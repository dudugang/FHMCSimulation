.TH "/home/nam4/Desktop/sandbox/FHMCSimulation/src/utilities.cpp" 3 "Thu Dec 22 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/nam4/Desktop/sandbox/FHMCSimulation/src/utilities.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'utilities\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBIM1\fP   2147483563"
.br
.ti -1c
.RI "#define \fBIM2\fP   2147483399"
.br
.ti -1c
.RI "#define \fBAM\fP   (1\&.0/\fBIM1\fP)"
.br
.ti -1c
.RI "#define \fBIMM1\fP   (\fBIM1\fP-1)"
.br
.ti -1c
.RI "#define \fBIA1\fP   40014"
.br
.ti -1c
.RI "#define \fBIA2\fP   40692"
.br
.ti -1c
.RI "#define \fBIQ1\fP   53668"
.br
.ti -1c
.RI "#define \fBIQ2\fP   52774"
.br
.ti -1c
.RI "#define \fBIR1\fP   12211"
.br
.ti -1c
.RI "#define \fBIR2\fP   3791"
.br
.ti -1c
.RI "#define \fBNTAB\fP   32"
.br
.ti -1c
.RI "#define \fBNDIV\fP   (1+\fBIMM1\fP/\fBNTAB\fP)"
.br
.ti -1c
.RI "#define \fBEPS\fP   1\&.2e-7"
.br
.ti -1c
.RI "#define \fBRNMX\fP   (1\&.0-\fBEPS\fP)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBpauseCode\fP (long int dur)"
.br
.RI "\fIPause the code for a certain time\&. \fP"
.ti -1c
.RI "std::vector< std::string > \fBsplitstr\fP (const std::string &s, char delim)"
.br
.RI "\fIC++ explode a string\&. \fP"
.ti -1c
.RI "std::string \fBgetTimeStamp\fP ()"
.br
.RI "\fIObtain instantaneous timestamp\&. \fP"
.ti -1c
.RI "std::vector< std::vector
.br
< double > > \fBmatrixProduct\fP (std::vector< std::vector< double > > &mat1, std::vector< std::vector< double > > &mat2)"
.br
.RI "\fICompute product of 2 matrices, W = UV\&. \fP"
.ti -1c
.RI "std::vector< std::vector
.br
< double > > \fBrotationMatrix\fP (const double alpha, const double beta, const double gamma)"
.br
.RI "\fICreate 3D rotation matrix from angles (x, then y, then z) \fP"
.ti -1c
.RI "std::vector< double > \fBrandom3DSurfaceVector\fP (const double magnitude)"
.br
.RI "\fIChose a random vector sampled from a random distribution on the surface of a sphere\&. \fP"
.ti -1c
.RI "double \fBrng\fP (int *idum)"
.br
.RI "\fIRandom number generator (from Numerical Recipes) \fP"
.ti -1c
.RI "void \fBpbc\fP (std::vector< double > &pos, const std::vector< double > &box)"
.br
.RI "\fIReplace a position inside a box assuming periodic boundary conditions\&. \fP"
.ti -1c
.RI "double \fBpbcDist2\fP (const std::vector< double > &p1, const std::vector< double > &p2, const std::vector< double > &box)"
.br
.RI "\fICalculate the minimum image distance squared between two coordinates assuming periodic boundary conditions\&. \fP"
.ti -1c
.RI "bool \fBfileExists\fP (std::string fileName)"
.br
.RI "\fIFunction to check whether a given file exists or not\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBRNG_SEED\fP = -1024"
.br
.RI "\fIDefault RNG seed\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define AM   (1\&.0/\fBIM1\fP)"

.PP
Definition at line 8 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define EPS   1\&.2e-7"

.PP
Definition at line 18 of file utilities\&.cpp\&.
.SS "#define IA1   40014"

.PP
Definition at line 10 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IA2   40692"

.PP
Definition at line 11 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IM1   2147483563"

.PP
Definition at line 6 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IM2   2147483399"

.PP
Definition at line 7 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IMM1   (\fBIM1\fP-1)"

.PP
Definition at line 9 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IQ1   53668"

.PP
Definition at line 12 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IQ2   52774"

.PP
Definition at line 13 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IR1   12211"

.PP
Definition at line 14 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IR2   3791"

.PP
Definition at line 15 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define NDIV   (1+\fBIMM1\fP/\fBNTAB\fP)"

.PP
Definition at line 17 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define NTAB   32"

.PP
Definition at line 16 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define RNMX   (1\&.0-\fBEPS\fP)"

.PP
Definition at line 19 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SH "Function Documentation"
.PP 
.SS "bool fileExists (std::stringfileName)"

.PP
Function to check whether a given file exists or not\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of file to check
.RE
.PP
\fBReturns:\fP
.RS 4
If file exists 
.RE
.PP

.PP
Definition at line 230 of file utilities\&.cpp\&.
.PP
Referenced by checkpoint::checkpoint(), checkpoint::load(), and tabulated::loadPotential()\&.
.PP
.nf
230                                     {
231     struct stat stFileInfo;
232 
233     if (stat(fileName\&.c_str(),&stFileInfo) == 0)
234         return true;
235     else
236         return false;
237 }
.fi
.SS "std::string getTimeStamp ()"

.PP
Obtain instantaneous timestamp\&. 
.PP
\fBReturns:\fP
.RS 4
char* timestamp 
.RE
.PP

.PP
Definition at line 49 of file utilities\&.cpp\&.
.PP
Referenced by checkpoint::dump(), initialize(), checkpoint::load(), performCrossover(), performTMMC(), performWALA(), moves::print(), and simSystem::readConfig()\&.
.PP
.nf
49                           {
50     time_t rawtime;
51     time (&rawtime);
52     struct tm * timeinfo;
53     timeinfo = localtime (&rawtime);
54     char timestamp [80];
55     strftime (timestamp,80,"%d/%m/%Y %H:%M:%S",timeinfo);
56     std::string ans (timestamp);
57     return ans;
58 }
.fi
.SS "std::vector< std::vector < double > > matrixProduct (std::vector< std::vector< double > > &mat1, std::vector< std::vector< double > > &mat2)"

.PP
Compute product of 2 matrices, W = UV\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat1\fP Matrix U 
.br
\fImat2\fP Matrix V 
.RE
.PP
\fBReturns:\fP
.RS 4
W 
.RE
.PP

.PP
Definition at line 67 of file utilities\&.cpp\&.
.PP
Referenced by rotationMatrix()\&.
.PP
.nf
67                                                                                                                                       {
68     std::vector < double > dummy (3, 0);
69     std::vector < std::vector < double > > W (3, dummy);
70 
71     for (unsigned int i = 0; i < 3; ++i) {
72         for (unsigned int j = 0; j < 3; ++j) {
73             W[i][j] = mat1[i][j]*mat2[j][i];
74         }
75     }
76 
77     return W;
78 }
.fi
.SS "void pauseCode (long intdur)"

.PP
Pause the code for a certain time\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP Number of seconds to pause for 
.RE
.PP

.PP
Definition at line 26 of file utilities\&.cpp\&.
.PP
.nf
26                               {
27     long int temp = time(NULL) + dur;
28     while(temp > time(NULL));
29 }
.fi
.SS "void pbc (std::vector< double > &pos, const std::vector< double > &box)"

.PP
Replace a position inside a box assuming periodic boundary conditions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Position to be placed in box 
.br
\fIbox\fP Box dimensions 
.RE
.PP

.PP
Definition at line 186 of file utilities\&.cpp\&.
.PP
Referenced by hardWallZ::energy(), squareWellWallZ::energy(), rightTriangleXZ::energy(), hardWallZ::inside(), and squareWellWallZ::inside()\&.
.PP
.nf
186                                                                       {
187     // generally while loops are faster than round statements
188     for (unsigned int i = 0; i < pos\&.size(); ++i) {
189         while (pos[i] < 0\&.0) {
190             pos[i] += box[i];
191         }
192         while (pos[i] >= box[i]) {
193             pos[i] -= box[i];
194         }
195     }
196 }
.fi
.SS "double pbcDist2 (const std::vector< double > &p1, const std::vector< double > &p2, const std::vector< double > &box)"

.PP
Calculate the minimum image distance squared between two coordinates assuming periodic boundary conditions\&. Coordinates do not have to be in the box to begin with\&.
.PP
\fBParameters:\fP
.RS 4
\fI\\p1\fP Position 1 
.br
\fI\\p1\fP Position 2 
.br
\fI\\box\fP Box size
.RE
.PP
\fBReturns:\fP
.RS 4
d2 (distance squared) 
.RE
.PP

.PP
Definition at line 207 of file utilities\&.cpp\&.
.PP
Referenced by lennardJones::energy(), fsLennardJones::energy(), cylinderZ::energy(), tabulated::energy(), squareWell::energy(), hardCore::energy(), cylinderZ::inside(), and aggVolBias3::make()\&.
.PP
.nf
207                                                                                                                   {
208     double d2 = 0\&.0;
209     for (unsigned int i = 0; i < p2\&.size(); ++i) {
210         double dr = p2[i] - p1[i];
211         while (dr < -box[i]/2\&.0) {
212             dr += box[i];
213         }
214         while (dr > box[i]/2\&.0) {
215             dr -= box[i];
216         }
217         d2 += dr*dr;
218     }
219 
220     return d2;
221 }
.fi
.SS "std::vector< double > random3DSurfaceVector (const doublemagnitude)"

.PP
Chose a random vector sampled from a random distribution on the surface of a sphere\&. 
.PP
\fBParameters:\fP
.RS 4
\fImagnitude\fP Mangitude of the vector (radius of sphere)
.RE
.PP
\fBReturns:\fP
.RS 4
ans double3 containing coordinates of vector 
.RE
.PP

.PP
Definition at line 124 of file utilities\&.cpp\&.
.PP
References rng(), and RNG_SEED\&.
.PP
Referenced by aggVolBias3::make()\&.
.PP
.nf
124                                                                     {
125     int success = 0;
126     std::vector < double > ans (3, 0);
127     while (success == 0) {
128         double r1 = rng(&RNG_SEED), r2 = rng(&RNG_SEED), x1 = 1\&.0-2\&.0*r1, x2 = 1\&.0-2\&.0*r2;
129         double sum2 = x1*x1+x2*x2;
130         if (sum2 < 1\&.0) {
131             ans[0] = 2*x1*sqrt(1-sum2)*magnitude;
132             ans[1] = 2*x2*sqrt(1-sum2)*magnitude;
133             ans[2] = (1-2\&.0*sum2)*magnitude;
134             success = 1;
135         }
136     }
137     return ans;
138 }
.fi
.SS "double rng (int *idum)"

.PP
Random number generator (from Numerical Recipes) 
.PP
\fBParameters:\fP
.RS 4
\fIidum\fP seed
.RE
.PP
\fBReturns:\fP
.RS 4
temp Pseudo-random number between [0, 1) 
.RE
.PP

.PP
Definition at line 147 of file utilities\&.cpp\&.
.PP
References AM, IA1, IA2, IM1, IM2, IMM1, IQ1, IQ2, IR1, IR2, NDIV, NTAB, and RNMX\&.
.PP
Referenced by aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), moves::makeMove(), random3DSurfaceVector(), and quaternion::setRandomRot()\&.
.PP
.nf
147                        {
148     int j;
149     long k;
150     static long idum2=123456789;
151     static long iy=0;
152     static long iv[NTAB];
153     double temp;
154 
155     if (*idum <= 0) {
156         if (-(*idum) < 1) *idum=1;
157         else *idum = -(*idum);
158         idum2=(*idum);
159         for (j=NTAB+7;j>=0;j--) {
160             k=(*idum)/IQ1;
161             *idum=IA1*(*idum-k*IQ1)-k*IR1;
162             if (*idum < 0) *idum += IM1;
163             if (j < NTAB) iv[j] = *idum;
164         } iy=iv[0];
165     }
166     k=(*idum)/IQ1;
167     *idum=IA1*(*idum-k*IQ1)-k*IR1;
168     if (*idum < 0) *idum += IM1;
169     k=idum2/IQ2;
170     idum2=IA2*(idum2-k*IQ2)-k*IR2;
171     if (idum2 < 0) idum2 += IM2;
172     j=iy/NDIV;
173     iy=iv[j]-idum2;
174     iv[j] = *idum;
175     if (iy < 1) iy += IMM1;
176     if ((temp=AM*iy) > RNMX) return RNMX;
177     else return temp;
178 }
.fi
.SS "std::vector< std::vector < double > > rotationMatrix (const doublealpha, const doublebeta, const doublegamma)"

.PP
Create 3D rotation matrix from angles (x, then y, then z) 
.PP
\fBParameters:\fP
.RS 4
\fIalpha\fP Radians to rotate centers by around x-axis 
.br
\fIbeta\fP Radians to rotate centers by around y-axis 
.br
\fIgamma\fP Radians to rotate centers by around z-axis 
.RE
.PP

.PP
Definition at line 87 of file utilities\&.cpp\&.
.PP
References matrixProduct()\&.
.PP
.nf
87                                                                                                               {
88 
89     std::vector < double > dummy (3, 0);
90     std::vector < std::vector < double > > Rx (3, dummy), Ry(3, dummy), Rz(3, dummy), Ryx, Rzyx;
91 
92     // https://en\&.wikipedia\&.org/wiki/Rotation_matrix#General_rotations
93     Rx[0][0] = 1\&.0;
94     Rx[1][1] = cos(alpha);
95     Rx[1][2] = -sin(alpha);
96     Rx[2][1] = sin(alpha);
97     Rx[2][2] = cos(alpha);
98 
99     Ry[0][0] = cos(beta);
100     Ry[0][2] = sin(beta);
101     Ry[1][1] = 1\&.0;
102     Ry[2][0] = -sin(beta);
103     Ry[2][2] = cos(beta);
104 
105     Rz[0][0] = cos(gamma);
106     Rz[0][1] = -sin(gamma);
107     Rz[1][0] = sin(gamma);
108     Rz[1][1] = cos(gamma);
109     Rz[2][2] = 1\&.0;
110 
111     Ryx = matrixProduct(Ry, Rx);
112     Rzyx = matrixProduct(Rz, Ryx);
113 
114     return Rzyx;
115 }
.fi
.SS "std::vector< std::string > splitstr (const std::string &s, chardelim)"

.PP
C++ explode a string\&. For converting to string\&. 
.PP
Definition at line 34 of file utilities\&.cpp\&.
.PP
.nf
34                                                                   {
35     std::stringstream ss(s);
36     std::string item;
37     std::vector <std::string> tokens;
38     while (std::getline(ss, item, delim)) {
39         tokens\&.push_back(item);
40     }
41     return tokens;
42 }
.fi
.SH "Variable Documentation"
.PP 
.SS "int RNG_SEED = -1024"

.PP
Default RNG seed\&. 
.PP
Definition at line 3 of file utilities\&.cpp\&.
.PP
Referenced by initialize(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), moves::makeMove(), random3DSurfaceVector(), and quaternion::setRandomRot()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
