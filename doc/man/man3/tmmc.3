.TH "tmmc" 3 "Mon Aug 10 2015" "Version v0.0.1" "Multicomponent  Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tmmc \- Transition Matrix Monte Carlo biasing class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <bias\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBtmmc\fP ()"
.br
.ti -1c
.RI "\fBtmmc\fP (const int Nmax, const int Nmin)"
.br
.RI "\fIInitialize the tmmc object\&. \fP"
.ti -1c
.RI "void \fBupdateC\fP (const int Nstart, const int Nend, const double pa)"
.br
.RI "\fIUpdate the collection matrix\&. \fP"
.ti -1c
.RI "void \fBcalculatePI\fP ()"
.br
.RI "\fICalculate the (natural logarithm of the) macrostate density matrix via the probability matrix\&. \fP"
.ti -1c
.RI "void \fBprint\fP (const std::string fileName, bool printC=false)"
.br
.RI "\fIPrint the UN-NORMALIZED biasing function (lnPI) and possibly collection matrix to files\&. \fP"
.ti -1c
.RI "void \fBreadC\fP (const std::string fileName)"
.br
.RI "\fIRead the collection matrix from a file\&. \fP"
.ti -1c
.RI "void \fBreadlnPI\fP (const std::string fileName)"
.br
.RI "\fIRead the macrostate distribution (biasing function) from a file\&. \fP"
.ti -1c
.RI "void \fBsetLnPI\fP (const std::vector< double > &lnPIguess)"
.br
.RI "\fIBlindly assign a guess of the macrostate distribution\&. \fP"
.ti -1c
.RI "bool \fBcheckFullyVisited\fP ()"
.br
.RI "\fICheck if the the collection matrix has been filled (i\&.e\&. \fP"
.ti -1c
.RI "const \fB__BIAS_INT_TYPE__\fP \fBgetTransitionAddress\fP (const int Nstart, const int Nend)"
.br
.RI "\fIFor a given multidimensional array which has been cast into 1D, find the address that refers to a given transition\&. \fP"
.ti -1c
.RI "const \fB__BIAS_INT_TYPE__\fP \fBgetAddress\fP (const int Nval)"
.br
.RI "\fIGet the address in lnPI that corresponds to a given macrostate\&. \fP"
.ti -1c
.RI "const double \fBgetBias\fP (const int address)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Transition Matrix Monte Carlo biasing class\&. 
.PP
Definition at line 23 of file bias\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "tmmc::tmmc ()\fC [inline]\fP"

.PP
Definition at line 25 of file bias\&.h\&.
.PP
.nf
25 {};
.fi
.SS "tmmc::tmmc (const int Nmax, const int Nmin)"

.PP
Initialize the tmmc object\&. 
.PP
\fBParameters:\fP
.RS 4
\fInSpec\fP Number of species in the simulation\&. 
.br
\fINmax\fP Upper bound for total number of particles\&. 
.br
\fINmin\fP Lower bound for total number of particles\&. 
.RE
.PP

.PP
Definition at line 11 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__\&.
.PP
.nf
11                                           {               
12                 if (Nmin > Nmax) {
13                                 throw customException ("Nmin > Nmax in TMMC bias");
14                 }
15                 __BIAS_INT_TYPE__ size = (Nmax - Nmin + 1);
16                 Nmin_ = Nmin;
17                 Nmax_ = Nmax;
18                 
19                 // attempt to allocate memory for collection matrix and initializes it all to 0
20                 try {
21                                 C_\&.resize(3*size, 0);
22                 } catch (const std::bad_alloc &ce) {
23                                 throw customException ("Out of memory, cannot allocate space for collection matrix in tmmc");
24                 }
25 
26                 // attempt to allocate memory for probability matrix and initializes it all to 0
27                 try {
28                                 P_\&.resize(3*size, 0);
29                 } catch (const std::bad_alloc &ce) {
30                                 throw customException ("Out of memory, cannot allocate space for probability matrix in tmmc");
31                 }
32                 
33                 // attempt to allocate memory for lnPI matrix and initializes it all to 0
34                 try {
35                                 lnPI_\&.resize(size, 0\&.0);
36                 } catch (const std::bad_alloc &ce) {
37                                 throw customException ("Out of memory, cannot allocate space for macrostate distribution matrix in tmmc");
38                 }
39 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void tmmc::calculatePI ()"

.PP
Calculate the (natural logarithm of the) macrostate density matrix via the probability matrix\&. 
.PP
Definition at line 116 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__, getTransitionAddress(), and sstr\&.
.PP
Referenced by main()\&.
.PP
.nf
116                         {
117                 for (__BIAS_INT_TYPE__ i = 0; i < C_\&.size(); i += 3) {
118                                 double sum = 0\&.0;
119                                 for (unsigned int j = 0; j < 3; ++j) {
120                                                 sum += C_[i+j];
121                                 }
122                                 if (sum > 0) {
123                                                 for (unsigned int j = 0; j < 3; ++j) {
124                                                                 P_[i+j] = C_[i+j] / sum;
125                                                 }
126                                 } else {
127                                                 // This state has not been visited at all if sum = 0\&.  However, at high system densities this could be the "correct"
128                                                 // result so this error may need to be discarded later in favor of:
129                                                 // P_[i+j] = 0;
130                                                 // However, having this throw an exception is also a good way to find that upper bound where the system is completely packed
131                                                 // so I will keep it this way for now\&.
132                                                 throw customException ("Cannot compute TMMC macrostate distribution because probability matrix contains zeros");
133                                 }
134                 }
135                 
136                 // Reset first value to zero just to start fresh\&. Since only ratios matter this is perfectly fair\&.
137                 lnPI_[0] = 0\&.0;
138                 __BIAS_INT_TYPE__ address1, address2;
139                 for (__BIAS_INT_TYPE__ i = 0; i < lnPI_\&.size()-1; ++i) {
140                                 address1 = getTransitionAddress(Nmin_+i, Nmin_+i+1);
141                                 address2 = getTransitionAddress(Nmin_+i+1, Nmin_+i);
142                                 if (!(P_[address1] > 0) || !(P_[address2] > 0)) {
143                                                 throw customException ("Cannot compute TMMC macrostate distribution because probability matrix contains zeros at address: P["+sstr(address1)+"] = "+sstr(P_[address1])+", P["+sstr(address2)+"] = "+sstr(P_[address2]));
144                                 }
145                                 lnPI_[i+1] = lnPI_[i] + log(P_[address1]/P_[address2]); // this is why P_ cannot be zero
146                 }
147 }
.fi
.SS "bool tmmc::checkFullyVisited ()"

.PP
Check if the the collection matrix has been filled (i\&.e\&. contains no zeros, except when crossing imposed bounds)\&. Technically, if in an ideal gas state, dU ~ 0 so pacc = 1\&.0, therefore probability of remaining in same state is 0\&. However, this matrix should be considered filled, if transitions to N+1 and N-1 for each N are found (except at bounds)\&. 
.PP
Definition at line 46 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__\&.
.PP
Referenced by main()\&.
.PP
.nf
46                               {
47                 for (__BIAS_INT_TYPE__ i = 0; i < C_\&.size(); i += 3) {
48                                 if (i == 0) {
49                                                 // lower bound, so only +1 move must be sampled
50                                                 if (!(C_[i+1] > 0)) {
51                                                                 return false;
52                                                 }                                               
53                                 } else if (i == C_\&.size()-3) {
54                                                 // upper bound, so only -1 move must be sampled
55                                                 if (!(C_[i+2] > 0)) {
56                                                                 return false;
57                                                 }
58                                 } else {
59                                                 // midpoints, both +1 and -1 moves must be sampled
60                                                 if (!(C_[i+1] > 0) || !(C_[i+2] > 0)) {
61                                                                 return false;
62                                                 }
63                                 }
64                 }
65                 return true;
66 }
.fi
.SS "const \fB__BIAS_INT_TYPE__\fP tmmc::getAddress (const int Nval)"

.PP
Get the address in lnPI that corresponds to a given macrostate\&. 
.PP
\fBParameters:\fP
.RS 4
\fINval\fP Number of total atoms 
.RE
.PP

.PP
Definition at line 95 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__\&.
.PP
Referenced by calculateBias()\&.
.PP
.nf
95                                                         {
96                 __BIAS_INT_TYPE__ x = Nval - Nmin_;
97                 return x;
98 }
.fi
.SS "const double tmmc::getBias (const int address)\fC [inline]\fP"

.PP
Definition at line 37 of file bias\&.h\&.
.PP
Referenced by calculateBias()\&.
.PP
.nf
37 { return -lnPI_[address]; }
.fi
.SS "const \fB__BIAS_INT_TYPE__\fP tmmc::getTransitionAddress (const int Nstart, const int Nend)"

.PP
For a given multidimensional array which has been cast into 1D, find the address that refers to a given transition\&. 
.PP
\fBParameters:\fP
.RS 4
\fINstart\fP Number of total species initially (before MC move) 
.br
\fINend\fP Number of total species (in order) after the MC move 
.RE
.PP

.PP
Definition at line 74 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__\&.
.PP
Referenced by calculatePI(), and updateC()\&.
.PP
.nf
74                                                                                     {
75                 // Layout of y = [0, +1, -1] 
76                 int addOrSubtract = (Nend - Nstart), y = 0;
77                 if (addOrSubtract == 0) {
78                                 y = 0;
79                 } else if (addOrSubtract == 1) {
80                                 y = 1;
81                 } else if (addOrSubtract == -1) {
82                                 y = 2;
83                 } else {
84                                 throw customException ("Illegal addOrSubtract value");
85                 }
86                 __BIAS_INT_TYPE__ x = Nstart - Nmin_;
87                 return x*3 + y;
88 }
.fi
.SS "void tmmc::print (const std::string fileName, bool printC = \fCfalse\fP)"

.PP
Print the UN-NORMALIZED biasing function (lnPI) and possibly collection matrix to files\&. Will overwrite the files if another with that name exists\&. Prints in netCDF format if enabled\&.
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of the file to print to\&. Will append with '_lnPI' and '_C' for biasing function and collection matrix, respectively\&. 
.br
\fIprintC\fP Defaults to false, but if true will also print the collection matrix\&. 
.RE
.PP

.PP
Definition at line 157 of file bias\&.cpp\&.
.PP
References sstr\&.
.PP
Referenced by main()\&.
.PP
.nf
157                                                        {
158 #ifdef NETCDF_CAPABLE
159                 // Print collection matrix
160                 if (printC) {
161                                 const std::string name = fileName + "_C\&.nc"
162                                 NcFile outFile(name\&.c_str(), NcFile::replace);
163                                 NcDim probDim = outFile\&.addDim("vectorized_position", C_\&.size());
164                                 NcVar probVar = outFile\&.addVar("C", ncDouble, probDim);
165                                 const std::string dummyName = "number_species:";
166                                 probVar\&.putAtt(dummyName\&.c_str(), sstr(nSpec_)\&.c_str());
167                                 const std::string attName = "species_total_upper_bound:";
168                                 probVar\&.putAtt(attName\&.c_str(), sstr(Nmax_)\&.c_str());
169                                 const std::string attName = "species_total_lower_bound:";
170                                 probVar\&.putAtt(attName\&.c_str(), sstr(Nmin_)\&.c_str());
171                                 probVar\&.putVar(&C_[0]);
172                 }
173                 
174                 // Print lnPI (bias) matrix
175                 const std::string name = fileName + "_lnPI\&.nc"
176                 NcFile outFile(name\&.c_str(), NcFile::replace);
177                 NcDim probDim = outFile\&.addDim("vectorized_position", lnPI_\&.size());
178                 NcVar probVar = outFile\&.addVar("lnPI", ncDouble, probDim);
179                 const std::string attName = "species_total_upper_bound:";
180                 probVar\&.putAtt(attName\&.c_str(), sstr(Nmax_)\&.c_str());
181                 const std::string attName = "species_total_lower_bound:";
182                 probVar\&.putAtt(attName\&.c_str(), sstr(Nmin_)\&.c_str());
183                 probVar\&.putVar(&lnPI_[0]);
184 #else
185                 // Print collection matrix
186                 if (printC) {
187                                 std::ofstream of;
188                                 of\&.open(fileName+"_C\&.dat", std::ofstream::out);
189                                 of << "# Collection matrix in single row (vectorized) notation\&." << std::endl;
190                                 of << "# species_total_upper_bound: " << Nmax_ << std::endl;
191                                 of << "# species_total_lower_bound: " << Nmin_ << std::endl;
192                                 for (long long int i = 0; i < C_\&.size(); ++i) {
193                                                 of << C_[i] << std::endl;
194                                 }
195                                 of\&.close();
196                 }
197                 
198                 // Print lnPI (bias) matrix
199                 std::ofstream of;
200                 of\&.open(fileName+"_lnPI\&.dat", std::ofstream::out);
201                 of << "# lnPI (bias) matrix in single row (vectorized) notation\&." << std::endl;
202                 of << "# species_total_upper_bound: " << Nmax_ << std::endl;
203                 of << "# species_total_lower_bound: " << Nmin_ << std::endl;
204                 for (long long int i = 0; i < lnPI_\&.size(); ++i) {
205                                 of << lnPI_[i] << std::endl;
206                 }
207                 of\&.close();
208 #endif
209 }
.fi
.SS "void tmmc::readC (const std::string fileName)"

.PP
Read the collection matrix from a file\&. This assumes the user has already guaranteed that the bounds are consistent, e\&.g\&. Nmin and Nmax, as it will not check this automatically\&. Also assumes file was generated by this code\&. 'Hand made' ones might have formatting issues since parsing is done based on tokens\&.
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of file containing the collection matrix\&. Must include file extension\&. 
.RE
.PP

.PP
Definition at line 218 of file bias\&.cpp\&.
.PP
References __BIAS_INT_TYPE__\&.
.PP
.nf
218                                           {
219 #ifdef NETCDF_CAPABLE
220                 NcFile dataFile (fileName\&.c_str(), NcFile::read);
221                 NcVar C_data = dataFile\&.getVar("C");
222                 if (C_data\&.isNull()) throw customException("Collection matrix was empty, cannot read");
223                 C_data\&.getVar(&C_[0]);
224 #else
225                 std::string line;
226                 std::ifstream inF (fileName);
227                 
228                 // Skip file header
229                 bool header = true;
230                 while (header) {
231                                 std::getline (inF, line);
232                                 if (line\&.compare(0,1,"#",0,1) != 0) {
233                                                 header = false;
234                                 }
235                 }
236                 
237                 // Read line by line, parsing based on token
238                 C_[0] = atof(line\&.c_str());
239                 __BIAS_INT_TYPE__ index = 1;
240                 while (inF >> C_[index]) {
241                                 index++;
242                 }
243 #endif
244 }
.fi
.SS "void tmmc::readlnPI (const std::string fileName)"

.PP
Read the macrostate distribution (biasing function) from a file\&. This assumes the user has already guaranteed that the bounds are consistent, e\&.g\&. Nmin and Nmax, as it will not check this automatically\&. Also assumes file was generated by this code\&. 'Hand made' ones might have formatting issues since parsing is done based on tokens\&.
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of file containing lnPI\&. Must include file extension\&. 
.RE
.PP

.PP
Definition at line 253 of file bias\&.cpp\&.
.PP
.nf
253                                              {
254 #ifdef NETCDF_CAPABLE
255                 NcFile dataFile (fileName\&.c_str(), NcFile::read);
256                 NcVar lnPI_data = dataFile\&.getVar("lnPI");
257                 if (lnPI_data\&.isNull()) throw customException("Macrostate distribution matrix (biasing function) was empty, cannot read");
258                 lnPI_data\&.getVar(&lnPI_[0]);
259 #else
260                 std::string line;
261                 std::ifstream inF (fileName);
262                 
263                 // Skip file header
264                 bool header = true;
265                 while (header) {
266                                 std::getline (inF, line);
267                                 if (line\&.compare(0,1,"#",0,1) != 0) {
268                                                 header = false;
269                                 }
270                 }
271                 
272                 // Read line by line, parsing based on token
273                 lnPI_[0] = atof(line\&.c_str());
274                 long long int index = 1;
275                 while (inF >> lnPI_[index]) {
276                                 index++;
277                 }
278 #endif
279 }
.fi
.SS "void tmmc::setLnPI (const std::vector< double > & lnPIguess)\fC [inline]\fP"

.PP
Blindly assign a guess of the macrostate distribution\&. 
.PP
Definition at line 33 of file bias\&.h\&.
.PP
Referenced by main()\&.
.SS "void tmmc::updateC (const int Nstart, const int Nend, const double pa)"

.PP
Update the collection matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fINstart\fP Total number of atoms initially (before MC move) 
.br
\fINend\fP Total number of atoms after the MC move 
.br
\fIpa\fP Unbiased Metropolis criterion for making a MC move (i\&.e\&. pa = min(1, exp(\&.\&.\&.))) 
.RE
.PP

.PP
Definition at line 107 of file bias\&.cpp\&.
.PP
References getTransitionAddress()\&.
.PP
Referenced by calculateBias()\&.
.PP
.nf
107                                                                      {
108                 const int i = getTransitionAddress(Nstart, Nend), j = getTransitionAddress(Nstart, Nstart);
109                 C_[i] += pa;
110                 C_[j] += (1-pa);
111 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Multicomponent Monte Carlo Simulation from the source code\&.
