.TH "insertParticle" 3 "Thu Dec 22 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
insertParticle \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <insert\&.h>\fP
.PP
Inherits \fBmcMove\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBinsertParticle\fP ()"
.br
.ti -1c
.RI "\fBinsertParticle\fP (const int typeIndex, const std::string tag)"
.br
.RI "\fIInstantiate a new move, also give a name which is the combination of auser-defined tag + the particle index it operates on\&. \fP"
.ti -1c
.RI "int \fBmake\fP (\fBsimSystem\fP &sys)"
.br
.RI "\fIInsert a particle into the system\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 14 of file insert\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "insertParticle::insertParticle ()\fC [inline]\fP"

.PP
Definition at line 16 of file insert\&.h\&.
.PP
References mcMove::changeN_\&.
.PP
.nf
16 { changeN_ = true; }
.fi
.SS "insertParticle::insertParticle (const inttypeIndex, const std::stringtag)\fC [inline]\fP"

.PP
Instantiate a new move, also give a name which is the combination of auser-defined tag + the particle index it operates on\&. 
.PP
Definition at line 17 of file insert\&.h\&.
.PP
References mcMove::changeN_, mcMove::name_, and mcMove::typeIndex_\&.
.SH "Member Function Documentation"
.PP 
.SS "int insertParticle::make (\fBsimSystem\fP &sys)\fC [virtual]\fP"

.PP
Insert a particle into the system\&. All other information is stored in the \fBsimSystem\fP object\&.
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System object to attempt to insert a particle into\&.
.RE
.PP
\fBReturns:\fP
.RS 4
MOVE_SUCCESS if inserted a particle, otherwise MOVE_FAILURE if did not\&. Will throw exceptions if there was an error\&. 
.RE
.PP

.PP
Implements \fBmcMove\fP\&.
.PP
Definition at line 10 of file insert\&.cpp\&.
.PP
References simSystem::addKECorrection(), simSystem::beta(), simSystem::box(), calculateBias(), simSystem::getCurrentM(), simSystem::getFractionalAtom(), simSystem::getNeighborAtoms(), simSystem::getTotalM(), simSystem::getTotN(), simSystem::getWALABias(), H2_2PI, simSystem::incrementEnergy(), simSystem::insertAtom(), simSystem::mass(), simSystem::maxSpecies(), MOVE_FAILURE, MOVE_SUCCESS, atom::mState, simSystem::mu(), simSystem::nSpecies(), simSystem::numSpecies, atom::pos, simSystem::ppot, rng(), RNG_SEED, simSystem::speciesBarriers, simSystem::tmmcBias, simSystem::totNMax(), mcMove::typeIndex_, wala::update(), tmmc::updateC(), simSystem::useTMMC, simSystem::useWALA, and customException::what()\&.
.PP
.nf
10                                         {
11     bool earlyReject = false;
12 
13     // check if at upper bound for this specific species type
14     if (sys\&.numSpecies[typeIndex_] >= sys\&.maxSpecies(typeIndex_)) {
15             earlyReject = true;
16     }
17 
18     // also check if at upper bound for total number of atoms
19     if (sys\&.getTotN() >= sys\&.totNMax()) {
20         earlyReject = true;
21     }
22 
23     // updates to biasing functions must be done even if at bounds
24     if (earlyReject) {
25         if (sys\&.useWALA) {
26              sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
27         }
28         if (sys\&.useTMMC) {
29                     int nTotFinal = sys\&.getTotN(), mFinal = sys\&.getCurrentM() + 1;
30                     if (sys\&.getCurrentM() == sys\&.getTotalM()-1) {
31                         nTotFinal++;
32                         mFinal = 0;
33                     }
34             sys\&.tmmcBias->updateC (sys\&.getTotN(), nTotFinal, sys\&.getCurrentM(), mFinal, 0\&.0);
35         }
36         return MOVE_FAILURE;
37     }
38 
39     const std::vector < double > box = sys\&.box();
40     double V = 1\&.0;
41     for (unsigned int i = 0; i < box\&.size(); ++i) {
42         V *= box[i];
43     }
44 
45     double insEnergy = 0\&.0;
46     int origState = 0;
47     bool createdAtom = false;
48 
49     // reference N state
50     long long int nHigh = sys\&.numSpecies[typeIndex_]+1;
51 
52         atom* newAtom;
53         if (sys\&.getCurrentM() == 0) {
54             // attempt to insert a brand new one
55             newAtom = new atom;
56             createdAtom = true;
57             origState = 0;
58             if (sys\&.getTotalM() > 1) {
59                 newAtom->mState = 1; // incremental insertion state if doing expanded ensemble, otherwise leave as 0
60             }
61             for (unsigned int i = 0; i < box\&.size(); ++i) {
62                 newAtom->pos[i] = rng (&RNG_SEED) * box[i];
63             }
64         } else {
65             // continue to try to insert the partially inserted one
66             // don't increment the state yet
67             newAtom = sys\&.getFractionalAtom(); // mcMove object guarantees we are only making this move if the fractional atom if type typeIndex_
68             origState = newAtom->mState;
69 
70             // if doing expanded ensemble and one is already partially inserted, have to get baseline, else this baseline is 0
71             for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
72                 // get positions of neighboring atoms around newAtom
73                 std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms (spec, typeIndex_, newAtom);
74                     for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
75                     try {
76                         insEnergy -= sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], newAtom, box);
77                     } catch (customException& ce) {
78                         std::string a = "Cannot insert because of energy error: ", b = ce\&.what();
79                         if (createdAtom) {
80                             delete newAtom;
81                         }
82                         throw customException (a+b);
83                     }
84                     }
85                     // neglect all tail corrections for partially inserted particles
86             }
87 
88             // account for any wall or barrier interactions
89             insEnergy -= sys\&.speciesBarriers[typeIndex_]\&.energy(newAtom, box);
90 
91             // now increment the expanded ensemble state after baseline has been calculated
92             newAtom->mState += 1;
93             if (newAtom->mState == sys\&.getTotalM()) {
94                 newAtom->mState = 0;
95             }
96         }
97 
98         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
99             // get positions of neighboring atoms around newAtom
100             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms (spec, typeIndex_, newAtom);
101             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
102             try {
103                 insEnergy += sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], newAtom, box);
104             } catch (customException& ce) {
105                 std::string a = "Cannot insert because of energy error: ", b = ce\&.what();
106                 if (createdAtom) {
107                     delete newAtom;
108                 }
109                 throw customException (a+b);
110             }
111             }
112             // add tail correction to potential energy -- only enable for fluid phase simulations
113 #ifdef FLUID_PHASE_SIMULATIONS
114             if (sys\&.ppot[spec][typeIndex_]->useTailCorrection) {
115                 if (newAtom->mState == 0) { // the mState was updated above to be what the atom will be if move is accepted
116                     // if current atom becomes a full atom, include tail corrections
117                         if (sys\&.numSpecies[spec] > 0) {
118                                 insEnergy += sys\&.ppot[spec][typeIndex_]->tailCorrection(sys\&.numSpecies[spec]/V);
119                         }
120                     }
121             }
122 #endif
123         }
124 
125         // account for any wall or barrier interaction
126         insEnergy += sys\&.speciesBarriers[typeIndex_]\&.energy(newAtom, box);
127 
128         // restore the original mState of the newAtom
129         newAtom->mState = origState;
130 
131         // biasing
132     double dN = 1\&.0/sys\&.getTotalM();
133     double p_u = 0\&.0;
134     if (sys\&.addKECorrection()) {
135         const double Lambda3 = pow(H2_2PI*sys\&.beta()/sys\&.mass(typeIndex_), 1\&.5);
136         p_u = pow(V/nHigh/Lambda3, dN)*exp(sys\&.beta()*(sys\&.mu(typeIndex_)*dN - insEnergy));
137     } else {
138         p_u = pow(V/nHigh, dN)*exp(sys\&.beta()*(sys\&.mu(typeIndex_)*dN - insEnergy));
139     }
140         int nTotFinal = sys\&.getTotN(), mFinal = sys\&.getCurrentM() + 1;
141         if (sys\&.getCurrentM() == sys\&.getTotalM()-1) {
142             nTotFinal++;
143             mFinal = 0;
144             if (sys\&.addKECorrection()) {
145                 insEnergy += 1\&.5/sys\&.beta();
146             }
147         }
148         double bias = calculateBias(sys, nTotFinal, mFinal);
149 
150         // tmmc gets updated the same way, regardless of whether the move gets accepted
151         if (sys\&.useTMMC) {
152             sys\&.tmmcBias->updateC (sys\&.getTotN(), nTotFinal, sys\&.getCurrentM(), mFinal, std::min(1\&.0, p_u));
153         }
154 
155     // metropolis criterion
156     if (rng (&RNG_SEED) < p_u*bias) {
157             try {
158                     sys\&.insertAtom(typeIndex_, newAtom);
159             } catch (customException &ce) {
160                     std::string a = "Failed to insert atom: ", b = ce\&.what();
161             if (createdAtom) {
162                 delete newAtom;
163             }
164                     throw customException (a+b);
165             }
166         sys\&.incrementEnergy(insEnergy);
167 
168         // update Wang-Landau bias, if used
169         if (sys\&.useWALA) {
170             sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
171         }
172 
173         if (createdAtom) {
174             delete newAtom;
175         }
176 
177             return MOVE_SUCCESS;
178         }
179 
180     // update Wang-Landau bias (even if moved failed), if used
181     if (sys\&.useWALA) {
182         sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
183     }
184 
185     if (createdAtom) {
186         delete newAtom;
187     }
188 
189     return MOVE_FAILURE;
190 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
