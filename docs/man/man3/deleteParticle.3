.TH "deleteParticle" 3 "Thu Dec 29 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
deleteParticle \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <delete\&.h>\fP
.PP
Inherits \fBmcMove\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBdeleteParticle\fP ()"
.br
.ti -1c
.RI "\fBdeleteParticle\fP (const int typeIndex, const std::string tag)"
.br
.RI "\fIInstantiate a new move, also give a name which is the combination of auser-defined tag + the particle index it operates on\&. \fP"
.ti -1c
.RI "int \fBmake\fP (\fBsimSystem\fP &sys)"
.br
.RI "\fIDelete a particle from the system\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 13 of file delete\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "deleteParticle::deleteParticle ()\fC [inline]\fP"

.PP
Definition at line 15 of file delete\&.h\&.
.PP
References mcMove::changeN_\&.
.PP
.nf
15 { changeN_ = true; }
.fi
.SS "deleteParticle::deleteParticle (const inttypeIndex, const std::stringtag)\fC [inline]\fP"

.PP
Instantiate a new move, also give a name which is the combination of auser-defined tag + the particle index it operates on\&. 
.PP
Definition at line 16 of file delete\&.h\&.
.PP
References mcMove::changeN_, mcMove::name_, and mcMove::typeIndex_\&.
.SH "Member Function Documentation"
.PP 
.SS "int deleteParticle::make (\fBsimSystem\fP &sys)\fC [virtual]\fP"

.PP
Delete a particle from the system\&. All other information is stored in the \fBsimSystem\fP object\&.
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System object to attempt to remove a particle from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
MOVE_SUCCESS if deleted a particle, otherwise MOVE_FAILURE if did not\&. Will throw exceptions if there was an error\&. 
.RE
.PP

.PP
Implements \fBmcMove\fP\&.
.PP
Definition at line 10 of file delete\&.cpp\&.
.PP
References simSystem::addKECorrection(), simSystem::atoms, simSystem::beta(), simSystem::box(), calculateBias(), simSystem::deleteAtom(), simSystem::getCurrentM(), simSystem::getFractionalAtom(), simSystem::getNeighborAtoms(), simSystem::getTotalM(), simSystem::getTotN(), simSystem::getWALABias(), H2_2PI, simSystem::incrementEnergy(), simSystem::mass(), simSystem::minSpecies(), MOVE_FAILURE, MOVE_SUCCESS, atom::mState, simSystem::mu(), simSystem::nSpecies(), simSystem::numSpecies, simSystem::ppot, rng(), RNG_SEED, simSystem::speciesBarriers, simSystem::tmmcBias, simSystem::totNMin(), mcMove::typeIndex_, wala::update(), tmmc::updateC(), simSystem::useTMMC, simSystem::useWALA, and customException::what()\&.
.PP
.nf
10                                         {
11     bool earlyReject = false;
12 
13     // check if any can be deleted from this species
14     if (sys\&.numSpecies[typeIndex_] < sys\&.minSpecies(typeIndex_)) {
15         earlyReject = true;
16         }
17         if (sys\&.numSpecies[typeIndex_] == sys\&.minSpecies(typeIndex_) && sys\&.getCurrentM() == 0) {
18             earlyReject = true;
19         }
20 
21         // also check if at global bound on total number of particles
22         if (sys\&.getTotN() < sys\&.totNMin()) {
23             earlyReject = true;
24         }
25         if (sys\&.getTotN() == sys\&.totNMin() && sys\&.getCurrentM() == 0) { // move class guarantees only operating on the correct species already
26             earlyReject = true;
27         }
28 
29     // updates to biasing functions must be done even if at bounds
30         if (earlyReject) {
31             if (sys\&.useWALA) {
32                     sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
33             }
34             if (sys\&.useTMMC) {
35                     int nTotFinal = sys\&.getTotN(), mFinal = sys\&.getCurrentM() - 1;
36                     if (sys\&.getCurrentM() == 0) {
37                         nTotFinal--;
38                         mFinal = sys\&.getTotalM() - 1;
39                     }
40                     sys\&.tmmcBias->updateC (sys\&.getTotN(), nTotFinal, sys\&.getCurrentM(), mFinal, 0\&.0);
41             }
42             return MOVE_FAILURE;
43         }
44 
45     const std::vector < double > box = sys\&.box();
46     double V = 1\&.0;
47     for (unsigned int i = 0; i < box\&.size(); ++i) {
48         V *= box[i];
49     }
50 
51     double delEnergy = 0\&.0;
52 
53     // initial guess at the N state we are coming from
54         long long int nHigh = sys\&.numSpecies[typeIndex_];
55 
56     atom* chosenAtom;
57         if (sys\&.getCurrentM() == 0) {
58             // pick a brand new one to delete
59             chosenAtom = &sys\&.atoms[typeIndex_][(int) floor(rng (&RNG_SEED) * sys\&.numSpecies[typeIndex_])];
60             nHigh = sys\&.numSpecies[typeIndex_];
61         } else {
62             // continue to try to delete the partially deleted one
63             chosenAtom = sys\&.getFractionalAtom(); // mcMove guarantees this move only being made if fractional atom of type typeIndex_
64             nHigh = sys\&.numSpecies[typeIndex_] + 1; // again mcMove guarantees this species is the fractional one, reference has to be at the next fully inserted level
65     }
66 
67         // get baseline as the particle currently is
68         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
69             // get positions of neighboring atoms around chosenAtom
70             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex_, chosenAtom);
71             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
72                     try {
73                 delEnergy -= sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], chosenAtom, box);
74             } catch (customException& ce) {
75                 std::string a = "Cannot delete because of energy error: ", b = ce\&.what();
76                 throw customException (a+b);
77             }
78             }
79             // add tail correction to potential energy -- only enable for fluid phase simulations
80 #ifdef FLUID_PHASE_SIMULATIONS
81             if (sys\&.ppot[spec][typeIndex_]->useTailCorrection) {
82                 if (chosenAtom->mState == 0) {
83                     // if current atom is a full atom right now, include tail corrections
84                     if (spec == typeIndex_) {
85                                 if (sys\&.numSpecies[spec]-1 > 0) {
86                                     delEnergy -= sys\&.ppot[spec][typeIndex_]->tailCorrection((sys\&.numSpecies[spec]-1)/V);
87                                 }
88                     } else {
89                                 if (sys\&.numSpecies[spec] > 0) {
90                                     delEnergy -= sys\&.ppot[spec][typeIndex_]->tailCorrection(sys\&.numSpecies[spec]/V);
91                                 }
92                         }
93                 }
94             }
95 #endif
96         }
97 
98         // also account for any wall or barrier interaction
99     delEnergy -= sys\&.speciesBarriers[typeIndex_]\&.energy(chosenAtom, box);
100 
101         // if the particle is about to be completely removed, no further calculation is required
102         if (chosenAtom->mState != 1 && sys\&.getTotalM() > 1) { // if 1, it is just completely removed - otherwise have to do calculation since in expanded ensemble if M > 1
103             // temporarily decrement the expanded ensemble state on the atom
104             int orig_state = chosenAtom->mState;
105             chosenAtom->mState -= 1;
106             if (chosenAtom->mState < 0) {
107                 chosenAtom->mState = sys\&.getTotalM() - 1;
108             }
109 
110             for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
111                 // get positions of neighboring atoms around chosenAtom
112                     std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex_, chosenAtom);
113                     for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
114                         try {
115                         delEnergy += sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], chosenAtom, box);
116                     } catch (customException& ce) {
117                         std::string a = "Cannot delete because of energy error: ", b = ce\&.what();
118                         throw customException (a+b);
119                     }
120                     }
121                     // no tail corrections for partially inserted particles
122             }
123 
124             // also account for any wall or barrier interaction
125             delEnergy += sys\&.speciesBarriers[typeIndex_]\&.energy(chosenAtom, box);
126 
127             // restore the expanded ensemble state
128             chosenAtom->mState = orig_state;
129         }
130 
131         // biasing
132         double dN = 1\&.0/sys\&.getTotalM();
133     double p_u = 1\&.0;
134     if (sys\&.addKECorrection()) {
135         const double Lambda3 = pow(H2_2PI*sys\&.beta()/sys\&.mass(typeIndex_), 1\&.5);
136         p_u = pow(Lambda3*nHigh/V, dN)*exp(sys\&.beta()*(-sys\&.mu(typeIndex_)*dN - delEnergy));
137     } else {
138         p_u = pow(nHigh/V, dN)*exp(sys\&.beta()*(-sys\&.mu(typeIndex_)*dN - delEnergy));
139     }
140 
141         int nTotFinal = sys\&.getTotN(), mFinal = sys\&.getCurrentM() - 1;
142         if (sys\&.getCurrentM() == 0) {
143             nTotFinal--;
144             mFinal = sys\&.getTotalM() - 1;
145             if (sys\&.addKECorrection()) {
146                 delEnergy -= 1\&.5/sys\&.beta();
147             }
148         }
149         double bias = calculateBias(sys, nTotFinal, mFinal);
150 
151         // tmmc gets updated the same way, regardless of whether the move gets accepted
152         if (sys\&.useTMMC) {
153             sys\&.tmmcBias->updateC (sys\&.getTotN(), nTotFinal, sys\&.getCurrentM(), mFinal, std::min(1\&.0, p_u)); // also has to be function of N and M now
154         }
155 
156     // metropolis criterion
157     if (rng (&RNG_SEED) < p_u*bias) {
158         int counter = 0;
159         for (std::vector<atom>::iterator it = sys\&.atoms[typeIndex_]\&.begin(); it != sys\&.atoms[typeIndex_]\&.end(); ++it) {
160             if (&(*it) == chosenAtom) {
161                 break;
162             } else {
163                 counter++;
164             }
165         }
166             try {
167                     sys\&.deleteAtom(typeIndex_, counter);
168             } catch (customException &ce) {
169                     std::string a = "Failed to delete atom: ", b = ce\&.what();
170                     throw customException (a+b);
171             }
172         sys\&.incrementEnergy(delEnergy);
173 
174         // update Wang-Landau bias, if used
175         if (sys\&.useWALA) {
176             sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
177         }
178 
179             return MOVE_SUCCESS;
180         }
181 
182     // update Wang-Landau bias (even if moved failed), if used
183     if (sys\&.useWALA) {
184         sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
185     }
186 
187     return MOVE_FAILURE;
188 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
