.TH "/home/nam4/Desktop/sandbox/FHMCSimulation/src/input.h" 3 "Thu Dec 29 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/nam4/Desktop/sandbox/FHMCSimulation/src/input.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <string>\fP
.br
\fC#include 'mover\&.h'\fP
.br
\fC#include 'system\&.h'\fP
.br
\fC#include 'insert\&.h'\fP
.br
\fC#include 'delete\&.h'\fP
.br
\fC#include 'translate\&.h'\fP
.br
\fC#include 'swap\&.h'\fP
.br
\fC#include 'utilities\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBsimSystem\fP \fBinitialize\fP (const std::string filename, \fBmoves\fP *eqMoves, \fBmoves\fP *prMoves)"
.br
.RI "\fIParse a json input file and initialize system object accordingly\&. \fP"
.ti -1c
.RI "void \fBsetConfig\fP (\fBsimSystem\fP &sys, const std::string filename)"
.br
.RI "\fISetup a system's initial configuration as necessary\&. \fP"
.ti -1c
.RI "void \fBsetMoves\fP (\fBsimSystem\fP &sys, const rapidjson::Document &doc, \fBmoves\fP *usedMovesEq, \fBmoves\fP *usedMovesPr)"
.br
.RI "\fIAssign the Monte Carlo moves based on the JSON input file\&. \fP"
.ti -1c
.RI "void \fBsetSystemBarriers\fP (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"
.br
.RI "\fIInitialize the barriers in a system by parsing the input document\&. \fP"
.ti -1c
.RI "void \fBsetPairPotentials\fP (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"
.br
.RI "\fIAssign the pair potentials based on the JSON input file\&. \fP"
.ti -1c
.RI "void \fBcheckBounds\fP (\fBsimSystem\fP &sys)"
.br
.RI "\fICheck the following bounds on system\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void checkBounds (\fBsimSystem\fP &sys)"

.PP
Check the following bounds on system\&. If any fail, an emergency exit is performed\&.
.IP "1." 4
Check all pair potentials are set\&.
.IP "2." 4
Check that rcut < L/2 for all potentials
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to check bounds on 
.RE
.PP

.PP
Definition at line 10 of file input\&.cpp\&.
.PP
References simSystem::box(), simSystem::nSpecies(), numToStr(), simSystem::potentialIsSet(), simSystem::ppot, sendErr(), and SYS_FAILURE\&.
.PP
Referenced by initialize()\&.
.PP
.nf
10                                   {
11     // check all pair potentials have been set and all r_cut < L/2
12     double minL = sys\&.box()[0];
13     for (unsigned int i = 1; i < 3; ++i) {
14         minL = std::min(minL, sys\&.box()[i]);
15     }
16     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
17         for (unsigned int j = 0; j < sys\&.nSpecies(); ++j) {
18             if (!sys\&.potentialIsSet(i, j)) {
19                 sendErr("Not all pair potentials are set");
20                 exit(SYS_FAILURE);
21             }
22             if (!(sys\&.ppot[i][j]->rcut() < minL/2\&.0)) {
23                 sendErr("Pair potential r_cut for species "+numToStr(i)+", "+numToStr(j)+" is > L/2");
24                 exit(SYS_FAILURE);
25             }
26         }
27     }
28 }
.fi
.SS "\fBsimSystem\fP initialize (const std::stringfilename, \fBmoves\fP *usedMovesEq, \fBmoves\fP *usedMovesPr)"

.PP
Parse a json input file and initialize system object accordingly\&. [in] filename Input JSON document's filename  [in] usedMovesEq Pointer to move object that will be used during 'equilibration' (WL)  [in] usedMovesPr Pointer to move object that will be used during 'production' (TMMC) 
.PP
Definition at line 37 of file input\&.cpp\&.
.PP
References simSystem::addKECorrection(), checkBounds(), simSystem::lnF_end, simSystem::lnF_start, simSystem::nCrossoverVisits, parseJson(), simSystem::restartFromTMMC, simSystem::restartFromTMMCFile, simSystem::restartFromWALA, simSystem::restartFromWALAFile, RNG_SEED, sendErr(), sendMsg(), setMoves(), setPairPotentials(), setSystemBarriers(), simSystem::setTotNBounds(), SYS_FAILURE, simSystem::tmmcSweepSize, simSystem::toggleKE(), simSystem::totalTMMCSweeps, simSystem::wala_g, simSystem::wala_s, and simSystem::wlSweepSize\&.
.PP
.nf
37                                                                                         {
38     rapidjson::Document doc;
39     parseJson (filename, doc);
40 
41     // Check each member exists and is in the correct format
42     assert(doc\&.HasMember("num_species"));
43     assert(doc["num_species"]\&.IsInt());
44     assert(doc\&.HasMember("beta"));
45     assert(doc["beta"]\&.IsNumber());
46 
47     assert(doc\&.HasMember("box"));
48     assert(doc["box"]\&.IsArray());
49     assert(doc["box"]\&.Size() == 3);
50     std::vector < double > sysBox (3, 0);
51     for (rapidjson::SizeType i = 0; i < doc["box"]\&.Size(); ++i) {
52         assert(doc["box"][i]\&.IsNumber());
53         sysBox[i] = doc["box"][i]\&.GetDouble();
54     }
55 
56     double duh = 10\&.0;
57     if (doc\&.HasMember("delta_u_hist")) {
58         assert(doc["delta_u_hist"]\&.IsNumber());
59         duh = doc["delta_u_hist"]\&.GetDouble();
60     }
61 
62     int max_order = 2;
63     if (doc\&.HasMember("max_order")) {
64         assert(doc["max_order"]\&.IsNumber());
65         max_order = doc["max_order"]\&.GetInt();
66     }
67 
68     bool use_ke = false;
69     if (doc\&.HasMember("use_ke")) {
70         assert(doc["use_ke"]\&.IsBool());
71         use_ke = doc["use_ke"]\&.GetBool();
72     }
73 
74     assert(doc\&.HasMember("mu"));
75     assert(doc["mu"]\&.IsArray());
76     assert(doc["mu"]\&.Size() == doc["num_species"]\&.GetInt());
77     std::vector < double > sysMu (doc["mu"]\&.Size(), 0);
78     for (rapidjson::SizeType i = 0; i < doc["mu"]\&.Size(); ++i) {
79         assert(doc["mu"][i]\&.IsNumber());
80         sysMu[i] = doc["mu"][i]\&.GetDouble();
81     }
82 
83     assert(doc\&.HasMember("seed"));
84     assert(doc["seed"]\&.IsInt());
85     RNG_SEED = doc["seed"]\&.GetInt();
86 
87     assert(doc\&.HasMember("max_N"));
88     assert(doc["max_N"]\&.IsArray());
89     assert(doc["max_N"]\&.Size() == doc["num_species"]\&.GetInt());
90     std::vector < int > sysMax (doc["max_N"]\&.Size(), 0);
91     for (rapidjson::SizeType i = 0; i < doc["max_N"]\&.Size(); ++i) {
92         assert(doc["max_N"][i]\&.IsInt());
93         sysMax[i] = doc["max_N"][i]\&.GetInt();
94     }
95 
96     assert(doc\&.HasMember("min_N"));
97     assert(doc["min_N"]\&.IsArray());
98     assert(doc["min_N"]\&.Size() == doc["num_species"]\&.GetInt());
99     std::vector < int > sysMin (doc["min_N"]\&.Size(), 0);
100     for (rapidjson::SizeType i = 0; i < doc["min_N"]\&.Size(); ++i) {
101         assert(doc["min_N"][i]\&.IsInt());
102         sysMin[i] = doc["min_N"][i]\&.GetInt();
103     }
104 
105     int Mtot = 1;
106     if (doc\&.HasMember("num_expanded_states")) {
107         assert(doc["num_expanded_states"]\&.IsInt());
108         Mtot = doc["num_expanded_states"]\&.GetInt();
109     }
110 
111     simSystem sys (doc["num_species"]\&.GetInt(), doc["beta"]\&.GetDouble(), sysBox, sysMu, sysMax, sysMin, Mtot, duh, max_order);
112     if (use_ke) {
113         sys\&.toggleKE();
114         if (sys\&.addKECorrection() == false) {
115             throw customException ("Unable to set KE flag");
116         }
117     }
118 
119     std::vector < int > sysWindow;
120     if (doc\&.HasMember("window")) {
121         assert(doc["window"]\&.IsArray());
122         assert(doc["window"]\&.Size() == 2);
123         sysWindow\&.resize(2, 0);
124         sysWindow[0] = doc["window"][0]\&.GetInt();
125         sysWindow[1] = doc["window"][1]\&.GetInt();
126     }
127 
128     if (sysWindow\&.begin() != sysWindow\&.end()) {
129         sys\&.setTotNBounds(sysWindow);
130     }
131 
132     assert(doc\&.HasMember("tmmc_sweep_size"));
133     assert(doc["tmmc_sweep_size"]\&.IsNumber());
134     double tmpT = doc["tmmc_sweep_size"]\&.GetDouble(); // possibly in scientific notation
135     sys\&.tmmcSweepSize = tmpT; // convert
136 
137     assert(doc\&.HasMember("total_tmmc_sweeps"));
138     assert(doc["total_tmmc_sweeps"]\&.IsNumber());
139     double tmpS = doc["total_tmmc_sweeps"]\&.GetDouble(); // possibly in scientific notation
140     sys\&.totalTMMCSweeps = tmpS; // convert
141 
142     assert(doc\&.HasMember("wala_sweep_size"));
143     assert(doc["wala_sweep_size"]\&.IsNumber());
144     double tmpW = doc["wala_sweep_size"]\&.GetDouble(); // possibly in scientific notation
145     sys\&.wlSweepSize = tmpW; // convert
146 
147     assert(doc\&.HasMember("wala_g"));
148     assert(doc["wala_g"]\&.IsNumber());
149     sys\&.wala_g = doc["wala_g"]\&.GetDouble();
150 
151     assert(doc\&.HasMember("wala_s"));
152     assert(doc["wala_s"]\&.IsNumber());
153     sys\&.wala_s = doc["wala_s"]\&.GetDouble();
154 
155     if (doc\&.HasMember("lnF_start")) {
156         assert(doc["lnF_start"]\&.IsNumber());
157         sys\&.lnF_start = doc["lnF_start"]\&.GetDouble(); // bounds are checked later
158     }
159 
160     if (doc\&.HasMember("lnF_end")) {
161         assert(doc["lnF_end"]\&.IsNumber());
162         sys\&.lnF_end = doc["lnF_end"]\&.GetDouble();
163         if (sys\&.lnF_end >= 1\&.0) {
164             sendErr("Terminal lnF factor for Wang-Landau must be < 1");
165             exit(SYS_FAILURE);
166         }
167     }
168     if (sys\&.lnF_end >= sys\&.lnF_start) {
169         sendErr("lnF_end must be < lnF_start for Wang-Landau to proceed forward");
170         exit(SYS_FAILURE);
171     }
172 
173     sys\&.restartFromWALA = false;
174     sys\&.restartFromWALAFile = "";
175     if (doc\&.HasMember("restart_from_wala_lnPI")) {
176         assert(doc["restart_from_wala_lnPI"]\&.IsString());
177         sys\&.restartFromWALAFile = doc["restart_from_wala_lnPI"]\&.GetString();
178         if (sys\&.restartFromWALAFile != "") {
179             sys\&.restartFromWALA = true;
180         }
181     }
182 
183     // restarting from TMMC overrides WL by skipping that portion altogether
184     sys\&.restartFromTMMC = false;
185     sys\&.restartFromTMMCFile = "";
186     if (doc\&.HasMember("restart_from_tmmc_C")) {
187         assert(doc["restart_from_tmmc_C"]\&.IsString());
188         sys\&.restartFromTMMCFile = doc["restart_from_tmmc_C"]\&.GetString();
189         if (sys\&.restartFromTMMCFile != "") {
190             sys\&.restartFromTMMC = true;
191         }
192     }
193 
194     // number of times the TMMC C matrix has to be traversed during the WALA --> TMMC crossover
195     if (doc\&.HasMember("num_crossover_visits")) {
196         assert(doc["num_crossover_visits"]\&.IsNumber());
197         sys\&.nCrossoverVisits = doc["num_crossover_visits"]\&.GetDouble(); // convert
198         if (sys\&.nCrossoverVisits < 1) {
199             sendErr("Must allow the collection matrix to be traversed at least once in the crossover from Wang-Landau to TMMC");
200             exit(SYS_FAILURE);
201         }
202     }
203 
204     setMoves (sys, doc, usedMovesEq, usedMovesPr);
205     setPairPotentials (sys, doc);
206 
207     checkBounds (sys);
208     sendMsg("System from "+filename+" passed bounds checks");
209 
210     setSystemBarriers (sys, doc);
211     sendMsg("Initialized barriers from "+filename);
212 
213     sendMsg("Successfully read valid parameters from "+filename);
214     return sys;
215 }
.fi
.SS "void setConfig (\fBsimSystem\fP &sys, const std::stringfilename)"

.PP
Setup a system's initial configuration as necessary\&. 
.IP "1." 4
If 'restart_file' in input json file, read initial config from there\&.
.IP "2." 4
In not, randomly generate initial configuration\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to initialize 
.br
\fIfilename\fP Input JSON filename 
.RE
.PP

.PP
Definition at line 404 of file input\&.cpp\&.
.PP
References moves::addInsert(), simSystem::addKECorrection(), simSystem::box(), simSystem::getTotalM(), simSystem::nSpecies(), simSystem::numSpecies, numToStr(), parseJson(), simSystem::printSnapshot(), simSystem::readConfig(), sendErr(), sendMsg(), setPairPotentials(), setSystemBarriers(), SYS_FAILURE, simSystem::toggleKE(), simSystem::totNMin(), and customException::what()\&.
.PP
.nf
404                                                           {
405     rapidjson::Document doc;
406     parseJson (filename, doc);
407 
408     std::string restart_file = "";
409     if (doc\&.HasMember("restart_file")) {
410         assert(doc["restart_file"]\&.IsString());
411         restart_file = doc["restart_file"]\&.GetString();
412     }
413 
414     std::vector < double > sysBox = sys\&.box();
415 
416     double duh = 10\&.0;
417     if (doc\&.HasMember("delta_u_hist")) {
418         assert(doc["delta_u_hist"]\&.IsNumber());
419         duh = doc["delta_u_hist"]\&.GetDouble();
420     }
421 
422     int max_order = 2;
423     if (doc\&.HasMember("max_order")) {
424         assert(doc["max_order"]\&.IsNumber());
425         max_order = doc["max_order"]\&.GetInt();
426     }
427 
428     bool use_ke = sys\&.addKECorrection();
429     int Mtot = sys\&.getTotalM();
430 
431     std::vector < double > sysMu (doc["mu"]\&.Size(), 0);
432     for (rapidjson::SizeType i = 0; i < doc["mu"]\&.Size(); ++i) {
433         sysMu[i] = doc["mu"][i]\&.GetDouble();
434     }
435     std::vector < int > sysMax (doc["max_N"]\&.Size(), 0);
436     for (rapidjson::SizeType i = 0; i < doc["max_N"]\&.Size(); ++i) {
437         sysMax[i] = doc["max_N"][i]\&.GetInt();
438     }
439     std::vector < int > sysMin (doc["min_N"]\&.Size(), 0);
440     for (rapidjson::SizeType i = 0; i < doc["min_N"]\&.Size(); ++i) {
441         sysMin[i] = doc["min_N"][i]\&.GetInt();
442     }
443 
444     // Read from restart file if specified
445     if (restart_file != "") {
446         try {
447             sys\&.readConfig(restart_file);
448         } catch (customException &ce) {
449             sendErr(ce\&.what());
450         }
451     } else if (restart_file == "" && sys\&.totNMin() > 0) {
452         sendMsg("Automatically generating the initial configuration");
453 
454         // have to generate initial configuration manually - start with mu = INF
455         std::vector < double > initMu (doc["num_species"]\&.GetInt(), 1\&.0e2);
456 
457         simSystem initSys (doc["num_species"]\&.GetInt(), doc["beta"]\&.GetDouble()/100\&.0, sysBox, initMu, sysMax, sysMin, Mtot, duh, max_order); // beta =  1/T, so low beta to have high T
458         if (use_ke) {
459             initSys\&.toggleKE();
460             if (initSys\&.addKECorrection() == false) {
461                 throw customException ("Unable to set KE flag");
462             }
463         }
464 
465         // add the same potentials
466         setPairPotentials (initSys, doc);
467         setSystemBarriers (initSys, doc);
468 
469         std::vector < int > initialization_order (sys\&.nSpecies(), 0), check_init (sys\&.nSpecies(), 0);
470         std::vector < double > init_frac (sys\&.nSpecies(), 1\&.0);
471         double sum = 0\&.0;
472         for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
473             initialization_order[i] = i;
474             if (i > 0) init_frac[i] = 0\&.0;
475             sum += init_frac[i];
476         }
477         if (doc\&.HasMember("init_order")) {
478             assert(doc["init_order"]\&.IsArray());
479             assert(doc["init_order"]\&.Size() == doc["num_species"]\&.GetInt());
480 
481             for (rapidjson::SizeType i = 0; i < doc["init_order"]\&.Size(); ++i) {
482                 assert(doc["init_order"][i]\&.IsInt());
483                 initialization_order[i] = doc["init_order"][i]\&.GetInt();
484                 if (initialization_order[i] < 0 || initialization_order[i] >= sys\&.nSpecies()) {
485                     sendErr("Order of initialization goes out of bounds, should include 0 <= i < nSpec");
486                     exit(SYS_FAILURE);
487                 }
488                 if (check_init[initialization_order[i]] != 0) {
489                     sendErr("Order of initialization repeats itself");
490                     exit(SYS_FAILURE);
491                 } else {
492                     check_init[initialization_order[i]] = 1;
493                 }
494             }
495         }
496         if (doc\&.HasMember("init_frac")) {
497             assert(doc["init_frac"]\&.IsArray());
498             assert(doc["init_frac"]\&.Size() == doc["num_species"]\&.GetInt());
499             sum = 0\&.0;
500             for (rapidjson::SizeType i = 0; i < doc["init_frac"]\&.Size(); ++i) {
501                 assert(doc["init_frac"][i]\&.IsNumber());
502                 init_frac[i] = doc["init_frac"][i]\&.GetDouble();
503                 if (init_frac[i] < 0 || init_frac[i] >= 1\&.0) {
504                     sendErr("Initialization fraction out of bounds");
505                     exit(SYS_FAILURE);
506                 }
507                 sum += init_frac[i];
508             }
509         }
510         for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
511             init_frac[i] /= sum;
512         }
513 
514         // iteratively add each individual species, assume we want an equimolar mixture to start from
515         int added = 0;
516         for (unsigned int idx = 0; idx < sys\&.nSpecies(); ++idx) {
517             unsigned int i = initialization_order[idx];
518             sendMsg("Initializing species "+numToStr(i)+" configurations");
519 
520             // insert this species i
521             moves initMove (initSys\&.getTotalM());
522             initMove\&.addInsert(i, 1\&.0);
523 
524             // also add displacment moves for all species present
525             for (unsigned int j = 0; j <= idx; ++j) {
526                 sendMsg("Added translation moves for initialization of species "+numToStr(initialization_order[j]));
527                 initMove\&.addTranslate(initialization_order[j], 2\&.0, 1\&.0, initSys\&.box());
528             }
529 
530             // now do simuation until within proper range
531             int targetNum = sys\&.totNMin()*init_frac[idx];
532             if (idx == sys\&.nSpecies() - 1) {
533                 // to account for integer rounding
534                 targetNum = sys\&.totNMin() - added;
535             }
536             added += targetNum;
537 
538             sendMsg("Target number = "+numToStr(targetNum)+" for species "+numToStr(i+1));
539             int tmpCounter = 0, statusPrint = 10e6;
540             while (initSys\&.numSpecies[i] < targetNum) {
541                 try {
542                     initMove\&.makeMove(initSys);
543                 } catch (customException &ce) {
544                     std::string msg = ce\&.what();
545                     sendErr("Failed to create an initial configuration because "+msg);
546                     exit(SYS_FAILURE);
547                 }
548                 tmpCounter++;
549                 if (tmpCounter%statusPrint == 0) {
550                     tmpCounter = 0;
551                     sendMsg("Grew "+numToStr(initSys\&.numSpecies[i])+" atoms of type "+numToStr(i)+" so far");
552                 }
553             }
554         }
555 
556         // print snapshot from Reading initial configuration
557         initSys\&.printSnapshot("auto-init\&.xyz", "auto-generated initial configuration");
558 
559         // read into sys
560         try {
561             sys\&.readConfig("auto-init\&.xyz");
562         } catch (customException &ce) {
563             std::string msg = ce\&.what();
564             sendErr("Failed to read auto-generated initialization file because "+msg);
565         }
566     }
567 }
.fi
.SS "void setMoves (\fBsimSystem\fP &sys, const rapidjson::Document &doc, \fBmoves\fP *usedMovesEq, \fBmoves\fP *usedMovesPr)"

.PP
Assign the Monte Carlo moves based on the JSON input file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP Simulation system that has been initialized 
.br
\fIdoc\fP JSON document corresponding to input file  [in] usedMovesEq Pointer to move object that will be used during 'equilibration' (WL)  [in] usedMovesPr Pointer to move object that will be used during 'production' (TMMC) 
.RE
.PP

.PP
Definition at line 225 of file input\&.cpp\&.
.PP
References moves::addDelete(), moves::addInsert(), moves::addSwap(), moves::addTranslate(), simSystem::box(), simSystem::getTotalM(), simSystem::nSpecies(), numToStr(), sendErr(), moves::setM(), and SYS_FAILURE\&.
.PP
Referenced by initialize()\&.
.PP
.nf
225                                                                                                      {
226     std::vector < double > ref (sys\&.nSpecies(), 0);
227     std::vector < std::vector < double > > probEqSwap (sys\&.nSpecies(), ref), probPrSwap (sys\&.nSpecies(), ref);
228     std::vector < double > probPrInsDel (sys\&.nSpecies(), 0), probPrDisp (sys\&.nSpecies(), 0);
229     std::vector < double > probEqInsDel (sys\&.nSpecies(), 0), probEqDisp (sys\&.nSpecies(), 0);
230     std::vector < double > maxPrD (sys\&.nSpecies(), 0), maxEqD (sys\&.nSpecies(), 0);
231     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
232         std::string dummy = "prob_pr_ins_del_" + std::to_string(i+1);
233         assert(doc\&.HasMember(dummy\&.c_str()));
234         assert(doc[dummy\&.c_str()]\&.IsNumber());
235         probPrInsDel[i] = doc[dummy\&.c_str()]\&.GetDouble();
236     }
237 
238     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
239         std::string dummy = "prob_pr_displace_" + std::to_string(i+1);
240         assert(doc\&.HasMember(dummy\&.c_str()));
241         assert(doc[dummy\&.c_str()]\&.IsNumber());
242         probPrDisp[i] = doc[dummy\&.c_str()]\&.GetDouble();
243         dummy = "max_pr_displacement_" + std::to_string(i+1);
244         assert(doc\&.HasMember(dummy\&.c_str()));
245         assert(doc[dummy\&.c_str()]\&.IsNumber());
246         maxPrD[i] = doc[dummy\&.c_str()]\&.GetDouble();
247     }
248 
249     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
250         std::string dummy = "prob_eq_ins_del_" + std::to_string(i+1);
251         assert(doc\&.HasMember(dummy\&.c_str()));
252         assert(doc[dummy\&.c_str()]\&.IsNumber());
253         probEqInsDel[i] = doc[dummy\&.c_str()]\&.GetDouble();
254     }
255 
256     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
257         std::string dummy = "prob_eq_displace_" + std::to_string(i+1);
258         assert(doc\&.HasMember(dummy\&.c_str()));
259         assert(doc[dummy\&.c_str()]\&.IsNumber());
260         probEqDisp[i] = doc[dummy\&.c_str()]\&.GetDouble();
261         dummy = "max_eq_displacement_" + std::to_string(i+1);
262         assert(doc\&.HasMember(dummy\&.c_str()));
263         assert(doc[dummy\&.c_str()]\&.IsNumber());
264         maxEqD[i] = doc[dummy\&.c_str()]\&.GetDouble();
265     }
266 
267     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
268         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
269             std::string name1 = "prob_pr_swap_"+std::to_string(i+1)+"_"+std::to_string(j+1);
270             std::string name2 = "prob_pr_swap_"+std::to_string(j+1)+"_"+std::to_string(i+1);
271             std::string moveName = "";
272             bool foundIJ = false;
273             if (doc\&.HasMember(name1\&.c_str())) {
274                 moveName = name1;
275                 foundIJ = true;
276             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
277                 moveName = name2;
278                 foundIJ = true;
279             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
280                 sendErr("Input file doubly specifies production swap move probability for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
281                 exit(SYS_FAILURE);
282             } else {
283                 sendErr("Input file does not specify production swap move probability for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
284                 exit(SYS_FAILURE);
285             }
286             assert(doc[moveName\&.c_str()]\&.IsNumber());
287             probPrSwap[i][j] = doc[moveName\&.c_str()]\&.GetDouble();
288             probPrSwap[j][i] = doc[moveName\&.c_str()]\&.GetDouble();
289         }
290     }
291 
292     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
293         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
294             std::string name1 = "prob_eq_swap_"+std::to_string(i+1)+"_"+std::to_string(j+1);
295             std::string name2 = "prob_eq_swap_"+std::to_string(j+1)+"_"+std::to_string(i+1);
296             std::string moveName = "";
297             bool foundIJ = false;
298             if (doc\&.HasMember(name1\&.c_str())) {
299                 moveName = name1;
300                 foundIJ = true;
301             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
302                 moveName = name2;
303                 foundIJ = true;
304             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
305                 sendErr("Input file doubly specifies equilibration swap move probability for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
306                 exit(SYS_FAILURE);
307             } else {
308                 sendErr("Input file does not specify equilibration swap move probability for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
309                 exit(SYS_FAILURE);
310             }
311             assert(doc[moveName\&.c_str()]\&.IsNumber());
312             probEqSwap[i][j] = doc[moveName\&.c_str()]\&.GetDouble();
313             probEqSwap[j][i] = doc[moveName\&.c_str()]\&.GetDouble();
314         }
315     }
316 
317     usedMovesEq->setM(sys\&.getTotalM());
318     usedMovesPr->setM(sys\&.getTotalM());
319     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
320         usedMovesEq->addInsert(i, probEqInsDel[i]);
321         usedMovesPr->addInsert(i, probPrInsDel[i]);
322 
323         usedMovesEq->addDelete(i, probEqInsDel[i]);
324         usedMovesPr->addDelete(i, probPrInsDel[i]);
325 
326         usedMovesEq->addTranslate(i, probEqDisp[i], maxEqD[i], sys\&.box());
327         usedMovesPr->addTranslate(i, probPrDisp[i], maxPrD[i], sys\&.box());
328 
329         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
330             usedMovesEq->addSwap(i, j, probEqSwap[i][j]);
331             usedMovesPr->addSwap(i, j, probPrSwap[i][j]);
332         }
333     }
334 }
.fi
.SS "void setPairPotentials (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"

.PP
Assign the pair potentials based on the JSON input file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP Simulation system that has been initialized 
.br
\fIdoc\fP JSON document corresponding to input file 
.RE
.PP

.PP
Definition at line 342 of file input\&.cpp\&.
.PP
References simSystem::addPotential(), simSystem::nSpecies(), numToStr(), simSystem::ppot, sendErr(), and SYS_FAILURE\&.
.PP
Referenced by initialize(), and setConfig()\&.
.PP
.nf
342                                                                       {
343     int Mtot = 1;
344     if (doc\&.HasMember("num_expanded_states")) {
345         Mtot = doc["num_expanded_states"]\&.GetInt();
346     }
347 
348     //std::vector < pairPotential* > ppotArray (sys\&.nSpecies()*(sys\&.nSpecies()-1)/2 + sys\&.nSpecies());
349     std::vector < std::string > ppotType (sys\&.nSpecies()*(sys\&.nSpecies()-1)/2 + sys\&.nSpecies());
350     int ppotTypeIndex = 0;
351     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
352         for (unsigned int j = i; j < sys\&.nSpecies(); ++j) {
353             std::string name1 = "ppot_"+std::to_string(i+1)+"_"+std::to_string(j+1), name2 = "ppot_"+std::to_string(j+1)+"_"+std::to_string(i+1);
354             std::string ppotName = "", dummy = "";
355             bool foundIJ = false;
356             if (doc\&.HasMember(name1\&.c_str())) {
357                 ppotName = name1;
358                 foundIJ = true;
359             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
360                 ppotName = name2;
361                 foundIJ = true;
362             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
363                 sendErr("Input file doubly specifies pair potential for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
364                 exit(SYS_FAILURE);
365             } else {
366                 sendErr("Input file does not specify pair potential for species pair ("+numToStr(i+1)+", "+numToStr(j+1)+")");
367                 exit(SYS_FAILURE);
368             }
369             assert(doc[ppotName\&.c_str()]\&.IsString());
370             ppotType[ppotTypeIndex] = doc[ppotName\&.c_str()]\&.GetString();
371             dummy = ppotName+"_params";
372             assert(doc\&.HasMember(dummy\&.c_str()));
373             assert(doc[dummy\&.c_str()]\&.IsArray());
374             std::vector < double > params (doc[dummy\&.c_str()]\&.Size()+1, 0);
375             for (unsigned int k = 0; k < params\&.size()-1; ++k) {
376                 assert(doc[dummy\&.c_str()][k]\&.IsNumber());
377                 params[k] = doc[dummy\&.c_str()][k]\&.GetDouble();
378             }
379             params[params\&.size()-1] = Mtot;
380 
381             bool useCellList = false; // default
382             dummy = ppotName+"_use_cell_list";
383             if (doc\&.HasMember(dummy\&.c_str())) {
384                 assert(doc[dummy\&.c_str()]\&.IsBool());
385                 useCellList = doc[dummy\&.c_str()]\&.GetBool();
386             }
387 
388             sys\&.addPotential(i, j, ppotType[ppotTypeIndex], params, useCellList);
389             sys\&.ppot[i][j]->savePotential(ppotName+"\&.dat", 0\&.01, 0\&.01);
390 
391             ppotTypeIndex++;
392         }
393     }
394 }
.fi
.SS "void setSystemBarriers (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"

.PP
Initialize the barriers in a system by parsing the input document\&. This function is defined separately since it must be done several times\&.
.PP
[in, out] sys System to initialize with barriers  [in] doc Input JSON document 
.PP
Definition at line 575 of file input\&.cpp\&.
.PP
References simSystem::getTotalM(), MAX_BARRIERS_PER_SPECIES, simSystem::nSpecies(), sendErr(), simSystem::speciesBarriers, SYS_FAILURE, and customException::what()\&.
.PP
Referenced by initialize(), and setConfig()\&.
.PP
.nf
575                                                                       {
576     // get Mtot, first from doc, otherwise try sys, but they should be the same
577     int Mtot = 1;
578     if (doc\&.HasMember("num_expanded_states")) {
579         assert(doc["num_expanded_states"]\&.IsInt());
580         Mtot = doc["num_expanded_states"]\&.GetInt();
581     } else {
582         Mtot = sys\&.getTotalM();
583     }
584 
585     // Hard wall (expect parameters: {lb, ub, sigma})
586     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
587         bool convention0 = false;
588         std::string dummy = "hardWallZ_" + std::to_string(i+1);
589         std::vector < double > wallParams (3, 0);
590         if (doc\&.HasMember(dummy\&.c_str())) {
591             assert(doc[dummy\&.c_str()]\&.IsArray());
592             assert(doc[dummy\&.c_str()]\&.Size() == 3);
593             for (unsigned int j = 0; j < 3; ++j) {
594                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
595             }
596             try {
597                 sys\&.speciesBarriers[i]\&.addHardWallZ (wallParams[0], wallParams[1], wallParams[2], Mtot);
598             } catch (customException &ce) {
599                 sendErr(ce\&.what());
600                 exit(SYS_FAILURE);
601             }
602             convention0 = true;
603         }
604         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
605             // alternatively allow multiple walls to specified with a suffix up to a max
606             std::string dummy = "hardWallZ_" + std::to_string(i+1) + "_" + std::to_string(j);
607             if (doc\&.HasMember(dummy\&.c_str())) {
608                 if (convention0) {
609                     sendErr("Error, multiple barrier naming conventions used for the same species");
610                     exit(SYS_FAILURE);
611                 }
612                 if (doc\&.HasMember(dummy\&.c_str())) {
613                     assert(doc[dummy\&.c_str()]\&.IsArray());
614                     assert(doc[dummy\&.c_str()]\&.Size() == 3);
615                     for (unsigned int j = 0; j < 3; ++j) {
616                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
617                     }
618                     try {
619                         sys\&.speciesBarriers[i]\&.addHardWallZ (wallParams[0], wallParams[1], wallParams[2], Mtot);
620                     } catch (customException &ce) {
621                         sendErr(ce\&.what());
622                         exit(SYS_FAILURE);
623                     }
624                 }
625             }
626         }
627     }
628 
629     // Square well wall (expect parameters: {lb, ub, sigma, range, eps})
630     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
631         bool convention0 = false;
632         std::string dummy = "squareWellWallZ_" + std::to_string(i+1);
633         std::vector < double > wallParams (5, 0);
634         if (doc\&.HasMember(dummy\&.c_str())) {
635             assert(doc[dummy\&.c_str()]\&.IsArray());
636             assert(doc[dummy\&.c_str()]\&.Size() == 5);
637             for (unsigned int j = 0; j < 5; ++j) {
638                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
639             }
640             try {
641                 sys\&.speciesBarriers[i]\&.addSquareWellWallZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], Mtot);
642             } catch (customException &ce) {
643                 sendErr(ce\&.what());
644                 exit(SYS_FAILURE);
645             }
646             convention0 = true;
647         }
648         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
649             // alternatively allow multiple walls to specified with a suffix up to a max
650             std::string dummy = "squareWellWallZ_" + std::to_string(i+1) + "_" + std::to_string(j);
651             if (doc\&.HasMember(dummy\&.c_str())) {
652                 if (convention0) {
653                     sendErr("Error, multiple barrier naming conventions used for the same species");
654                     exit(SYS_FAILURE);
655                 }
656                 if (doc\&.HasMember(dummy\&.c_str())) {
657                     assert(doc[dummy\&.c_str()]\&.IsArray());
658                     assert(doc[dummy\&.c_str()]\&.Size() == 5);
659                     for (unsigned int j = 0; j < 5; ++j) {
660                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
661                     }
662                     try {
663                         sys\&.speciesBarriers[i]\&.addSquareWellWallZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], Mtot);
664                     } catch (customException &ce) {
665                         sendErr(ce\&.what());
666                         exit(SYS_FAILURE);
667                     }
668                 }
669             }
670         }
671     }
672 
673     // cylinderZ (expect parameters: {x, y, radius, width, sigma, eps})
674     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
675         bool convention0 = false;
676         std::string dummy = "cylinderZ_" + std::to_string(i+1);
677         std::vector < double > wallParams (6, 0);
678         if (doc\&.HasMember(dummy\&.c_str())) {
679             assert(doc[dummy\&.c_str()]\&.IsArray());
680             assert(doc[dummy\&.c_str()]\&.Size() == 6);
681             for (unsigned int j = 0; j < 6; ++j) {
682                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
683             }
684             try {
685                 sys\&.speciesBarriers[i]\&.addCylinderZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], Mtot);
686             } catch (customException &ce) {
687                 sendErr(ce\&.what());
688                 exit(SYS_FAILURE);
689             }
690             convention0 = true;
691         }
692         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
693             // alternatively allow multiple walls to specified with a suffix up to a max
694             std::string dummy = "cylinderZ_" + std::to_string(i+1) + "_" + std::to_string(j);
695             if (doc\&.HasMember(dummy\&.c_str())) {
696                 if (convention0) {
697                     sendErr("Error, multiple barrier naming conventions used for the same species");
698                     exit(SYS_FAILURE);
699                 }
700                 if (doc\&.HasMember(dummy\&.c_str())) {
701                     assert(doc[dummy\&.c_str()]\&.IsArray());
702                     assert(doc[dummy\&.c_str()]\&.Size() == 6);
703                     for (unsigned int j = 0; j < 6; ++j) {
704                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
705                     }
706                     try {
707                         sys\&.speciesBarriers[i]\&.addCylinderZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], Mtot);
708                     } catch (customException &ce) {
709                         sendErr(ce\&.what());
710                         exit(SYS_FAILURE);
711                     }
712                 }
713             }
714         }
715     }
716 
717     // rightTriangleXZ (expect parameters: {width, theta, lamW, eps, sigma, sep, offset, zbase, top})
718     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
719         bool convention0 = false;
720         std::string dummy = "rightTriangleXZ_" + std::to_string(i+1);
721         std::vector < double > wallParams (8, 0);
722         bool top = false;
723         assert(doc\&.HasMember("box"));
724         assert(doc["box"]\&.IsArray());
725         assert(doc["box"]\&.Size() == 3);
726         std::vector < double > sysBox (3, 0);
727         for (rapidjson::SizeType j = 0; j < doc["box"]\&.Size(); ++j) {
728             assert(doc["box"][j]\&.IsNumber());
729             sysBox[j] = doc["box"][j]\&.GetDouble();
730         }
731         if (doc\&.HasMember(dummy\&.c_str())) {
732             assert(doc[dummy\&.c_str()]\&.IsArray());
733             assert(doc[dummy\&.c_str()]\&.Size() == 9);
734             for (unsigned int j = 0; j < 8; ++j) {
735                 assert (doc[dummy\&.c_str()][j]\&.IsDouble());
736                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
737             }
738             assert (doc[dummy\&.c_str()][8]\&.IsBool());
739             top = doc[dummy\&.c_str()][8]\&.GetBool();
740             try {
741                 sys\&.speciesBarriers[i]\&.addRightTriangleXZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], wallParams[6], sysBox, wallParams[7], top, Mtot);
742             } catch (customException &ce) {
743                 sendErr(ce\&.what());
744                 exit(SYS_FAILURE);
745             }
746             convention0 = true;
747         }
748         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
749             // alternatively allow multiple walls to specified with a suffix up to a max
750             std::string dummy = "rightTriangleXZ_" + std::to_string(i+1) + "_" + std::to_string(j);
751             if (doc\&.HasMember(dummy\&.c_str())) {
752                 if (convention0) {
753                     sendErr("Error, multiple barrier naming conventions used for the same species");
754                     exit(SYS_FAILURE);
755                 }
756                 if (doc\&.HasMember(dummy\&.c_str())) {
757                     assert(doc[dummy\&.c_str()]\&.IsArray());
758                     assert(doc[dummy\&.c_str()]\&.Size() == 9);
759                     for (unsigned int k = 0; k < 8; ++k) {
760                         assert (doc[dummy\&.c_str()][k]\&.IsNumber());
761                         wallParams[k] = doc[dummy\&.c_str()][k]\&.GetDouble();
762                     }
763                     assert (doc[dummy\&.c_str()][8]\&.IsBool());
764                     top = doc[dummy\&.c_str()][8]\&.GetBool();
765                     try {
766                         sys\&.speciesBarriers[i]\&.addRightTriangleXZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], wallParams[6], sysBox, wallParams[7], top, Mtot);
767                     } catch (customException &ce) {
768                         sendErr(ce\&.what());
769                         exit(SYS_FAILURE);
770                     }
771                 }
772             }
773         }
774     }
775 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
