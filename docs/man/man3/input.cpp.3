.TH "/home/nam4/Desktop/sandbox/FHMCSimulation/src/input.cpp" 3 "Fri Dec 23 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/nam4/Desktop/sandbox/FHMCSimulation/src/input.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'input\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcheckBounds\fP (\fBsimSystem\fP &sys)"
.br
.RI "\fICheck bounds on system variables such as rcut < L/2, etc\&. \fP"
.ti -1c
.RI "\fBsimSystem\fP \fBinitialize\fP (const std::string filename, \fBmoves\fP *usedMovesEq, \fBmoves\fP *usedMovesPr)"
.br
.RI "\fIParse a json input file and initialize system object accordingly\&. \fP"
.ti -1c
.RI "void \fBsetPairPotentials\fP (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"
.br
.ti -1c
.RI "void \fBsetup\fP (\fBsimSystem\fP &sys, const std::string filename)"
.br
.RI "\fISetup a system's initial configuration as necessary\&. \fP"
.ti -1c
.RI "void \fBinitializeSystemBarriers\fP (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"
.br
.RI "\fIInitialize the barriers in a system by parsing the input document\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void checkBounds (\fBsimSystem\fP &sys)"

.PP
Check bounds on system variables such as rcut < L/2, etc\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to check bounds on 
.RE
.PP

.PP
Definition at line 8 of file input\&.cpp\&.
.PP
References simSystem::box(), simSystem::nSpecies(), simSystem::potentialIsSet(), simSystem::ppot, and SYS_FAILURE\&.
.PP
Referenced by initialize()\&.
.PP
.nf
8                                   {
9     // check all pair potentials have been set and all r_cut < L/2
10     double minL = sys\&.box()[0];
11     for (unsigned int i = 1; i < 3; ++i) {
12         minL = std::min(minL, sys\&.box()[i]);
13     }
14     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
15         for (unsigned int j = 0; j < sys\&.nSpecies(); ++j) {
16             if (!sys\&.potentialIsSet(i, j)) {
17                 std::cerr << "Not all pair potentials are set" << std::endl;
18                 exit(SYS_FAILURE);
19             }
20             if (!(sys\&.ppot[i][j]->rcut() < minL/2\&.0)) {
21                 std::cerr << "Pair potential r_cut for species " << i << ", " << j << " is > L/2" << std::endl;
22                 exit(SYS_FAILURE);
23             }
24         }
25     }
26 }
.fi
.SS "\fBsimSystem\fP initialize (const std::stringfilename, \fBmoves\fP *usedMovesEq, \fBmoves\fP *usedMovesPr)"

.PP
Parse a json input file and initialize system object accordingly\&. [in] filename Input JSON document's filename  [in] usedMovesEq Pointer to move object that will be used during 'equilibration' (WL)  [in] usedMovesPr Pointer to move object that will be used during 'production' (TMMC) 
.PP
Definition at line 35 of file input\&.cpp\&.
.PP
References moves::addDelete(), moves::addInsert(), simSystem::addKECorrection(), moves::addSwap(), moves::addTranslate(), simSystem::box(), checkBounds(), getTimeStamp(), simSystem::getTotalM(), initializeSystemBarriers(), simSystem::lnF_end, simSystem::lnF_start, simSystem::nCrossoverVisits, simSystem::nSpecies(), simSystem::restartFromTMMC, simSystem::restartFromTMMCFile, simSystem::restartFromWALA, simSystem::restartFromWALAFile, RNG_SEED, moves::setM(), setPairPotentials(), simSystem::setTotNBounds(), SYS_FAILURE, simSystem::tmmcSweepSize, simSystem::toggleKE(), simSystem::totalTMMCSweeps, simSystem::wala_g, simSystem::wala_s, and simSystem::wlSweepSize\&.
.PP
.nf
35                                                                                         {
36 
37     // Parse input JSON file
38     FILE* fp = fopen(filename\&.c_str(), "r");
39     char readBuffer[65536];
40     rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));
41     rapidjson::Document doc;
42     doc\&.ParseStream(is);
43     fclose(fp);
44     std::cout << "Parsed " << filename << " at " << getTimeStamp() << std::endl;
45 
46     // Assert that this is a JSON document
47     assert(doc\&.IsObject());
48 
49     // Check each member exists and is in the correct format
50     assert(doc\&.HasMember("num_species"));
51     assert(doc["num_species"]\&.IsInt());
52     assert(doc\&.HasMember("beta"));
53     assert(doc["beta"]\&.IsNumber());
54 
55     assert(doc\&.HasMember("box"));
56     assert(doc["box"]\&.IsArray());
57     assert(doc["box"]\&.Size() == 3);
58     std::vector < double > sysBox (3, 0);
59     for (rapidjson::SizeType i = 0; i < doc["box"]\&.Size(); ++i) {
60         assert(doc["box"][i]\&.IsNumber());
61         sysBox[i] = doc["box"][i]\&.GetDouble();
62     }
63 
64     double duh = 10\&.0;
65     if (doc\&.HasMember("delta_u_hist")) {
66         assert(doc["delta_u_hist"]\&.IsNumber());
67         duh = doc["delta_u_hist"]\&.GetDouble();
68     }
69 
70     int max_order = 2;
71     if (doc\&.HasMember("max_order")) {
72         assert(doc["max_order"]\&.IsNumber());
73         max_order = doc["max_order"]\&.GetInt();
74     }
75 
76     bool use_ke = false;
77     if (doc\&.HasMember("use_ke")) {
78         assert(doc["use_ke"]\&.IsBool());
79         use_ke = doc["use_ke"]\&.GetBool();
80     }
81 
82     assert(doc\&.HasMember("mu"));
83     assert(doc["mu"]\&.IsArray());
84     assert(doc["mu"]\&.Size() == doc["num_species"]\&.GetInt());
85     std::vector < double > sysMu (doc["mu"]\&.Size(), 0);
86     for (rapidjson::SizeType i = 0; i < doc["mu"]\&.Size(); ++i) {
87         assert(doc["mu"][i]\&.IsNumber());
88         sysMu[i] = doc["mu"][i]\&.GetDouble();
89     }
90 
91     assert(doc\&.HasMember("seed"));
92     assert(doc["seed"]\&.IsInt());
93     RNG_SEED = doc["seed"]\&.GetInt();
94 
95     assert(doc\&.HasMember("max_N"));
96     assert(doc["max_N"]\&.IsArray());
97     assert(doc["max_N"]\&.Size() == doc["num_species"]\&.GetInt());
98     std::vector < int > sysMax (doc["max_N"]\&.Size(), 0);
99     for (rapidjson::SizeType i = 0; i < doc["max_N"]\&.Size(); ++i) {
100         assert(doc["max_N"][i]\&.IsInt());
101         sysMax[i] = doc["max_N"][i]\&.GetInt();
102     }
103 
104     assert(doc\&.HasMember("min_N"));
105     assert(doc["min_N"]\&.IsArray());
106     assert(doc["min_N"]\&.Size() == doc["num_species"]\&.GetInt());
107     std::vector < int > sysMin (doc["min_N"]\&.Size(), 0);
108     for (rapidjson::SizeType i = 0; i < doc["min_N"]\&.Size(); ++i) {
109         assert(doc["min_N"][i]\&.IsInt());
110         sysMin[i] = doc["min_N"][i]\&.GetInt();
111     }
112 
113     int Mtot = 1;
114     if (doc\&.HasMember("num_expanded_states")) {
115         assert(doc["num_expanded_states"]\&.IsInt());
116         Mtot = doc["num_expanded_states"]\&.GetInt();
117     }
118 
119     simSystem sys (doc["num_species"]\&.GetInt(), doc["beta"]\&.GetDouble(), sysBox, sysMu, sysMax, sysMin, Mtot, duh, max_order);
120     if (use_ke) {
121         sys\&.toggleKE();
122         if (sys\&.addKECorrection() == false) {
123             throw customException ("Unable to set KE flag");
124         }
125     }
126 
127     std::vector < int > sysWindow;
128     if (doc\&.HasMember("window")) {
129         assert(doc["window"]\&.IsArray());
130         assert(doc["window"]\&.Size() == 2);
131         sysWindow\&.resize(2, 0);
132         sysWindow[0] = doc["window"][0]\&.GetInt();
133         sysWindow[1] = doc["window"][1]\&.GetInt();
134     }
135 
136     if (sysWindow\&.begin() != sysWindow\&.end()) {
137         sys\&.setTotNBounds(sysWindow);
138     }
139 
140     assert(doc\&.HasMember("tmmc_sweep_size"));
141     assert(doc["tmmc_sweep_size"]\&.IsNumber());
142     double tmpT = doc["tmmc_sweep_size"]\&.GetDouble(); // possibly in scientific notation
143     sys\&.tmmcSweepSize = tmpT; // convert
144 
145     assert(doc\&.HasMember("total_tmmc_sweeps"));
146     assert(doc["total_tmmc_sweeps"]\&.IsNumber());
147     double tmpS = doc["total_tmmc_sweeps"]\&.GetDouble(); // possibly in scientific notation
148     sys\&.totalTMMCSweeps = tmpS; // convert
149 
150     assert(doc\&.HasMember("wala_sweep_size"));
151     assert(doc["wala_sweep_size"]\&.IsNumber());
152     double tmpW = doc["wala_sweep_size"]\&.GetDouble(); // possibly in scientific notation
153     sys\&.wlSweepSize = tmpW; // convert
154 
155     assert(doc\&.HasMember("wala_g"));
156     assert(doc["wala_g"]\&.IsNumber());
157     sys\&.wala_g = doc["wala_g"]\&.GetDouble();
158 
159     assert(doc\&.HasMember("wala_s"));
160     assert(doc["wala_s"]\&.IsNumber());
161     sys\&.wala_s = doc["wala_s"]\&.GetDouble();
162 
163     if (doc\&.HasMember("lnF_start")) {
164         assert(doc["lnF_start"]\&.IsNumber());
165         sys\&.lnF_start = doc["lnF_start"]\&.GetDouble(); // bounds are checked later
166     }
167 
168     if (doc\&.HasMember("lnF_end")) {
169         assert(doc["lnF_end"]\&.IsNumber());
170         sys\&.lnF_end = doc["lnF_end"]\&.GetDouble();
171         if (sys\&.lnF_end >= 1\&.0) {
172             std::cerr << "Terminal lnF factor for Wang-Landau must be < 1" << std::endl;
173             exit(SYS_FAILURE);
174         }
175     }
176     if (sys\&.lnF_end >= sys\&.lnF_start) {
177         std::cerr << "lnF_end must be < lnF_start for Wang-Landau to proceed forward" << std::endl;
178         exit(SYS_FAILURE);
179     }
180 
181     sys\&.restartFromWALA = false;
182     sys\&.restartFromWALAFile = "";
183     if (doc\&.HasMember("restart_from_wala_lnPI")) {
184         assert(doc["restart_from_wala_lnPI"]\&.IsString());
185         sys\&.restartFromWALAFile = doc["restart_from_wala_lnPI"]\&.GetString();
186         if (sys\&.restartFromWALAFile != "") {
187             sys\&.restartFromWALA = true;
188         }
189     }
190 
191     // restarting from TMMC overrides WL by skipping that portion altogether
192     sys\&.restartFromTMMC = false;
193     sys\&.restartFromTMMCFile = "";
194     if (doc\&.HasMember("restart_from_tmmc_C")) {
195         assert(doc["restart_from_tmmc_C"]\&.IsString());
196         sys\&.restartFromTMMCFile = doc["restart_from_tmmc_C"]\&.GetString();
197         if (sys\&.restartFromTMMCFile != "") {
198             sys\&.restartFromTMMC = true;
199         }
200     }
201 
202     // number of times the TMMC C matrix has to be traversed during the WALA --> TMMC crossover
203     if (doc\&.HasMember("num_crossover_visits")) {
204         assert(doc["num_crossover_visits"]\&.IsNumber());
205         sys\&.nCrossoverVisits = doc["num_crossover_visits"]\&.GetDouble(); // convert
206         if (sys\&.nCrossoverVisits < 1) {
207             std::cerr << "Must allow the collection matrix to be traversed at least once in the crossover from Wang-Landau to TMMC" << std::endl;
208             exit(SYS_FAILURE);
209         }
210     }
211 
212     std::vector < double > ref (sys\&.nSpecies(), 0);
213     std::vector < std::vector < double > > probEqSwap (sys\&.nSpecies(), ref), probPrSwap (sys\&.nSpecies(), ref);
214     std::vector < double > probPrInsDel (sys\&.nSpecies(), 0), probPrDisp (sys\&.nSpecies(), 0);
215     std::vector < double > probEqInsDel (sys\&.nSpecies(), 0), probEqDisp (sys\&.nSpecies(), 0);
216     std::vector < double > maxPrD (sys\&.nSpecies(), 0), maxEqD (sys\&.nSpecies(), 0);
217     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
218         std::string dummy = "prob_pr_ins_del_" + std::to_string(i+1);
219         assert(doc\&.HasMember(dummy\&.c_str()));
220         assert(doc[dummy\&.c_str()]\&.IsNumber());
221         probPrInsDel[i] = doc[dummy\&.c_str()]\&.GetDouble();
222     }
223     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
224         std::string dummy = "prob_pr_displace_" + std::to_string(i+1);
225         assert(doc\&.HasMember(dummy\&.c_str()));
226         assert(doc[dummy\&.c_str()]\&.IsNumber());
227         probPrDisp[i] = doc[dummy\&.c_str()]\&.GetDouble();
228         dummy = "max_pr_displacement_" + std::to_string(i+1);
229         assert(doc\&.HasMember(dummy\&.c_str()));
230         assert(doc[dummy\&.c_str()]\&.IsNumber());
231         maxPrD[i] = doc[dummy\&.c_str()]\&.GetDouble();
232     }
233     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
234         std::string dummy = "prob_eq_ins_del_" + std::to_string(i+1);
235         assert(doc\&.HasMember(dummy\&.c_str()));
236         assert(doc[dummy\&.c_str()]\&.IsNumber());
237         probEqInsDel[i] = doc[dummy\&.c_str()]\&.GetDouble();
238     }
239     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
240         std::string dummy = "prob_eq_displace_" + std::to_string(i+1);
241         assert(doc\&.HasMember(dummy\&.c_str()));
242         assert(doc[dummy\&.c_str()]\&.IsNumber());
243         probEqDisp[i] = doc[dummy\&.c_str()]\&.GetDouble();
244         dummy = "max_eq_displacement_" + std::to_string(i+1);
245         assert(doc\&.HasMember(dummy\&.c_str()));
246         assert(doc[dummy\&.c_str()]\&.IsNumber());
247         maxEqD[i] = doc[dummy\&.c_str()]\&.GetDouble();
248     }
249     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
250         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
251             std::string name1 = "prob_pr_swap_"+std::to_string(i+1)+"_"+std::to_string(j+1);
252             std::string name2 = "prob_pr_swap_"+std::to_string(j+1)+"_"+std::to_string(i+1);
253             std::string moveName = "";
254             bool foundIJ = false;
255             if (doc\&.HasMember(name1\&.c_str())) {
256                 moveName = name1;
257                 foundIJ = true;
258             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
259                 moveName = name2;
260                 foundIJ = true;
261             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
262                 std::cerr << "Input file doubly specifies production swap move probability for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
263                 exit(SYS_FAILURE);
264             } else {
265                 std::cerr << "Input file does not specify production swap move probability for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
266                 exit(SYS_FAILURE);
267             }
268             assert(doc[moveName\&.c_str()]\&.IsNumber());
269             probPrSwap[i][j] = doc[moveName\&.c_str()]\&.GetDouble();
270             probPrSwap[j][i] = doc[moveName\&.c_str()]\&.GetDouble();
271         }
272     }
273 
274     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
275         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
276             std::string name1 = "prob_eq_swap_"+std::to_string(i+1)+"_"+std::to_string(j+1);
277             std::string name2 = "prob_eq_swap_"+std::to_string(j+1)+"_"+std::to_string(i+1);
278             std::string moveName = "";
279             bool foundIJ = false;
280             if (doc\&.HasMember(name1\&.c_str())) {
281                 moveName = name1;
282                 foundIJ = true;
283             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
284                 moveName = name2;
285                 foundIJ = true;
286             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
287                 std::cerr << "Input file doubly specifies equilibration swap move probability for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
288                 exit(SYS_FAILURE);
289             } else {
290                 std::cerr << "Input file does not specify equilibration swap move probability for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
291                 exit(SYS_FAILURE);
292             }
293             assert(doc[moveName\&.c_str()]\&.IsNumber());
294             probEqSwap[i][j] = doc[moveName\&.c_str()]\&.GetDouble();
295             probEqSwap[j][i] = doc[moveName\&.c_str()]\&.GetDouble();
296         }
297     }
298 
299     setPairPotentials (sys, doc);
300 
301     usedMovesEq->setM(sys\&.getTotalM());
302     usedMovesPr->setM(sys\&.getTotalM());
303     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
304         usedMovesEq->addInsert(i, probEqInsDel[i]);
305         usedMovesPr->addInsert(i, probPrInsDel[i]);
306 
307         usedMovesEq->addDelete(i, probEqInsDel[i]);
308         usedMovesPr->addDelete(i, probPrInsDel[i]);
309 
310         usedMovesEq->addTranslate(i, probEqDisp[i], maxEqD[i], sys\&.box());
311         usedMovesPr->addTranslate(i, probPrDisp[i], maxPrD[i], sys\&.box());
312 
313         for (unsigned int j = i+1; j < sys\&.nSpecies(); ++j) {
314             usedMovesEq->addSwap(i, j, probEqSwap[i][j]);
315             usedMovesPr->addSwap(i, j, probPrSwap[i][j]);
316         }
317     }
318 
319     checkBounds (sys);
320     std::cout << filename << " passed bounds checks at " << getTimeStamp() << std::endl;
321     initializeSystemBarriers (sys, doc);
322     std::cout << "Initialized barriers from " << filename << " at " << getTimeStamp() << std::endl;
323 
324     std::cout << "Successfully read valid parameters from " << filename << " at " << getTimeStamp() << std::endl;
325     return sys;
326 }
.fi
.SS "void initializeSystemBarriers (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"

.PP
Initialize the barriers in a system by parsing the input document\&. This function is defined separately since it must be done several times\&.
.PP
[in, out] sys System to initialize with barriers  [in] doc Input JSON document 
.PP
Definition at line 563 of file input\&.cpp\&.
.PP
References simSystem::getTotalM(), MAX_BARRIERS_PER_SPECIES, simSystem::nSpecies(), simSystem::speciesBarriers, SYS_FAILURE, and customException::what()\&.
.PP
Referenced by initialize(), and setup()\&.
.PP
.nf
563                                                                              {
564     // get Mtot, first from doc, otherwise try sys, but they should be the same
565     int Mtot = 1;
566     if (doc\&.HasMember("num_expanded_states")) {
567         assert(doc["num_expanded_states"]\&.IsInt());
568         Mtot = doc["num_expanded_states"]\&.GetInt();
569     } else {
570         Mtot = sys\&.getTotalM();
571     }
572 
573     // Hard wall (expect parameters: {lb, ub, sigma})
574     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
575         bool convention0 = false;
576         std::string dummy = "hardWallZ_" + std::to_string(i+1);
577         std::vector < double > wallParams (3, 0);
578         if (doc\&.HasMember(dummy\&.c_str())) {
579             assert(doc[dummy\&.c_str()]\&.IsArray());
580             assert(doc[dummy\&.c_str()]\&.Size() == 3);
581             for (unsigned int j = 0; j < 3; ++j) {
582                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
583             }
584             try {
585                 sys\&.speciesBarriers[i]\&.addHardWallZ (wallParams[0], wallParams[1], wallParams[2], Mtot);
586             } catch (customException &ce) {
587                 std::cerr << ce\&.what() << std::endl;
588                 exit(SYS_FAILURE);
589             }
590             convention0 = true;
591         }
592         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
593             // alternatively allow multiple walls to specified with a suffix up to a max
594             std::string dummy = "hardWallZ_" + std::to_string(i+1) + "_" + std::to_string(j);
595             if (doc\&.HasMember(dummy\&.c_str())) {
596                 if (convention0) {
597                     std::cerr << "Error: multiple barrier naming conventions used for the same species" << std::endl;
598                     exit(SYS_FAILURE);
599                 }
600                 if (doc\&.HasMember(dummy\&.c_str())) {
601                     assert(doc[dummy\&.c_str()]\&.IsArray());
602                     assert(doc[dummy\&.c_str()]\&.Size() == 3);
603                     for (unsigned int j = 0; j < 3; ++j) {
604                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
605                     }
606                     try {
607                         sys\&.speciesBarriers[i]\&.addHardWallZ (wallParams[0], wallParams[1], wallParams[2], Mtot);
608                     } catch (customException &ce) {
609                         std::cerr << ce\&.what() << std::endl;
610                         exit(SYS_FAILURE);
611                     }
612                 }
613             }
614         }
615     }
616 
617     // Square well wall (expect parameters: {lb, ub, sigma, range, eps})
618     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
619         bool convention0 = false;
620         std::string dummy = "squareWellWallZ_" + std::to_string(i+1);
621         std::vector < double > wallParams (5, 0);
622         if (doc\&.HasMember(dummy\&.c_str())) {
623             assert(doc[dummy\&.c_str()]\&.IsArray());
624             assert(doc[dummy\&.c_str()]\&.Size() == 5);
625             for (unsigned int j = 0; j < 5; ++j) {
626                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
627             }
628             try {
629                 sys\&.speciesBarriers[i]\&.addSquareWellWallZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], Mtot);
630             } catch (customException &ce) {
631                 std::cerr << ce\&.what() << std::endl;
632                 exit(SYS_FAILURE);
633             }
634             convention0 = true;
635         }
636         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
637             // alternatively allow multiple walls to specified with a suffix up to a max
638             std::string dummy = "squareWellWallZ_" + std::to_string(i+1) + "_" + std::to_string(j);
639             if (doc\&.HasMember(dummy\&.c_str())) {
640                 if (convention0) {
641                     std::cerr << "Error: multiple barrier naming conventions used for the same species" << std::endl;
642                     exit(SYS_FAILURE);
643                 }
644                 if (doc\&.HasMember(dummy\&.c_str())) {
645                     assert(doc[dummy\&.c_str()]\&.IsArray());
646                     assert(doc[dummy\&.c_str()]\&.Size() == 5);
647                     for (unsigned int j = 0; j < 5; ++j) {
648                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
649                     }
650                     try {
651                         sys\&.speciesBarriers[i]\&.addSquareWellWallZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], Mtot);
652                     } catch (customException &ce) {
653                         std::cerr << ce\&.what() << std::endl;
654                         exit(SYS_FAILURE);
655                     }
656                 }
657             }
658         }
659     }
660 
661     // cylinderZ (expect parameters: {x, y, radius, width, sigma, eps})
662     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
663         bool convention0 = false;
664         std::string dummy = "cylinderZ_" + std::to_string(i+1);
665         std::vector < double > wallParams (6, 0);
666         if (doc\&.HasMember(dummy\&.c_str())) {
667             assert(doc[dummy\&.c_str()]\&.IsArray());
668             assert(doc[dummy\&.c_str()]\&.Size() == 6);
669             for (unsigned int j = 0; j < 6; ++j) {
670                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
671             }
672             try {
673                 sys\&.speciesBarriers[i]\&.addCylinderZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], Mtot);
674             } catch (customException &ce) {
675                 std::cerr << ce\&.what() << std::endl;
676                 exit(SYS_FAILURE);
677             }
678             convention0 = true;
679         }
680         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
681             // alternatively allow multiple walls to specified with a suffix up to a max
682             std::string dummy = "cylinderZ_" + std::to_string(i+1) + "_" + std::to_string(j);
683             if (doc\&.HasMember(dummy\&.c_str())) {
684                 if (convention0) {
685                     std::cerr << "Error: multiple barrier naming conventions used for the same species" << std::endl;
686                     exit(SYS_FAILURE);
687                 }
688                 if (doc\&.HasMember(dummy\&.c_str())) {
689                     assert(doc[dummy\&.c_str()]\&.IsArray());
690                     assert(doc[dummy\&.c_str()]\&.Size() == 6);
691                     for (unsigned int j = 0; j < 6; ++j) {
692                         wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
693                     }
694                     try {
695                         sys\&.speciesBarriers[i]\&.addCylinderZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], Mtot);
696                     } catch (customException &ce) {
697                         std::cerr << ce\&.what() << std::endl;
698                         exit(SYS_FAILURE);
699                     }
700                 }
701             }
702         }
703     }
704 
705     // rightTriangleXZ (expect parameters: {width, theta, lamW, eps, sigma, sep, offset, zbase, top})
706     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
707         bool convention0 = false;
708         std::string dummy = "rightTriangleXZ_" + std::to_string(i+1);
709         std::vector < double > wallParams (8, 0);
710         bool top = false;
711         assert(doc\&.HasMember("box"));
712         assert(doc["box"]\&.IsArray());
713         assert(doc["box"]\&.Size() == 3);
714         std::vector < double > sysBox (3, 0);
715         for (rapidjson::SizeType j = 0; j < doc["box"]\&.Size(); ++j) {
716             assert(doc["box"][j]\&.IsNumber());
717             sysBox[j] = doc["box"][j]\&.GetDouble();
718         }
719         if (doc\&.HasMember(dummy\&.c_str())) {
720             assert(doc[dummy\&.c_str()]\&.IsArray());
721             assert(doc[dummy\&.c_str()]\&.Size() == 9);
722             for (unsigned int j = 0; j < 8; ++j) {
723                 assert (doc[dummy\&.c_str()][j]\&.IsDouble());
724                 wallParams[j] = doc[dummy\&.c_str()][j]\&.GetDouble();
725             }
726             assert (doc[dummy\&.c_str()][8]\&.IsBool());
727             top = doc[dummy\&.c_str()][8]\&.GetBool();
728             try {
729                 sys\&.speciesBarriers[i]\&.addRightTriangleXZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], wallParams[6], sysBox, wallParams[7], top, Mtot);
730             } catch (customException &ce) {
731                 std::cerr << ce\&.what() << std::endl;
732                 exit(SYS_FAILURE);
733             }
734             convention0 = true;
735         }
736         for (unsigned int j = 1; j <= MAX_BARRIERS_PER_SPECIES; ++j) {
737             // alternatively allow multiple walls to specified with a suffix up to a max
738             std::string dummy = "rightTriangleXZ_" + std::to_string(i+1) + "_" + std::to_string(j);
739             if (doc\&.HasMember(dummy\&.c_str())) {
740                 if (convention0) {
741                     std::cerr << "Error: multiple barrier naming conventions used for the same species" << std::endl;
742                     exit(SYS_FAILURE);
743                 }
744                 if (doc\&.HasMember(dummy\&.c_str())) {
745                     assert(doc[dummy\&.c_str()]\&.IsArray());
746                     assert(doc[dummy\&.c_str()]\&.Size() == 9);
747                     for (unsigned int k = 0; k < 8; ++k) {
748                         assert (doc[dummy\&.c_str()][k]\&.IsNumber());
749                         wallParams[k] = doc[dummy\&.c_str()][k]\&.GetDouble();
750                     }
751                     assert (doc[dummy\&.c_str()][8]\&.IsBool());
752                     top = doc[dummy\&.c_str()][8]\&.GetBool();
753                     try {
754                         sys\&.speciesBarriers[i]\&.addRightTriangleXZ (wallParams[0], wallParams[1], wallParams[2], wallParams[3], wallParams[4], wallParams[5], wallParams[6], sysBox, wallParams[7], top, Mtot);
755                     } catch (customException &ce) {
756                         std::cerr << ce\&.what() << std::endl;
757                         exit(SYS_FAILURE);
758                     }
759                 }
760             }
761         }
762     }
763 }
.fi
.SS "void setPairPotentials (\fBsimSystem\fP &sys, const rapidjson::Document &doc)"

.PP
Definition at line 328 of file input\&.cpp\&.
.PP
References simSystem::addPotential(), simSystem::nSpecies(), simSystem::ppot, and SYS_FAILURE\&.
.PP
Referenced by initialize(), and setup()\&.
.PP
.nf
328                                                                       {
329     int Mtot = 1;
330     if (doc\&.HasMember("num_expanded_states")) {
331         Mtot = doc["num_expanded_states"]\&.GetInt();
332     }
333 
334     //std::vector < pairPotential* > ppotArray (sys\&.nSpecies()*(sys\&.nSpecies()-1)/2 + sys\&.nSpecies());
335     std::vector < std::string > ppotType (sys\&.nSpecies()*(sys\&.nSpecies()-1)/2 + sys\&.nSpecies());
336     int ppotTypeIndex = 0;
337     for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
338         for (unsigned int j = i; j < sys\&.nSpecies(); ++j) {
339             std::string name1 = "ppot_"+std::to_string(i+1)+"_"+std::to_string(j+1), name2 = "ppot_"+std::to_string(j+1)+"_"+std::to_string(i+1);
340             std::string ppotName = "", dummy = "";
341             bool foundIJ = false;
342             if (doc\&.HasMember(name1\&.c_str())) {
343                 ppotName = name1;
344                 foundIJ = true;
345             } else if (doc\&.HasMember(name2\&.c_str()) && !foundIJ) {
346                 ppotName = name2;
347                 foundIJ = true;
348             } else if (doc\&.HasMember(name2\&.c_str()) && foundIJ) {
349                 std::cerr << "Input file doubly specifies pair potential for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
350                 exit(SYS_FAILURE);
351             } else {
352                 std::cerr << "Input file does not specify pair potential for species pair ("+std::to_string(i+1)+", "+std::to_string(j+1)+")" << std::endl;
353                 exit(SYS_FAILURE);
354             }
355             assert(doc[ppotName\&.c_str()]\&.IsString());
356             ppotType[ppotTypeIndex] = doc[ppotName\&.c_str()]\&.GetString();
357             dummy = ppotName+"_params";
358             assert(doc\&.HasMember(dummy\&.c_str()));
359             assert(doc[dummy\&.c_str()]\&.IsArray());
360             std::vector < double > params (doc[dummy\&.c_str()]\&.Size()+1, 0);
361             for (unsigned int k = 0; k < params\&.size()-1; ++k) {
362                 assert(doc[dummy\&.c_str()][k]\&.IsNumber());
363                 params[k] = doc[dummy\&.c_str()][k]\&.GetDouble();
364             }
365             params[params\&.size()-1] = Mtot;
366 
367             bool useCellList = false; // default
368             dummy = ppotName+"_use_cell_list";
369             if (doc\&.HasMember(dummy\&.c_str())) {
370                 assert(doc[dummy\&.c_str()]\&.IsBool());
371                 useCellList = doc[dummy\&.c_str()]\&.GetBool();
372             }
373 
374             sys\&.addPotential(i, j, ppotType[ppotTypeIndex], params, useCellList);
375             sys\&.ppot[i][j]->savePotential(ppotName+"\&.dat", 0\&.01, 0\&.01);
376 
377             ppotTypeIndex++;
378         }
379     }
380 }
.fi
.SS "void setup (\fBsimSystem\fP &sys, const std::stringfilename)"

.PP
Setup a system's initial configuration as necessary\&. 
.IP "1." 4
If 'restart_file' in input json file, read initial config from there\&.
.IP "2." 4
In not, randomly generate initial configuration\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to initialize 
.br
\fIfilename\fP Input JSON filename 
.RE
.PP

.PP
Definition at line 390 of file input\&.cpp\&.
.PP
References moves::addInsert(), simSystem::addKECorrection(), simSystem::box(), simSystem::getTotalM(), initializeSystemBarriers(), simSystem::nSpecies(), simSystem::numSpecies, simSystem::printSnapshot(), simSystem::readConfig(), setPairPotentials(), SYS_FAILURE, simSystem::toggleKE(), simSystem::totNMin(), and customException::what()\&.
.PP
.nf
390                                                       {
391 
392     FILE* fp = fopen(filename\&.c_str(), "r");
393     char readBuffer[65536];
394     rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));
395     rapidjson::Document doc;
396     doc\&.ParseStream(is);
397     fclose(fp);
398 
399     std::string restart_file = "";
400     if (doc\&.HasMember("restart_file")) {
401         assert(doc["restart_file"]\&.IsString());
402         restart_file = doc["restart_file"]\&.GetString();
403     }
404 
405     std::vector < double > sysBox = sys\&.box();
406 
407     double duh = 10\&.0;
408     if (doc\&.HasMember("delta_u_hist")) {
409         assert(doc["delta_u_hist"]\&.IsNumber());
410         duh = doc["delta_u_hist"]\&.GetDouble();
411     }
412 
413     int max_order = 2;
414     if (doc\&.HasMember("max_order")) {
415         assert(doc["max_order"]\&.IsNumber());
416         max_order = doc["max_order"]\&.GetInt();
417     }
418 
419     bool use_ke = sys\&.addKECorrection();
420     int Mtot = sys\&.getTotalM();
421 
422     std::vector < double > sysMu (doc["mu"]\&.Size(), 0);
423     for (rapidjson::SizeType i = 0; i < doc["mu"]\&.Size(); ++i) {
424         sysMu[i] = doc["mu"][i]\&.GetDouble();
425     }
426     std::vector < int > sysMax (doc["max_N"]\&.Size(), 0);
427     for (rapidjson::SizeType i = 0; i < doc["max_N"]\&.Size(); ++i) {
428         sysMax[i] = doc["max_N"][i]\&.GetInt();
429     }
430     std::vector < int > sysMin (doc["min_N"]\&.Size(), 0);
431     for (rapidjson::SizeType i = 0; i < doc["min_N"]\&.Size(); ++i) {
432         sysMin[i] = doc["min_N"][i]\&.GetInt();
433     }
434 
435     // Read from restart file if specified
436     if (restart_file != "") {
437         try {
438             sys\&.readConfig(restart_file);
439         } catch (customException &ce) {
440             std::cerr << ce\&. what() << std::endl;
441         }
442     } else if (restart_file == "" && sys\&.totNMin() > 0) {
443         std::cout << "Automatically generating the initial configuration" << std::endl;
444 
445         // have to generate initial configuration manually - start with mu = INF
446         std::vector < double > initMu (doc["num_species"]\&.GetInt(), 1\&.0e2);
447         simSystem initSys (doc["num_species"]\&.GetInt(), 1/10\&., sysBox, initMu, sysMax, sysMin, Mtot, duh, max_order); // beta =  1/T, so low beta to have high T
448         if (use_ke) {
449             initSys\&.toggleKE();
450             if (initSys\&.addKECorrection() == false) {
451                 throw customException ("Unable to set KE flag");
452             }
453         }
454 
455         // add the same potentials
456         setPairPotentials (initSys, doc);
457         initializeSystemBarriers (initSys, doc);
458 
459         std::vector < int > initialization_order (sys\&.nSpecies(), 0), check_init (sys\&.nSpecies(), 0);
460         std::vector < double > init_frac (sys\&.nSpecies(), 1\&.0);
461         double sum = 0\&.0;
462         for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
463             initialization_order[i] = i;
464             if (i > 0) init_frac[i] = 0\&.0;
465             sum += init_frac[i];
466         }
467         if (doc\&.HasMember("init_order")) {
468             assert(doc["init_order"]\&.IsArray());
469             assert(doc["init_order"]\&.Size() == doc["num_species"]\&.GetInt());
470 
471             for (rapidjson::SizeType i = 0; i < doc["init_order"]\&.Size(); ++i) {
472                 assert(doc["init_order"][i]\&.IsInt());
473                 initialization_order[i] = doc["init_order"][i]\&.GetInt();
474                 if (initialization_order[i] < 0 || initialization_order[i] >= sys\&.nSpecies()) {
475                     std::cerr << "Order of initialization goes out of bounds, should include 0 <= i < nSpec" << std::endl;
476                     exit(SYS_FAILURE);
477                 }
478                 if (check_init[initialization_order[i]] != 0) {
479                     std::cerr << "Order of initialization repeats itself" << std::endl;
480                     exit(SYS_FAILURE);
481                 } else {
482                     check_init[initialization_order[i]] = 1;
483                 }
484             }
485         }
486         if (doc\&.HasMember("init_frac")) {
487             assert(doc["init_frac"]\&.IsArray());
488             assert(doc["init_frac"]\&.Size() == doc["num_species"]\&.GetInt());
489             sum = 0\&.0;
490             for (rapidjson::SizeType i = 0; i < doc["init_frac"]\&.Size(); ++i) {
491                 assert(doc["init_frac"][i]\&.IsNumber());
492                 init_frac[i] = doc["init_frac"][i]\&.GetDouble();
493                 if (init_frac[i] < 0 || init_frac[i] >= 1\&.0) {
494                     std::cerr << "Initialization fraction out of bounds" << std::endl;
495                     exit(SYS_FAILURE);
496                 }
497                 sum += init_frac[i];
498             }
499         }
500         for (unsigned int i = 0; i < sys\&.nSpecies(); ++i) {
501             init_frac[i] /= sum;
502         }
503 
504         // iteratively add each individual species, assume we want an equimolar mixture to start from
505         int added = 0;
506         for (unsigned int idx = 0; idx < sys\&.nSpecies(); ++idx) {
507             unsigned int i = initialization_order[idx];
508             std::cout << "Initializing species " << i << " configurations" << std::endl;
509 
510             // insert this species i
511             moves initMove (initSys\&.getTotalM());
512             initMove\&.addInsert(i, 1\&.0);
513 
514             // also add displacment moves for all species present
515             for (unsigned int j = 0; j <= idx; ++j) {
516                 std::cout << "Added translation moves for initialization of species " << initialization_order[j] << std::endl;
517                 initMove\&.addTranslate(initialization_order[j], 2\&.0, 1\&.0, initSys\&.box());
518             }
519 
520             // now do simuation until within proper range
521             int targetNum = sys\&.totNMin()*init_frac[idx];
522             if (idx == sys\&.nSpecies() - 1) {
523                 // to account for integer rounding
524                 targetNum = sys\&.totNMin() - added;
525             }
526             added += targetNum;
527 
528             std::cout << "Target number = " << targetNum << " for species " << i+1 << std::endl;
529             int tmpCounter = 0, statusPrint = 10e6;
530             while (initSys\&.numSpecies[i] < targetNum) {
531                 try {
532                     initMove\&.makeMove(initSys);
533                 } catch (customException &ce) {
534                     std::cerr << "Failed to create an initial configuration: " << ce\&.what() << std::endl;
535                     exit(SYS_FAILURE);
536                 }
537                 tmpCounter++;
538                 if (tmpCounter%statusPrint == 0) {
539                     tmpCounter = 0;
540                     std::cout << "Grew " << initSys\&.numSpecies[i] << " atoms of type " << i << " so far" << std::endl;
541                 }
542             }
543         }
544 
545         // print snapshot from Reading initial configuration
546         initSys\&.printSnapshot("auto-init\&.xyz", "auto-generated initial configuration");
547 
548         // read into sys
549         try {
550             sys\&.readConfig("auto-init\&.xyz");
551         } catch (customException &ce) {
552             std::cerr << "Failed to read auto-generated initialization file: " << ce\&. what() << std::endl;
553         }
554     }
555 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
