.TH "swapParticles" 3 "Wed Dec 28 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
swapParticles \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <swap\&.h>\fP
.PP
Inherits \fBmcMove\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBswapParticles\fP ()"
.br
.ti -1c
.RI "\fBswapParticles\fP (const int typeIndex1, const int typeIndex2, const std::string tag)"
.br
.RI "\fIInstantiate a new move, also give a name which is the combination of a user-defined tag + the particle indices it operates on\&. \fP"
.ti -1c
.RI "int \fBmake\fP (\fBsimSystem\fP &sys)"
.br
.RI "\fISwap two particles of different types in the system\&. \fP"
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 14 of file swap\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "swapParticles::swapParticles ()\fC [inline]\fP"

.PP
Definition at line 16 of file swap\&.h\&.
.PP
References mcMove::changeN_\&.
.PP
.nf
16 { changeN_ = false; }
.fi
.SS "swapParticles::swapParticles (const inttypeIndex1, const inttypeIndex2, const std::stringtag)\fC [inline]\fP"

.PP
Instantiate a new move, also give a name which is the combination of a user-defined tag + the particle indices it operates on\&. 
.PP
Definition at line 17 of file swap\&.h\&.
.PP
References mcMove::changeN_, mcMove::name_, and mcMove::typeIndex_\&.
.SH "Member Function Documentation"
.PP 
.SS "int swapParticles::make (\fBsimSystem\fP &sys)\fC [virtual]\fP"

.PP
Swap two particles of different types in the system\&. All other information is stored in the \fBsimSystem\fP object\&.
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System object to attempt to swap particles in\&.
.RE
.PP
\fBReturns:\fP
.RS 4
MOVE_SUCCESS if particles are swapped, otherwise MOVE_FAILURE if not\&. Will throw exceptions if there was an error\&. 
.RE
.PP

.PP
Implements \fBmcMove\fP\&.
.PP
Definition at line 10 of file swap\&.cpp\&.
.PP
References simSystem::atoms, simSystem::beta(), simSystem::box(), calculateBias(), simSystem::deleteAtom(), simSystem::getCurrentM(), simSystem::getFractionalAtom(), simSystem::getFractionalAtomType(), simSystem::getNeighborAtoms(), simSystem::getTotN(), simSystem::getWALABias(), simSystem::incrementEnergy(), simSystem::insertAtom(), MOVE_FAILURE, MOVE_SUCCESS, simSystem::nSpecies(), simSystem::numSpecies, atom::pos, simSystem::ppot, rng(), RNG_SEED, simSystem::speciesBarriers, simSystem::tmmcBias, mcMove::typeIndex_, wala::update(), tmmc::updateC(), simSystem::useTMMC, simSystem::useWALA, and customException::what()\&.
.PP
.nf
10                                        {
11     // Choose an atom of each type to try to exchange
12     int n1Avail = sys\&.numSpecies[typeIndex_];
13     if (sys\&.getCurrentM() > 0 && sys\&.getFractionalAtomType() == typeIndex_) {
14         n1Avail++;
15     }
16 
17     int n2Avail = sys\&.numSpecies[typeIndex2_];
18     if (sys\&.getCurrentM() > 0 && sys\&.getFractionalAtomType() == typeIndex2_) {
19         n2Avail++;
20     }
21 
22     if (n1Avail < 1 || n2Avail < 1) {
23         // updates to biasing functions must be done even if at bounds
24         if (sys\&.useWALA) {
25             sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
26         }
27         if (sys\&.useTMMC) {
28             sys\&.tmmcBias->updateC (sys\&.getTotN(), sys\&.getTotN(), sys\&.getCurrentM(), sys\&.getCurrentM(), 0\&.0);
29         }
30         return MOVE_FAILURE;
31     }
32 
33     // because the locations are effectively being swapped, it is fair to select a partially inserted atom to be involved
34     const int a1 = (int) floor(rng (&RNG_SEED) * n1Avail);
35     const int a2 = (int) floor(rng (&RNG_SEED) * n2Avail);
36     atom a1_orig = sys\&.atoms[typeIndex_][a1], a1_new = a1_orig;
37     atom a2_orig = sys\&.atoms[typeIndex2_][a2], a2_new = a2_orig;
38 
39     // positions will be exchanged, but no other property should change
40     a1_new\&.pos = a2_orig\&.pos;
41     a2_new\&.pos = a1_orig\&.pos;
42 
43     const std::vector < double > box = sys\&.box();
44     double V = 1\&.0;
45     for (unsigned int i = 0; i < box\&.size(); ++i) {
46             V *= box[i];
47         }
48 
49         double delEnergy = 0\&.0;
50         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
51             // get positions of neighboring atoms around a1
52             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex_, &sys\&.atoms[typeIndex_][a1]);
53             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
54                 if (neighborAtoms[i] == &sys\&.atoms[typeIndex2_][a2]) {
55                     // skip their interaction as they were already deleted - this is fine because their net pairwise interaction doesn't change over the
56                     // course of the simulation - this means we don't have to actually re-insert the other atom / get its interation somehow later
57                     continue;
58                 } else {
59                 try {
60                     delEnergy += sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], &sys\&.atoms[typeIndex_][a1], box);
61                 } catch (customException& ce) {
62                     std::string a = "Cannot delete because of energy error: ", b = ce\&.what();
63                     throw customException (a+b);
64                 }
65                 }
66             }
67             // add tail correction to potential energy -- only enable for fluid phase simulations
68 #ifdef FLUID_PHASE_SIMULATIONS
69             if (sys\&.ppot[spec][typeIndex_]->useTailCorrection) {
70                 if (!(sys\&.getCurrentM() > 0 && sys\&.getFractionalAtom () == &sys\&.atoms[typeIndex_][a1])) {
71                     // then a1 is not the partially inserted particle and tail interactions must be included
72                     if (spec == typeIndex_) {
73                                 if (sys\&.numSpecies[spec]-1 > 0) {
74                                     delEnergy += sys\&.ppot[spec][typeIndex_]->tailCorrection((sys\&.numSpecies[spec]-1)/V);
75                                 }
76                     } else {
77                                 if (sys\&.numSpecies[spec] > 0) {
78                                     delEnergy += sys\&.ppot[spec][typeIndex_]->tailCorrection(sys\&.numSpecies[spec]/V);
79                                 }
80                     }
81                 }
82             }
83 #endif
84     }
85 
86     // account for wall interaction energy
87     delEnergy += sys\&.speciesBarriers[typeIndex_]\&.energy(&sys\&.atoms[typeIndex_][a1], box);
88 
89         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
90             // get positions of neighboring atoms around a2
91             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex2_, &sys\&.atoms[typeIndex2_][a2]);
92             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
93                 if (neighborAtoms[i] == &sys\&.atoms[typeIndex_][a1]) {
94                     // skip their interaction as they were already deleted - this is fine because their net pairwise interaction doesn't change over the
95                     // course of the simulation - this means we don't have to actually re-insert the other atom / get its interation somehow later
96                     continue;
97                 } else {
98                 try {
99                     delEnergy += sys\&.ppot[spec][typeIndex2_]->energy(neighborAtoms[i], &sys\&.atoms[typeIndex2_][a2], box);
100                 } catch (customException& ce) {
101                     std::string a = "Cannot delete because of energy error: ", b = ce\&.what();
102                     throw customException (a+b);
103                 }
104                 }
105             }
106             // add tail correction to potential energy -- only enable for fluid phase simulations
107 #ifdef FLUID_PHASE_SIMULATIONS
108             if (sys\&.ppot[spec][typeIndex2_]->useTailCorrection) {
109                 if (!(sys\&.getCurrentM() > 0 && sys\&.getFractionalAtom () == &sys\&.atoms[typeIndex2_][a2])) {
110                     // then a2 is not the partially inserted particle and tail interactions must be included
111                     if (spec == typeIndex2_) {
112                                 if (sys\&.numSpecies[spec]-1 > 0) {
113                                     delEnergy += sys\&.ppot[spec][typeIndex2_]->tailCorrection((sys\&.numSpecies[spec]-1)/V);
114                                 }
115                     } else {
116                                 if (sys\&.numSpecies[spec] > 0) {
117                                     delEnergy += sys\&.ppot[spec][typeIndex2_]->tailCorrection(sys\&.numSpecies[spec]/V);
118                                 }
119                     }
120                 }
121             }
122 #endif
123         }
124 
125         // account for wall interaction energy
126         delEnergy += sys\&.speciesBarriers[typeIndex2_]\&.energy(&sys\&.atoms[typeIndex2_][a2], box);
127 
128         double insEnergy = 0\&.0;
129         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
130             // get positions of neighboring atoms around a1's (a2's) new (old) location
131             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex_, &a1_new);
132             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
133                 // with these new "copy atoms" getNeighborAtoms can't guarantee it doesn't point to old self, so must check
134                 if ((neighborAtoms[i] == &sys\&.atoms[typeIndex2_][a2]) || (neighborAtoms[i] == &sys\&.atoms[typeIndex_][a1])) {
135                     continue;
136                 } else {
137                 try {
138                     insEnergy += sys\&.ppot[spec][typeIndex_]->energy(neighborAtoms[i], &a1_new, box);
139                 } catch (customException& ce) {
140                     std::string a = "Cannot insert because of energy error: ", b = ce\&.what();
141                     throw customException (a+b);
142                 }
143                 }
144             }
145             // add tail correction to potential energy -- only enable for fluid phase simulations
146 #ifdef FLUID_PHASE_SIMULATIONS
147             if (sys\&.ppot[spec][typeIndex_]->useTailCorrection) {
148                 if (!(sys\&.getCurrentM() > 0 && sys\&.getFractionalAtom () == &sys\&.atoms[typeIndex_][a1])) {
149                     // then a1 is not the partially inserted particle and tail interactions must be included
150                     if (spec == typeIndex_) {
151                                 if (sys\&.numSpecies[spec]-1 > 0) {
152                                     insEnergy += sys\&.ppot[spec][typeIndex_]->tailCorrection((sys\&.numSpecies[spec]-1)/V);
153                             }
154                     } else {
155                                 if (sys\&.numSpecies[spec] > 0) {
156                                     insEnergy += sys\&.ppot[spec][typeIndex_]->tailCorrection(sys\&.numSpecies[spec]/V);
157                                 }
158                     }
159                 }
160             }
161 #endif
162         }
163         // account for wall interaction energy
164         insEnergy += sys\&.speciesBarriers[typeIndex_]\&.energy(&a1_new, box);
165 
166         for (unsigned int spec = 0; spec < sys\&.nSpecies(); ++spec) {
167             // get positions of neighboring atoms around a2's (a1's) new (old) location
168             std::vector < atom* > neighborAtoms = sys\&.getNeighborAtoms(spec, typeIndex2_, &a2_new);
169             for (unsigned int i = 0; i < neighborAtoms\&.size(); ++i) {
170                 if ((neighborAtoms[i] == &sys\&.atoms[typeIndex_][a1]) || (neighborAtoms[i] == &sys\&.atoms[typeIndex2_][a2])) {
171                     continue;
172                 } else {
173                 try {
174                     insEnergy += sys\&.ppot[spec][typeIndex2_]->energy(neighborAtoms[i], &a2_new, box);
175                 } catch (customException& ce) {
176                     std::string a = "Cannot insert because of energy error: ", b = ce\&.what();
177                     throw customException (a+b);
178                 }
179                 }
180             }
181             // add tail correction to potential energy -- only enable for fluid phase simulations
182 #ifdef FLUID_PHASE_SIMULATIONS
183             if (sys\&.ppot[spec][typeIndex2_]->useTailCorrection) {
184                 if (!(sys\&.getCurrentM() > 0 && sys\&.getFractionalAtom () == &sys\&.atoms[typeIndex2_][a2])) {
185                     // then a2 is not the partially inserted particle and tail interactions must be included
186                     if (spec == typeIndex2_) {
187                                 if (sys\&.numSpecies[spec]-1 > 0) {
188                                     insEnergy += sys\&.ppot[spec][typeIndex2_]->tailCorrection((sys\&.numSpecies[spec]-1)/V);
189                                 }
190                     } else {
191                                 if (sys\&.numSpecies[spec] > 0) {
192                                     insEnergy += sys\&.ppot[spec][typeIndex2_]->tailCorrection(sys\&.numSpecies[spec]/V);
193                                 }
194                     }
195                 }
196             }
197 #endif
198         }
199         // account for wall interaction energy
200         insEnergy += sys\&.speciesBarriers[typeIndex2_]\&.energy(&a2_new, box);
201 
202     // Biasing
203         const double p_u = exp(-sys\&.beta()*(insEnergy - delEnergy));
204         double bias = calculateBias(sys, sys\&.getTotN(), sys\&.getCurrentM());
205 
206         // tmmc gets updated the same way, regardless of whether the move gets accepted
207         if (sys\&.useTMMC) {
208             sys\&.tmmcBias->updateC (sys\&.getTotN(), sys\&.getTotN(), sys\&.getCurrentM(), sys\&.getCurrentM(), std::min(1\&.0, p_u));
209         }
210 
211     if (rng (&RNG_SEED) < p_u*bias) {
212         sys\&.incrementEnergy(insEnergy - delEnergy);
213 
214         // swap the particles by deleting/reinserting
215 
216         // could probably make this faster by using translateAtom instead of full insert/delete?
217 
218         // -a1 completely
219         try {
220             sys\&.deleteAtom(typeIndex_, a1, true);
221         } catch (customException &ce) {
222             std::string a = "Failed to delete atom during swapping: ", b = ce\&.what();
223             throw customException (a+b);
224         }
225 
226         // -a2 completely
227         try {
228             sys\&.deleteAtom(typeIndex2_, a2, true);
229         } catch (customException &ce) {
230             std::string a = "Failed to delete atom during swapping: ", b = ce\&.what();
231             throw customException (a+b);
232         }
233 
234         // +a1_new completely
235         try {
236             sys\&.insertAtom(typeIndex_, &a1_new, true);
237         } catch (customException &ce) {
238             std::string a = "Failed to insert atom during swapping: ", b = ce\&.what();
239             throw customException (a+b);
240         }
241 
242         // +a2_new completely
243         try {
244             sys\&.insertAtom(typeIndex2_, &a2_new, true);
245         } catch (customException &ce) {
246             std::string a = "Failed to insert atom during swapping: ", b = ce\&.what();
247             throw customException (a+b);
248         }
249 
250         // update Wang-Landau bias, if used
251         if (sys\&.useWALA) {
252             sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
253         }
254 
255         // double check
256         /*if (n1_orig != sys\&.numSpecies[typeIndex_]) {
257             throw customException ("Number of species 1 atoms do not match before and after swap move");
258         }
259         if (n2_orig != sys\&.numSpecies[typeIndex2_]) {
260             throw customException ("Number of species 2 atoms do not match before and after swap move");
261         }
262         if (fracType != sys\&.getFractionalAtomType()) {
263             throw customException ("Fractional type has changed during course of swap move");
264         }
265         if (m_orig != sys\&.getCurrentM()) {
266             throw customException ("Expanded ensemble state of system has changed during course of swap move");
267         }*/
268 
269     return MOVE_SUCCESS;
270         }
271 
272     // update Wang-Landau bias (even if moved failed), if used
273     if (sys\&.useWALA) {
274         sys\&.getWALABias()->update(sys\&.getTotN(), sys\&.getCurrentM());
275     }
276 
277     return MOVE_FAILURE;
278 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
