.TH "checkpoint" 3 "Fri Dec 30 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
checkpoint \- 
.PP
Information to restart/checkpoint the simulation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <checkpoint\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcheckpoint\fP ()"
.br
.ti -1c
.RI "\fBcheckpoint\fP (const std::string directory, const long int frequency, \fBsimSystem\fP &sys, const bool snaps=false, const bool override=false)"
.br
.RI "\fIRead system state from a file\&. \fP"
.ti -1c
.RI "\fB~checkpoint\fP ()"
.br
.ti -1c
.RI "void \fBload\fP (\fBsimSystem\fP &sys, const bool override)"
.br
.RI "\fIRead state of a system from a json file\&. \fP"
.ti -1c
.RI "void \fBdump\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0, const bool refine=true)"
.br
.RI "\fISave the state of a system to a json file\&. \fP"
.ti -1c
.RI "bool \fBcheck\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0, const bool refine=true)"
.br
.RI "\fICheck how long it has been since last checkpoint, and write new one if has exceeded frequency\&. \fP"
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBhasCheckpoint\fP"
.br
.RI "\fIAt least one checkpoint has been made that the system can restart from\&. \fP"
.ti -1c
.RI "bool \fBtakeSnaps\fP"
.br
.RI "\fISave snapshot of the system each time a record is made\&. \fP"
.ti -1c
.RI "bool \fBtmmcDone\fP"
.br
.ti -1c
.RI "bool \fBcrossoverDone\fP"
.br
.ti -1c
.RI "bool \fBwalaDone\fP"
.br
.RI "\fIProgress of each stage, regardless of where the checkpoint indicated to start from\&. \fP"
.ti -1c
.RI "bool \fBresFromWALA\fP"
.br
.ti -1c
.RI "bool \fBresFromCross\fP"
.br
.ti -1c
.RI "bool \fBresFromTMMC\fP"
.br
.RI "\fIFlags corresponding to which stage the checkpoint indicated to restart from\&. \fP"
.ti -1c
.RI "long int \fBfreq\fP"
.br
.RI "\fIFrequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) \fP"
.ti -1c
.RI "long long int \fBmoveCounter\fP"
.br
.RI "\fITracks the number of moves in a given sweep that have executed\&. \fP"
.ti -1c
.RI "long long int \fBsweepCounter\fP"
.br
.RI "\fITracks the number of sweeps that have executed\&. \fP"
.ti -1c
.RI "double \fBwala_lnF\fP"
.br
.RI "\fICurrent value of lnF from WALA\&. \fP"
.ti -1c
.RI "std::string \fBdir\fP"
.br
.RI "\fIName of the checkpoint directory containing the information to reinitialize the system (json) \fP"
.ti -1c
.RI "std::string \fBchkptName\fP"
.br
.RI "\fIName of checkpoint file\&. \fP"
.ti -1c
.RI "std::vector< double > \fBelb\fP"
.br
.ti -1c
.RI "std::vector< double > \fBeub\fP"
.br
.RI "\fIUpper and lower energy bounds for energy histogram\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Information to restart/checkpoint the simulation\&. 
.PP
Definition at line 22 of file checkpoint\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "checkpoint::checkpoint ()\fC [inline]\fP"

.PP
Definition at line 24 of file checkpoint\&.h\&.
.PP
References crossoverDone, dir, freq, hasCheckpoint, resFromCross, resFromTMMC, resFromWALA, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
24 { tmmcDone = false; crossoverDone = false; walaDone = false; hasCheckpoint = false; resFromTMMC = false; resFromWALA = false; resFromCross = false; takeSnaps = false; freq = -1; dir = "checkpt"; }
.fi
.SS "checkpoint::checkpoint (const std::stringdirectory, const long intfrequency, \fBsimSystem\fP &sys, const boolsnaps = \fCfalse\fP, const booloverride = \fCfalse\fP)"

.PP
Read system state from a file\&. If checkpoint directory is found and json file is valid, data is loaded from it\&. Note that although this stores the frequency, it does not use the value it dumps to file\&. This class always uses the frequency given when the class is instantiated\&.
.PP
\fBParameters:\fP
.RS 4
\fIdir\fP Directory where system state was saved 
.br
\fIfrequency\fP Frquency to take snapshots/checkpoints of the system (< 0 disables) 
.br
\fIsys\fP System to checkpoint 
.br
\fIsnaps\fP Take snapshots each time a record is made to make a movie? (default = false) 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 14 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, fileExists(), freq, hasCheckpoint, load(), moveCounter, resFromCross, resFromTMMC, resFromWALA, simSystem::restartFromTMMC, sweepCounter, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
14                                                                                                                                   {
15     tmmcDone = false;
16     crossoverDone = false;
17     walaDone = false;
18     hasCheckpoint = false;
19     takeSnaps = snaps;
20     dir = directory;
21     freq = frequency;
22     moveCounter = 0;
23     sweepCounter = 0;
24     resFromWALA = false;
25     resFromCross = false;
26     resFromTMMC = false;
27 
28     chkptName = dir+"/state\&.json";
29     if (fileExists(chkptName)) {
30         try {
31             load(sys, override);
32         } catch (std::exception &ex) {
33             std::string a = "Unable to load checkpoint "+chkptName+" : ";
34             std::string b = ex\&.what();
35             throw customException (a+b);
36         }
37     } else {
38         // Forcible skip to TMMC stage if want to manually start TMMC
39         if (sys\&.restartFromTMMC){
40             walaDone = true;
41             crossoverDone = true;
42         }
43     }
44 
45     time(&lastCheckPt_); // Take time when object was instantiated as initial time so that check() has a point of reference
46 }
.fi
.SS "checkpoint::~checkpoint ()\fC [inline]\fP"

.PP
Definition at line 26 of file checkpoint\&.h\&.
.PP
.nf
26 {};
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool checkpoint::check (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP, const boolrefine = \fCtrue\fP)"

.PP
Check how long it has been since last checkpoint, and write new one if has exceeded frequency\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed 
.br
\fIrefine\fP Refine the histogram boundaries before printing any? (default=true)
.RE
.PP
\fBReturns:\fP
.RS 4
bool Is a checkpoint being generated or not 
.RE
.PP

.PP
Definition at line 285 of file checkpoint\&.cpp\&.
.PP
References dump(), and freq\&.
.PP
Referenced by performCrossover(), performTMMC(), and performWALA()\&.
.PP
.nf
285                                                                                                                             {
286     if (freq > 0) {
287         if (std::abs(difftime(time(&now_), lastCheckPt_)) >= freq) {
288             dump(sys, moveCounter, sweepCounter, refine);
289             return true;
290         }
291     }
292     return false;
293 }
.fi
.SS "void checkpoint::dump (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP, const boolrefine = \fCtrue\fP)"

.PP
Save the state of a system to a json file\&. Creates the checkpoint directory if it doesn't exist\&.
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed 
.br
\fIrefine\fP Refine the histogram boundaries before printing any? (default=true) 
.RE
.PP

.PP
Definition at line 159 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, elb, eub, simSystem::extMomCounter(), fileExists(), freq, simSystem::getELB(), simSystem::getEUB(), getTimeStamp(), simSystem::getTMMCBias(), simSystem::getWALABias(), hasCheckpoint, wala::lnF(), tmmc::print(), wala::print(), simSystem::printEnergyHistogram(), simSystem::printExtMoments(), simSystem::printPkHistogram(), simSystem::printSnapshot(), simSystem::refineEnergyHistogramBounds(), simSystem::refinePkHistogramBounds(), takeSnaps, tmmcDone, and walaDone\&.
.PP
Referenced by check()\&.
.PP
.nf
159                                                                                                                            {
160     if (!fileExists(chkptName)) {
161         std::string command = "mkdir -p "+dir+" && touch "+chkptName;
162         const int succ = system(command\&.c_str());
163         if (succ != 0) {
164             throw customException("Unable to initialize checkpoint");
165         }
166     }
167 
168     rapidjson::StringBuffer s;
169     rapidjson::PrettyWriter < rapidjson::StringBuffer > writer(s);
170     hasCheckpoint = true;
171 
172     // Write restart/checkpoint options
173     writer\&.StartObject();
174     writer\&.String("tmmcDone");
175     writer\&.Bool(tmmcDone);
176 
177     writer\&.String("crossoverDone");
178     writer\&.Bool(crossoverDone);
179 
180     writer\&.String("walaDone");
181     writer\&.Bool(walaDone);
182 
183     writer\&.String("hasCheckpoint");
184     writer\&.Bool(hasCheckpoint);
185 
186     writer\&.String("takeSnaps");
187     writer\&.Bool(takeSnaps);
188 
189     writer\&.String("freq");
190     writer\&.Int64(freq);
191 
192     writer\&.String("dir");
193     writer\&.String(dir\&.c_str());
194 
195     writer\&.String("moveCounter");
196     writer\&.Double(moveCounter);
197 
198     writer\&.String("sweepCounter");
199     writer\&.Double(sweepCounter);
200 
201     if (walaDone && crossoverDone) { // In final TMMC stage or just finished the TMMC (end of simulation)
202         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
203         if (refine) {
204             sys\&.refineEnergyHistogramBounds();
205         }
206         sys\&.printEnergyHistogram(dir+"/eHist", false); // Un-normalized Energy histogram
207         if (refine) {
208             sys\&.refinePkHistogramBounds();
209         }
210         sys\&.printPkHistogram(dir+"/pkHist", false); // Un-normalized Particle histogram
211         sys\&.printExtMoments(dir+"/extMom", false); // Un-normalized Extensive moments, plus counter (number of times each recorded)
212         writer\&.String("extMomCounter");
213         std::vector < double > ctr = sys\&.extMomCounter();
214         writer\&.StartArray();
215         for (std::vector < double >::iterator it = ctr\&.begin(); it < ctr\&.end(); ++it) {
216             writer\&.Double(*it);
217         }
218         writer\&.EndArray();
219     } else if (walaDone && !crossoverDone && !tmmcDone) { // In crossover stage
220         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
221         sys\&.getWALABias()->print(dir+"/wala", true);
222 
223         writer\&.String("wala_lnF");
224         writer\&.Double(sys\&.getWALABias()->lnF());
225 
226         // Energy upper and lower bounds for histogram
227         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
228         writer\&.String("energyHistogramLB");
229         writer\&.StartArray();
230         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
231             writer\&.Double(*it);
232         }
233         writer\&.EndArray();
234         writer\&.String("energyHistogramUB");
235         writer\&.StartArray();
236         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
237             writer\&.Double(*it);
238         }
239         writer\&.EndArray();
240     } else if (!walaDone && !crossoverDone && !tmmcDone) { // In WALA stage
241         sys\&.getWALABias()->print(dir+"/wala", true);
242 
243         writer\&.String("wala_lnF");
244         writer\&.Double(sys\&.getWALABias()->lnF());
245 
246         // Energy upper and lower bounds for histogram
247         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
248         writer\&.String("energyHistogramLB");
249         writer\&.StartArray();
250         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
251             writer\&.Double(*it);
252         }
253         writer\&.EndArray();
254         writer\&.String("energyHistogramUB");
255         writer\&.StartArray();
256         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
257             writer\&.Double(*it);
258         }
259         writer\&.EndArray();
260     } else {
261         throw customException ("Uncertain which stage simulation is in, so cannot checkpoint");
262     }
263     writer\&.EndObject();
264     std::ofstream outData(chkptName\&.c_str());
265     outData << s\&.GetString() << std::endl;
266 
267     sys\&.printSnapshot(dir+"/snap\&.xyz", getTimeStamp(), true); // Instantaneous snapshot
268     if (takeSnaps) { // This only prints M = 0 atoms (fully inserted) to create a movie
269         sys\&.printSnapshot(dir+"/movie\&.xyz", getTimeStamp(), false);
270     }
271 
272     time(&lastCheckPt_);
273 }
.fi
.SS "void checkpoint::load (\fBsimSystem\fP &sys, const booloverride)"

.PP
Read state of a system from a json file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 54 of file checkpoint\&.cpp\&.
.PP
References tmmc::calculatePI(), chkptName, crossoverDone, dir, elb, eub, fileExists(), simSystem::getTMMCBias(), simSystem::getTotalM(), simSystem::getWALABias(), hasCheckpoint, moveCounter, parseJson(), tmmc::readC(), simSystem::readConfig(), wala::readH(), tmmc::readHC(), wala::readlnPI(), resFromCross, resFromTMMC, resFromWALA, simSystem::restartEnergyHistogram(), simSystem::restartExtMoments(), simSystem::restartPkHistogram(), sendErr(), sendMsg(), simSystem::setELB(), simSystem::setEUB(), simSystem::startTMMC(), simSystem::startWALA(), sweepCounter, SYS_FAILURE, takeSnaps, tmmcDone, simSystem::tmmcSweepSize, simSystem::wala_g, wala_lnF, simSystem::wala_s, and walaDone\&.
.PP
Referenced by checkpoint()\&.
.PP
.nf
54                                                           {
55     if (!fileExists(chkptName) && !override) {
56         throw customException ("No checkpoint by the name: "+chkptName);
57     }
58 
59     rapidjson::Document doc;
60     try {
61         parseJson (chkptName, doc);
62 
63         tmmcDone = doc["tmmcDone"]\&.GetBool();
64         crossoverDone = doc["crossoverDone"]\&.GetBool();
65         walaDone = doc["walaDone"]\&.GetBool();
66         hasCheckpoint = doc["hasCheckpoint"]\&.GetBool();
67         takeSnaps = doc["takeSnaps"]\&.GetBool();
68         dir = doc["dir"]\&.GetString();
69         moveCounter = (long long int)doc["moveCounter"]\&.GetDouble();
70         sweepCounter = (long long int)doc["sweepCounter"]\&.GetDouble();
71 
72         if (walaDone && crossoverDone) { // In final TMMC stage or just finished the TMMC (end of simulation)
73             resFromTMMC = true;
74             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
75             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
76             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
77             sys\&.getTMMCBias()->calculatePI();
78             std::vector < double > ctr (doc["extMomCounter"]\&.Size(), 0);
79             for (unsigned int i = 0; i < doc["extMomCounter"]\&.Size(); ++i) {
80                 ctr[i] = doc["extMomCounter"][i]\&.GetDouble();
81             }
82             sys\&.restartEnergyHistogram(dir+"/eHist");
83             sys\&.restartPkHistogram(dir+"/pkHist");
84             sys\&.restartExtMoments(dir+"/extMom", ctr);
85         } else if (walaDone && !crossoverDone && !tmmcDone) { // In crossover stage
86             resFromCross = true;
87             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
88             wala_lnF = doc["wala_lnF"]\&.GetDouble();
89             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
90 
91             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
92             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
93             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
94             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
95 
96             // Energy upper and lower bounds for histogram
97             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
98             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
99                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
100             }
101             sys\&.setELB(elb);
102 
103             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
104             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
105                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
106             }
107             sys\&.setEUB(eub);
108         } else if (!walaDone && !crossoverDone && !tmmcDone) { // In WALA stage and printed 1st checkpoint already
109             resFromWALA = true;
110             wala_lnF = doc["wala_lnF"]\&.GetDouble();
111             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
112 
113             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
114             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
115 
116             // Energy upper and lower bounds for histogram
117             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
118             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
119                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
120             }
121             sys\&.setELB(elb);
122 
123             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
124             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
125                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
126             }
127             sys\&.setEUB(eub);
128         } else {
129             if (!override) {
130                 sendErr("Uncertain which stage simulation is in, so cannot checkpoint");
131                 exit(SYS_FAILURE);
132             }
133         }
134 
135         sys\&.readConfig(dir+"/snap\&.xyz");
136         hasCheckpoint = true;
137     } catch (std::exception &ex) {
138         std::string msg = ex\&.what();
139         if (!override) {
140             hasCheckpoint = false;
141             sendErr("Unable to load checkpoint "+msg);
142             exit(SYS_FAILURE);
143         } else {
144             sendErr("Overriding the following errors to load checkpoint "+msg);
145         }
146     }
147 
148     sendMsg("Checkpoint loaded from "+chkptName);
149 }
.fi
.SH "Field Documentation"
.PP 
.SS "std::string checkpoint::chkptName"

.PP
Name of checkpoint file\&. 
.PP
Definition at line 43 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::crossoverDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performCrossover()\&.
.SS "std::string checkpoint::dir"

.PP
Name of the checkpoint directory containing the information to reinitialize the system (json) 
.PP
Definition at line 42 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "std::vector< double > checkpoint::elb"

.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "std::vector< double > checkpoint::eub"

.PP
Upper and lower energy bounds for energy histogram\&. 
.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "long int checkpoint::freq"

.PP
Frequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) 
.PP
Definition at line 37 of file checkpoint\&.h\&.
.PP
Referenced by check(), checkpoint(), and dump()\&.
.SS "bool checkpoint::hasCheckpoint"

.PP
At least one checkpoint has been made that the system can restart from\&. 
.PP
Definition at line 32 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "long long int checkpoint::moveCounter"

.PP
Tracks the number of moves in a given sweep that have executed\&. 
.PP
Definition at line 38 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), performTMMC(), and performWALA()\&.
.SS "bool checkpoint::resFromCross"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performCrossover()\&.
.SS "bool checkpoint::resFromTMMC"

.PP
Flags corresponding to which stage the checkpoint indicated to restart from\&. 
.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performTMMC()\&.
.SS "bool checkpoint::resFromWALA"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performWALA()\&.
.SS "long long int checkpoint::sweepCounter"

.PP
Tracks the number of sweeps that have executed\&. 
.PP
Definition at line 39 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), and performTMMC()\&.
.SS "bool checkpoint::takeSnaps"

.PP
Save snapshot of the system each time a record is made\&. 
.PP
Definition at line 33 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::tmmcDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performTMMC()\&.
.SS "double checkpoint::wala_lnF"

.PP
Current value of lnF from WALA\&. 
.PP
Definition at line 40 of file checkpoint\&.h\&.
.PP
Referenced by load()\&.
.SS "bool checkpoint::walaDone"

.PP
Progress of each stage, regardless of where the checkpoint indicated to start from\&. 
.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performWALA()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
