.TH "checkpoint" 3 "Fri Dec 30 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
checkpoint \- 
.PP
Information to restart/checkpoint the simulation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <checkpoint\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcheckpoint\fP ()"
.br
.ti -1c
.RI "\fBcheckpoint\fP (const std::string directory, const long int frequency, \fBsimSystem\fP &sys, const bool snaps=false, const bool override=false)"
.br
.RI "\fIRead system state from a file\&. \fP"
.ti -1c
.RI "\fB~checkpoint\fP ()"
.br
.ti -1c
.RI "void \fBload\fP (\fBsimSystem\fP &sys, const bool override)"
.br
.RI "\fIRead state of a system from a json file\&. \fP"
.ti -1c
.RI "void \fBdump\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0, const bool refine=true)"
.br
.RI "\fISave the state of a system to a json file\&. \fP"
.ti -1c
.RI "bool \fBcheck\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0, const bool refine=true)"
.br
.RI "\fICheck how long it has been since last checkpoint, and write new one if has exceeded frequency\&. \fP"
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBhasCheckpoint\fP"
.br
.RI "\fIAt least one checkpoint has been made that the system can restart from\&. \fP"
.ti -1c
.RI "bool \fBtakeSnaps\fP"
.br
.RI "\fISave snapshot of the system each time a record is made\&. \fP"
.ti -1c
.RI "bool \fBtmmcDone\fP"
.br
.ti -1c
.RI "bool \fBcrossoverDone\fP"
.br
.ti -1c
.RI "bool \fBwalaDone\fP"
.br
.RI "\fIProgress of each stage, regardless of where the checkpoint indicated to start from\&. \fP"
.ti -1c
.RI "bool \fBresFromWALA\fP"
.br
.ti -1c
.RI "bool \fBresFromCross\fP"
.br
.ti -1c
.RI "bool \fBresFromTMMC\fP"
.br
.RI "\fIFlags corresponding to which stage the checkpoint indicated to restart from\&. \fP"
.ti -1c
.RI "long int \fBfreq\fP"
.br
.RI "\fIFrequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) \fP"
.ti -1c
.RI "long long int \fBmoveCounter\fP"
.br
.RI "\fITracks the number of moves in a given sweep that have executed\&. \fP"
.ti -1c
.RI "long long int \fBsweepCounter\fP"
.br
.RI "\fITracks the number of sweeps that have executed\&. \fP"
.ti -1c
.RI "double \fBwala_lnF\fP"
.br
.RI "\fICurrent value of lnF from WALA\&. \fP"
.ti -1c
.RI "std::string \fBdir\fP"
.br
.RI "\fIName of the checkpoint directory containing the information to reinitialize the system (json) \fP"
.ti -1c
.RI "std::string \fBchkptName\fP"
.br
.RI "\fIName of checkpoint file\&. \fP"
.ti -1c
.RI "std::vector< double > \fBelb\fP"
.br
.ti -1c
.RI "std::vector< double > \fBeub\fP"
.br
.RI "\fIUpper and lower energy bounds for energy histogram\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Information to restart/checkpoint the simulation\&. 
.PP
Definition at line 22 of file checkpoint\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "checkpoint::checkpoint ()\fC [inline]\fP"

.PP
Definition at line 24 of file checkpoint\&.h\&.
.PP
References crossoverDone, dir, freq, hasCheckpoint, resFromCross, resFromTMMC, resFromWALA, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
24 { tmmcDone = false; crossoverDone = false; walaDone = false; hasCheckpoint = false; resFromTMMC = false; resFromWALA = false; resFromCross = false; takeSnaps = false; freq = -1; dir = "checkpt"; }
.fi
.SS "checkpoint::checkpoint (const std::stringdirectory, const long intfrequency, \fBsimSystem\fP &sys, const boolsnaps = \fCfalse\fP, const booloverride = \fCfalse\fP)"

.PP
Read system state from a file\&. If checkpoint directory is found and json file is valid, data is loaded from it\&. Note that although this stores the frequency, it does not use the value it dumps to file\&. This class always uses the frequency given when the class is instantiated\&.
.PP
\fBParameters:\fP
.RS 4
\fIdir\fP Directory where system state was saved 
.br
\fIfrequency\fP Frquency to take snapshots/checkpoints of the system (< 0 disables) 
.br
\fIsys\fP System to checkpoint 
.br
\fIsnaps\fP Take snapshots each time a record is made to make a movie? (default = false) 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 14 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, fileExists(), freq, hasCheckpoint, load(), moveCounter, resFromCross, resFromTMMC, resFromWALA, simSystem::restartFromTMMC, sweepCounter, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
14                                                                                                                                   {
15     tmmcDone = false;
16     crossoverDone = false;
17     walaDone = false;
18     hasCheckpoint = false;
19     takeSnaps = snaps;
20     dir = directory;
21     freq = frequency;
22     moveCounter = 0;
23     sweepCounter = 0;
24     resFromWALA = false;
25     resFromCross = false;
26     resFromTMMC = false;
27 
28     chkptName = dir+"/state\&.json";
29     if (fileExists(chkptName)) {
30         try {
31             load(sys, override);
32         } catch (std::exception &ex) {
33             std::string a = "Unable to load checkpoint "+chkptName+" : ";
34             std::string b = ex\&.what();
35             throw customException (a+b);
36         }
37     } else {
38         std::string command = "mkdir -p "+dir+" && touch "+chkptName;
39         const int succ = system(command\&.c_str());
40         if (succ != 0) {
41             throw customException("Unable to initialize checkpoint");
42         }
43 
44         // Forcible skip to TMMC stage if want to manually start TMMC
45         if (sys\&.restartFromTMMC){
46             walaDone = true;
47             crossoverDone = true;
48         }
49     }
50 
51     time(&lastCheckPt_); // Take time when object was instantiated as initial time
52 }
.fi
.SS "checkpoint::~checkpoint ()\fC [inline]\fP"

.PP
Definition at line 26 of file checkpoint\&.h\&.
.PP
.nf
26 {};
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool checkpoint::check (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP, const boolrefine = \fCtrue\fP)"

.PP
Check how long it has been since last checkpoint, and write new one if has exceeded frequency\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed 
.br
\fIrefine\fP Refine the histogram boundaries before printing any? (default=true)
.RE
.PP
\fBReturns:\fP
.RS 4
bool Is a checkpoint being generated or not 
.RE
.PP

.PP
Definition at line 290 of file checkpoint\&.cpp\&.
.PP
References dump(), and freq\&.
.PP
Referenced by performCrossover(), performTMMC(), and performWALA()\&.
.PP
.nf
290                                                                                                                             {
291     if (freq > 0) {
292         if (std::abs(difftime(time(&now_), lastCheckPt_)) >= freq) {
293             dump(sys, moveCounter, sweepCounter, refine);
294             return true;
295         }
296     }
297     return false;
298 }
.fi
.SS "void checkpoint::dump (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP, const boolrefine = \fCtrue\fP)"

.PP
Save the state of a system to a json file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed 
.br
\fIrefine\fP Refine the histogram boundaries before printing any? (default=true) 
.RE
.PP

.PP
Definition at line 168 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, elb, eub, simSystem::extMomCounter(), freq, simSystem::getELB(), simSystem::getEUB(), getTimeStamp(), simSystem::getTMMCBias(), simSystem::getWALABias(), hasCheckpoint, wala::lnF(), tmmc::print(), wala::print(), simSystem::printEnergyHistogram(), simSystem::printExtMoments(), simSystem::printPkHistogram(), simSystem::printSnapshot(), simSystem::refineEnergyHistogramBounds(), simSystem::refinePkHistogramBounds(), takeSnaps, tmmcDone, and walaDone\&.
.PP
Referenced by check()\&.
.PP
.nf
168                                                                                                                            {
169     rapidjson::StringBuffer s;
170     rapidjson::PrettyWriter < rapidjson::StringBuffer > writer(s);
171     hasCheckpoint = true;
172 
173     // Write restart/checkpoint options
174     writer\&.StartObject();
175     writer\&.String("tmmcDone");
176     writer\&.Bool(tmmcDone);
177 
178     writer\&.String("crossoverDone");
179     writer\&.Bool(crossoverDone);
180 
181     writer\&.String("walaDone");
182     writer\&.Bool(walaDone);
183 
184     writer\&.String("hasCheckpoint");
185     writer\&.Bool(hasCheckpoint);
186 
187     writer\&.String("takeSnaps");
188     writer\&.Bool(takeSnaps);
189 
190     writer\&.String("freq");
191     writer\&.Int64(freq);
192 
193     writer\&.String("dir");
194     writer\&.String(dir\&.c_str());
195 
196     writer\&.String("moveCounter");
197     writer\&.Double(moveCounter);
198 
199     writer\&.String("sweepCounter");
200     writer\&.Double(sweepCounter);
201 
202     if (walaDone && crossoverDone) {
203         // in final TMMC stage or just finished the TMMC (end of simulation)
204         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
205         if (refine) {
206             sys\&.refineEnergyHistogramBounds();
207         }
208         sys\&.printEnergyHistogram(dir+"/eHist", false); // Un-normalized Energy histogram
209         if (refine) {
210             sys\&.refinePkHistogramBounds();
211         }
212         sys\&.printPkHistogram(dir+"/pkHist", false); // Un-normalized Particle histogram
213         sys\&.printExtMoments(dir+"/extMom", false); // Un-normalized Extensive moments, plus counter (number of times each recorded)
214         writer\&.String("extMomCounter");
215         std::vector < double > ctr = sys\&.extMomCounter();
216         writer\&.StartArray();
217         for (std::vector < double >::iterator it = ctr\&.begin(); it < ctr\&.end(); ++it) {
218             writer\&.Double(*it);
219         }
220         writer\&.EndArray();
221     } else if (walaDone && !crossoverDone && !tmmcDone) {
222         // in crossover stage
223         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
224         sys\&.getWALABias()->print(dir+"/wala", true);
225 
226         writer\&.String("wala_lnF");
227         writer\&.Double(sys\&.getWALABias()->lnF());
228 
229         // energy upper and lower bounds for histogram
230         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
231         writer\&.String("energyHistogramLB");
232         writer\&.StartArray();
233         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
234             writer\&.Double(*it);
235         }
236         writer\&.EndArray();
237         writer\&.String("energyHistogramUB");
238         writer\&.StartArray();
239         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
240             writer\&.Double(*it);
241         }
242         writer\&.EndArray();
243     } else if (!walaDone && !crossoverDone && !tmmcDone) {
244         // in WALA stage
245         sys\&.getWALABias()->print(dir+"/wala", true);
246 
247         writer\&.String("wala_lnF");
248         writer\&.Double(sys\&.getWALABias()->lnF());
249 
250         // energy upper and lower bounds for histogram
251         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
252         writer\&.String("energyHistogramLB");
253         writer\&.StartArray();
254         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
255             writer\&.Double(*it);
256         }
257         writer\&.EndArray();
258         writer\&.String("energyHistogramUB");
259         writer\&.StartArray();
260         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
261             writer\&.Double(*it);
262         }
263         writer\&.EndArray();
264     } else {
265         throw customException ("Uncertain which stage simulation is in, so cannot checkpoint");
266     }
267     writer\&.EndObject();
268     std::ofstream outData(chkptName\&.c_str());
269     outData << s\&.GetString() << std::endl;
270 
271     sys\&.printSnapshot(dir+"/snap\&.xyz", getTimeStamp(), true); // instantaneous snapshot
272     if (takeSnaps) {
273         // this only prints M = 0 atoms (fully inserted) to create a movie
274         sys\&.printSnapshot(dir+"/movie\&.xyz", getTimeStamp(), false);
275     }
276 
277     time(&lastCheckPt_);
278 }
.fi
.SS "void checkpoint::load (\fBsimSystem\fP &sys, const booloverride)"

.PP
Read state of a system from a json file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 60 of file checkpoint\&.cpp\&.
.PP
References tmmc::calculatePI(), chkptName, crossoverDone, dir, elb, eub, fileExists(), simSystem::getTMMCBias(), simSystem::getTotalM(), simSystem::getWALABias(), hasCheckpoint, moveCounter, parseJson(), tmmc::readC(), simSystem::readConfig(), wala::readH(), tmmc::readHC(), wala::readlnPI(), resFromCross, resFromTMMC, resFromWALA, simSystem::restartEnergyHistogram(), simSystem::restartExtMoments(), simSystem::restartPkHistogram(), sendErr(), sendMsg(), simSystem::setELB(), simSystem::setEUB(), simSystem::startTMMC(), simSystem::startWALA(), sweepCounter, SYS_FAILURE, takeSnaps, tmmcDone, simSystem::tmmcSweepSize, simSystem::wala_g, wala_lnF, simSystem::wala_s, and walaDone\&.
.PP
Referenced by checkpoint()\&.
.PP
.nf
60                                                           {
61     if (!fileExists(chkptName) && !override) {
62         throw customException ("No checkpoint by the name: "+chkptName);
63     }
64 
65     rapidjson::Document doc;
66     try {
67         parseJson (chkptName, doc);
68 
69         tmmcDone = doc["tmmcDone"]\&.GetBool();
70         crossoverDone = doc["crossoverDone"]\&.GetBool();
71         walaDone = doc["walaDone"]\&.GetBool();
72         hasCheckpoint = doc["hasCheckpoint"]\&.GetBool();
73         takeSnaps = doc["takeSnaps"]\&.GetBool();
74         dir = doc["dir"]\&.GetString();
75         moveCounter = (long long int)doc["moveCounter"]\&.GetDouble();
76         sweepCounter = (long long int)doc["sweepCounter"]\&.GetDouble();
77 
78         if (walaDone && crossoverDone) {
79             // In final TMMC stage or just finished the TMMC (end of simulation)
80             resFromTMMC = true;
81             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
82             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
83             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
84             sys\&.getTMMCBias()->calculatePI();
85             std::vector < double > ctr (doc["extMomCounter"]\&.Size(), 0);
86             for (unsigned int i = 0; i < doc["extMomCounter"]\&.Size(); ++i) {
87                 ctr[i] = doc["extMomCounter"][i]\&.GetDouble();
88             }
89             sys\&.restartEnergyHistogram(dir+"/eHist");
90             sys\&.restartPkHistogram(dir+"/pkHist");
91             sys\&.restartExtMoments(dir+"/extMom", ctr);
92         } else if (walaDone && !crossoverDone && !tmmcDone) {
93             // In crossover stage
94             resFromCross = true;
95             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
96             wala_lnF = doc["wala_lnF"]\&.GetDouble();
97             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
98 
99             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
100             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
101             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
102             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
103 
104             // Energy upper and lower bounds for histogram
105             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
106             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
107                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
108             }
109             sys\&.setELB(elb);
110 
111             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
112             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
113                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
114             }
115             sys\&.setEUB(eub);
116         } else if (!walaDone && !crossoverDone && !tmmcDone) {
117             // In WALA stage
118             resFromWALA = true;
119             wala_lnF = doc["wala_lnF"]\&.GetDouble();
120             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
121 
122             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
123             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
124 
125             // Energy upper and lower bounds for histogram
126             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
127             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
128                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
129             }
130             sys\&.setELB(elb);
131 
132             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
133             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
134                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
135             }
136             sys\&.setEUB(eub);
137         } else {
138             if (!override) {
139                 sendErr("Uncertain which stage simulation is in, so cannot checkpoint");
140                 exit(SYS_FAILURE);
141             }
142         }
143 
144         sys\&.readConfig(dir+"/snap\&.xyz");
145         hasCheckpoint = true;
146     } catch (std::exception &ex) {
147         std::string msg = ex\&.what();
148         if (!override) {
149             hasCheckpoint = false;
150             sendErr("Unable to load checkpoint "+msg);
151             exit(SYS_FAILURE);
152         } else {
153             sendErr("Overriding the following errors to load checkpoint "+msg);
154         }
155     }
156 
157     sendMsg("Checkpoint loaded from "+chkptName);
158 }
.fi
.SH "Field Documentation"
.PP 
.SS "std::string checkpoint::chkptName"

.PP
Name of checkpoint file\&. 
.PP
Definition at line 43 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::crossoverDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performCrossover()\&.
.SS "std::string checkpoint::dir"

.PP
Name of the checkpoint directory containing the information to reinitialize the system (json) 
.PP
Definition at line 42 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "std::vector< double > checkpoint::elb"

.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "std::vector< double > checkpoint::eub"

.PP
Upper and lower energy bounds for energy histogram\&. 
.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "long int checkpoint::freq"

.PP
Frequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) 
.PP
Definition at line 37 of file checkpoint\&.h\&.
.PP
Referenced by check(), checkpoint(), and dump()\&.
.SS "bool checkpoint::hasCheckpoint"

.PP
At least one checkpoint has been made that the system can restart from\&. 
.PP
Definition at line 32 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "long long int checkpoint::moveCounter"

.PP
Tracks the number of moves in a given sweep that have executed\&. 
.PP
Definition at line 38 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), performTMMC(), and performWALA()\&.
.SS "bool checkpoint::resFromCross"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performCrossover()\&.
.SS "bool checkpoint::resFromTMMC"

.PP
Flags corresponding to which stage the checkpoint indicated to restart from\&. 
.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performTMMC()\&.
.SS "bool checkpoint::resFromWALA"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performWALA()\&.
.SS "long long int checkpoint::sweepCounter"

.PP
Tracks the number of sweeps that have executed\&. 
.PP
Definition at line 39 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), and performTMMC()\&.
.SS "bool checkpoint::takeSnaps"

.PP
Save snapshot of the system each time a record is made\&. 
.PP
Definition at line 33 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::tmmcDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performTMMC()\&.
.SS "double checkpoint::wala_lnF"

.PP
Current value of lnF from WALA\&. 
.PP
Definition at line 40 of file checkpoint\&.h\&.
.PP
Referenced by load()\&.
.SS "bool checkpoint::walaDone"

.PP
Progress of each stage, regardless of where the checkpoint indicated to start from\&. 
.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performWALA()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
