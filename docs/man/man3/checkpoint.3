.TH "checkpoint" 3 "Wed Dec 28 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
checkpoint \- 
.PP
Information to restart/checkpoint the simulation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <checkpoint\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcheckpoint\fP ()"
.br
.ti -1c
.RI "\fBcheckpoint\fP (const std::string directory, const long int frequency, \fBsimSystem\fP &sys, const bool snaps=false, const bool override=false)"
.br
.RI "\fIRead system state from a file\&. \fP"
.ti -1c
.RI "\fB~checkpoint\fP ()"
.br
.ti -1c
.RI "void \fBload\fP (\fBsimSystem\fP &sys, const bool override)"
.br
.RI "\fIRead state of a system from a json file\&. \fP"
.ti -1c
.RI "void \fBdump\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0)"
.br
.RI "\fISave the state of a system to a json file\&. \fP"
.ti -1c
.RI "bool \fBcheck\fP (\fBsimSystem\fP &sys, const long long int \fBmoveCounter\fP=0, const long long int \fBsweepCounter\fP=0)"
.br
.RI "\fICheck how long it has been since last checkpoint, and write new one if has exceeded frequency\&. \fP"
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBhasCheckpoint\fP"
.br
.RI "\fIAt least one checkpoint has been made that the system can restart from\&. \fP"
.ti -1c
.RI "bool \fBtakeSnaps\fP"
.br
.RI "\fISave snapshot of the system each time a record is made\&. \fP"
.ti -1c
.RI "bool \fBtmmcDone\fP"
.br
.ti -1c
.RI "bool \fBcrossoverDone\fP"
.br
.ti -1c
.RI "bool \fBwalaDone\fP"
.br
.RI "\fIProgress of each stage, regardless of where the checkpoint indicated to start from\&. \fP"
.ti -1c
.RI "bool \fBresFromWALA\fP"
.br
.ti -1c
.RI "bool \fBresFromCross\fP"
.br
.ti -1c
.RI "bool \fBresFromTMMC\fP"
.br
.RI "\fIFlags corresponding to which stage the checkpoint indicated to restart from\&. \fP"
.ti -1c
.RI "long int \fBfreq\fP"
.br
.RI "\fIFrequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) \fP"
.ti -1c
.RI "long long int \fBmoveCounter\fP"
.br
.RI "\fITracks the number of moves in a given sweep that have executed\&. \fP"
.ti -1c
.RI "long long int \fBsweepCounter\fP"
.br
.RI "\fITracks the number of sweeps that have executed\&. \fP"
.ti -1c
.RI "double \fBwala_lnF\fP"
.br
.RI "\fICurrent value of lnF from WALA\&. \fP"
.ti -1c
.RI "std::string \fBdir\fP"
.br
.RI "\fIName of the checkpoint directory containing the information to reinitialize the system (json) \fP"
.ti -1c
.RI "std::string \fBchkptName\fP"
.br
.RI "\fIName of checkpoint file\&. \fP"
.ti -1c
.RI "std::vector< double > \fBelb\fP"
.br
.ti -1c
.RI "std::vector< double > \fBeub\fP"
.br
.RI "\fIUpper and lower energy bounds for energy histogram\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Information to restart/checkpoint the simulation\&. 
.PP
Definition at line 22 of file checkpoint\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "checkpoint::checkpoint ()\fC [inline]\fP"

.PP
Definition at line 24 of file checkpoint\&.h\&.
.PP
References crossoverDone, dir, freq, hasCheckpoint, resFromCross, resFromTMMC, resFromWALA, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
24 { tmmcDone = false; crossoverDone = false; walaDone = false; hasCheckpoint = false; resFromTMMC = false; resFromWALA = false; resFromCross = false; takeSnaps = false; freq = -1; dir = "checkpt"; }
.fi
.SS "checkpoint::checkpoint (const std::stringdirectory, const long intfrequency, \fBsimSystem\fP &sys, const boolsnaps = \fCfalse\fP, const booloverride = \fCfalse\fP)"

.PP
Read system state from a file\&. If checkpoint directory is found and json file is valid, data is loaded from it\&. Note that although this stores the frequency, it does not use the value it dumps to file\&. This class always uses the frequency given when the class is instantiated\&.
.PP
\fBParameters:\fP
.RS 4
\fIdir\fP Directory where system state was saved 
.br
\fIfrequency\fP Frquency to take snapshots/checkpoints of the system (< 0 disables) 
.br
\fIsys\fP System to checkpoint 
.br
\fIsnaps\fP Take snapshots each time a record is made to make a movie? (default = false) 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 14 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, fileExists(), freq, hasCheckpoint, load(), moveCounter, resFromCross, resFromTMMC, resFromWALA, simSystem::restartFromTMMC, sweepCounter, takeSnaps, tmmcDone, and walaDone\&.
.PP
.nf
14                                                                                                                                   {
15     tmmcDone = false;
16     crossoverDone = false;
17     walaDone = false;
18     hasCheckpoint = false;
19     takeSnaps = snaps;
20     dir = directory;
21     freq = frequency;
22     moveCounter = 0;
23     sweepCounter = 0;
24     resFromWALA = false;
25     resFromCross = false;
26     resFromTMMC = false;
27 
28     chkptName = dir+"/state\&.json";
29     if (fileExists(chkptName)) {
30         // if checkpoint exists, and is a valid json file, use this information
31         FILE* fp = fopen(chkptName\&.c_str(), "r");
32         char readBuffer[65536];
33         rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer) );
34         rapidjson::Document doc;
35         doc\&.ParseStream(is);
36         fclose(fp);
37         if (doc\&.IsObject()) {
38             load(sys, override);
39         }
40     } else {
41         std::string command = "mkdir -p "+dir+" && touch "+chkptName;
42         const int succ = system(command\&.c_str());
43         if (succ != 0) {
44             throw customException("Unable to initialize checkpoint");
45         }
46 
47         // Forcible skip to TMMC stage if want to manually start TMMC
48         if (sys\&.restartFromTMMC){
49             walaDone = true;
50             crossoverDone = true;
51         }
52     }
53 
54     time(&lastCheckPt_); // take time when object was instantiated as initial time
55 }
.fi
.SS "checkpoint::~checkpoint ()\fC [inline]\fP"

.PP
Definition at line 26 of file checkpoint\&.h\&.
.PP
.nf
26 {};
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool checkpoint::check (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP)"

.PP
Check how long it has been since last checkpoint, and write new one if has exceeded frequency\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed
.RE
.PP
\fBReturns:\fP
.RS 4
bool Is a checkpoint being generated or not 
.RE
.PP

.PP
Definition at line 290 of file checkpoint\&.cpp\&.
.PP
References dump(), and freq\&.
.PP
Referenced by performCrossover(), performTMMC(), and performWALA()\&.
.PP
.nf
290                                                                                                          {
291     if (freq > 0) {
292         if (std::abs(difftime(time(&now_), lastCheckPt_)) >= freq) {
293             dump(sys, moveCounter, sweepCounter);
294             return true;
295         }
296     }
297     return false;
298 }
.fi
.SS "void checkpoint::dump (\fBsimSystem\fP &sys, const long long intmoveCounter = \fC0\fP, const long long intsweepCounter = \fC0\fP)"

.PP
Save the state of a system to a json file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fImoveCounter\fP Number of moves out of a given sweep that have executed 
.br
\fIsweepCounter\fP Number of loops/sweeps that have executed 
.RE
.PP

.PP
Definition at line 173 of file checkpoint\&.cpp\&.
.PP
References chkptName, crossoverDone, dir, elb, eub, simSystem::extMomCounter(), freq, simSystem::getELB(), simSystem::getEUB(), getTimeStamp(), simSystem::getTMMCBias(), simSystem::getWALABias(), hasCheckpoint, wala::lnF(), tmmc::print(), wala::print(), simSystem::printEnergyHistogram(), simSystem::printExtMoments(), simSystem::printPkHistogram(), simSystem::printSnapshot(), simSystem::refineEnergyHistogramBounds(), simSystem::refinePkHistogramBounds(), takeSnaps, tmmcDone, and walaDone\&.
.PP
Referenced by check()\&.
.PP
.nf
173                                                                                                         {
174     rapidjson::StringBuffer s;
175     rapidjson::PrettyWriter < rapidjson::StringBuffer > writer(s);
176     hasCheckpoint = true;
177 
178     // Write restart/checkpoint options
179     writer\&.StartObject();
180     writer\&.String("tmmcDone");
181     writer\&.Bool(tmmcDone);
182 
183     writer\&.String("crossoverDone");
184     writer\&.Bool(crossoverDone);
185 
186     writer\&.String("walaDone");
187     writer\&.Bool(walaDone);
188 
189     writer\&.String("hasCheckpoint");
190     writer\&.Bool(hasCheckpoint);
191 
192     writer\&.String("takeSnaps");
193     writer\&.Bool(takeSnaps);
194 
195     writer\&.String("freq");
196     writer\&.Int64(freq);
197 
198     writer\&.String("dir");
199     writer\&.String(dir\&.c_str());
200 
201     writer\&.String("moveCounter");
202     writer\&.Double(moveCounter);
203 
204     writer\&.String("sweepCounter");
205     writer\&.Double(sweepCounter);
206 
207     if (walaDone && crossoverDone) {
208         // in final TMMC stage or just finished the TMMC (end of simulation)
209         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
210         sys\&.refineEnergyHistogramBounds();
211         sys\&.printEnergyHistogram(dir+"/eHist", false); // Un-normalized Energy histogram
212         sys\&.refinePkHistogramBounds();
213         sys\&.printPkHistogram(dir+"/pkHist", false); // Un-normalized Particle histogram
214         sys\&.printExtMoments(dir+"/extMom", false); // Un-normalized Extensive moments, plus counter (number of times each recorded)
215         writer\&.String("extMomCounter");
216         std::vector < double > ctr = sys\&.extMomCounter();
217         writer\&.StartArray();
218         for (std::vector < double >::iterator it = ctr\&.begin(); it < ctr\&.end(); ++it) {
219             writer\&.Double(*it);
220         }
221         writer\&.EndArray();
222     } else if (walaDone && !crossoverDone && !tmmcDone) {
223         // in crossover stage
224         sys\&.getTMMCBias()->print(dir+"/tmmc", true, true);
225         sys\&.getWALABias()->print(dir+"/wala", true);
226 
227         writer\&.String("wala_lnF");
228         writer\&.Double(sys\&.getWALABias()->lnF());
229 
230         // energy upper and lower bounds for histogram
231         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
232         writer\&.String("energyHistogramLB");
233         writer\&.StartArray();
234         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
235             writer\&.Double(*it);
236         }
237         writer\&.EndArray();
238         writer\&.String("energyHistogramUB");
239         writer\&.StartArray();
240         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
241             writer\&.Double(*it);
242         }
243         writer\&.EndArray();
244     } else if (!walaDone && !crossoverDone && !tmmcDone) {
245         // in WALA stage
246         sys\&.getWALABias()->print(dir+"/wala", true);
247 
248         writer\&.String("wala_lnF");
249         writer\&.Double(sys\&.getWALABias()->lnF());
250 
251         // energy upper and lower bounds for histogram
252         std::vector < double > elb = sys\&.getELB(), eub = sys\&.getEUB();
253         writer\&.String("energyHistogramLB");
254         writer\&.StartArray();
255         for (std::vector < double >::iterator it = elb\&.begin(); it < elb\&.end(); ++it) {
256             writer\&.Double(*it);
257         }
258         writer\&.EndArray();
259         writer\&.String("energyHistogramUB");
260         writer\&.StartArray();
261         for (std::vector < double >::iterator it = eub\&.begin(); it < eub\&.end(); ++it) {
262             writer\&.Double(*it);
263         }
264         writer\&.EndArray();
265     } else {
266         throw customException ("Uncertain which stage simulation is in, so cannot checkpoint");
267     }
268     writer\&.EndObject();
269     std::ofstream outData(chkptName\&.c_str());
270     outData << s\&.GetString() << std::endl;
271 
272     sys\&.printSnapshot(dir+"/snap\&.xyz", getTimeStamp(), true); // instantaneous snapshot
273     if (takeSnaps) {
274         // this only prints M = 0 atoms (fully inserted) to create a movie
275         sys\&.printSnapshot(dir+"/movie\&.xyz", getTimeStamp(), false);
276     }
277 
278     time(&lastCheckPt_);
279 }
.fi
.SS "void checkpoint::load (\fBsimSystem\fP &sys, const booloverride)"

.PP
Read state of a system from a json file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsys\fP System to checkpoint 
.br
\fIoverride\fP Manually override exceptions, use with extreme caution (default=false) 
.RE
.PP

.PP
Definition at line 63 of file checkpoint\&.cpp\&.
.PP
References tmmc::calculatePI(), chkptName, crossoverDone, dir, elb, eub, fileExists(), getTimeStamp(), simSystem::getTMMCBias(), simSystem::getTotalM(), simSystem::getWALABias(), hasCheckpoint, moveCounter, tmmc::readC(), simSystem::readConfig(), wala::readH(), tmmc::readHC(), wala::readlnPI(), resFromCross, resFromTMMC, resFromWALA, simSystem::restartEnergyHistogram(), simSystem::restartExtMoments(), simSystem::restartPkHistogram(), simSystem::setELB(), simSystem::setEUB(), simSystem::startTMMC(), simSystem::startWALA(), sweepCounter, SYS_FAILURE, takeSnaps, tmmcDone, simSystem::tmmcSweepSize, simSystem::wala_g, wala_lnF, simSystem::wala_s, and walaDone\&.
.PP
Referenced by checkpoint()\&.
.PP
.nf
63                                                           {
64     if (!fileExists(chkptName) && !override) {
65         throw customException ("No checkpoint by the name: "+chkptName);
66     }
67 
68     rapidjson::Document doc;
69     try {
70         FILE* fp = fopen(chkptName\&.c_str(), "r");
71         char readBuffer[65536];
72         rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer) );
73         doc\&.ParseStream(is);
74         fclose(fp);
75 
76         tmmcDone = doc["tmmcDone"]\&.GetBool();
77         crossoverDone = doc["crossoverDone"]\&.GetBool();
78         walaDone = doc["walaDone"]\&.GetBool();
79         hasCheckpoint = doc["hasCheckpoint"]\&.GetBool();
80         takeSnaps = doc["takeSnaps"]\&.GetBool();
81         dir = doc["dir"]\&.GetString();
82         moveCounter = (long long int)doc["moveCounter"]\&.GetDouble();
83         sweepCounter = (long long int)doc["sweepCounter"]\&.GetDouble();
84 
85         if (walaDone && crossoverDone) {
86             // in final TMMC stage or just finished the TMMC (end of simulation)
87             resFromTMMC = true;
88             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
89             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
90             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
91             sys\&.getTMMCBias()->calculatePI();
92             std::vector < double > ctr (doc["extMomCounter"]\&.Size(), 0);
93             for (unsigned int i = 0; i < doc["extMomCounter"]\&.Size(); ++i) {
94                 ctr[i] = doc["extMomCounter"][i]\&.GetDouble();
95             }
96             sys\&.restartEnergyHistogram(dir+"/eHist");
97             sys\&.restartPkHistogram(dir+"/pkHist");
98             sys\&.restartExtMoments(dir+"/extMom", ctr);
99         } else if (walaDone && !crossoverDone && !tmmcDone) {
100             // in crossover stage
101             resFromCross = true;
102             sys\&.startTMMC(sys\&.tmmcSweepSize, sys\&.getTotalM());
103             wala_lnF = doc["wala_lnF"]\&.GetDouble();
104             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
105 
106             sys\&.getTMMCBias()->readC(dir+"/tmmc_C\&.dat");
107             sys\&.getTMMCBias()->readHC(dir+"/tmmc_HC\&.dat");
108             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
109             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
110 
111             // energy upper and lower bounds for histogram
112             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
113             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
114                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
115             }
116             sys\&.setELB(elb);
117 
118             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
119             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
120                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
121             }
122             sys\&.setEUB(eub);
123         } else if (!walaDone && !crossoverDone && !tmmcDone) {
124             // in WALA stage
125             resFromWALA = true;
126             wala_lnF = doc["wala_lnF"]\&.GetDouble();
127             sys\&.startWALA (wala_lnF, sys\&.wala_g, sys\&.wala_s, sys\&.getTotalM());
128 
129             sys\&.getWALABias()->readlnPI(dir+"/wala_lnPI\&.dat");
130             sys\&.getWALABias()->readH(dir+"/wala_H\&.dat");
131 
132             // energy upper and lower bounds for histogram
133             elb\&.resize(doc["energyHistogramLB"]\&.Size(), 0);
134             for (unsigned int i = 0; i < doc["energyHistogramLB"]\&.Size(); ++i) {
135                 elb[i] = doc["energyHistogramLB"][i]\&.GetDouble();
136             }
137             sys\&.setELB(elb);
138 
139             eub\&.resize(doc["energyHistogramUB"]\&.Size(), 0);
140             for (unsigned int i = 0; i < doc["energyHistogramUB"]\&.Size(); ++i) {
141                 eub[i] = doc["energyHistogramUB"][i]\&.GetDouble();
142             }
143             sys\&.setEUB(eub);
144         } else {
145             if (!override) {
146                 std::cerr << "Uncertain which stage simulation is in, so cannot checkpoint" << std::endl;
147                 exit(SYS_FAILURE);
148             }
149         }
150 
151         sys\&.readConfig(dir+"/snap\&.xyz");
152         hasCheckpoint = true;
153     } catch (std::exception &ex) {
154         if (!override) {
155             hasCheckpoint = false;
156             std::cerr << "Unable to load checkpoint: " << ex\&.what() << std::endl;
157             exit(SYS_FAILURE);
158         } else {
159             std::cerr << "Overriding the following errors to load checkpoint: " << ex\&.what() << std::endl;
160         }
161     }
162 
163     std::cout << "Checkpoint loaded from " << chkptName << " on " << getTimeStamp() << std::endl;
164 }
.fi
.SH "Field Documentation"
.PP 
.SS "std::string checkpoint::chkptName"

.PP
Name of checkpoint file\&. 
.PP
Definition at line 43 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::crossoverDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performCrossover()\&.
.SS "std::string checkpoint::dir"

.PP
Name of the checkpoint directory containing the information to reinitialize the system (json) 
.PP
Definition at line 42 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "std::vector< double > checkpoint::elb"

.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "std::vector< double > checkpoint::eub"

.PP
Upper and lower energy bounds for energy histogram\&. 
.PP
Definition at line 45 of file checkpoint\&.h\&.
.PP
Referenced by dump(), and load()\&.
.SS "long int checkpoint::freq"

.PP
Frequency (in seconds) that the system should print a new instantaneous snapshot of itself, does not load from checkpoints but is assigned when instantiated (is dumped though) 
.PP
Definition at line 37 of file checkpoint\&.h\&.
.PP
Referenced by check(), checkpoint(), and dump()\&.
.SS "bool checkpoint::hasCheckpoint"

.PP
At least one checkpoint has been made that the system can restart from\&. 
.PP
Definition at line 32 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "long long int checkpoint::moveCounter"

.PP
Tracks the number of moves in a given sweep that have executed\&. 
.PP
Definition at line 38 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), performTMMC(), and performWALA()\&.
.SS "bool checkpoint::resFromCross"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performCrossover()\&.
.SS "bool checkpoint::resFromTMMC"

.PP
Flags corresponding to which stage the checkpoint indicated to restart from\&. 
.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performTMMC()\&.
.SS "bool checkpoint::resFromWALA"

.PP
Definition at line 35 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), and performWALA()\&.
.SS "long long int checkpoint::sweepCounter"

.PP
Tracks the number of sweeps that have executed\&. 
.PP
Definition at line 39 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), load(), performCrossover(), and performTMMC()\&.
.SS "bool checkpoint::takeSnaps"

.PP
Save snapshot of the system each time a record is made\&. 
.PP
Definition at line 33 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), and load()\&.
.SS "bool checkpoint::tmmcDone"

.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performTMMC()\&.
.SS "double checkpoint::wala_lnF"

.PP
Current value of lnF from WALA\&. 
.PP
Definition at line 40 of file checkpoint\&.h\&.
.PP
Referenced by load()\&.
.SS "bool checkpoint::walaDone"

.PP
Progress of each stage, regardless of where the checkpoint indicated to start from\&. 
.PP
Definition at line 34 of file checkpoint\&.h\&.
.PP
Referenced by checkpoint(), dump(), load(), and performWALA()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
