.TH "simSystem" 3 "Wed Jan 4 2017" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
simSystem \- 
.PP
System information for the simulation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <system\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBsimSystem\fP ()"
.br
.ti -1c
.RI "\fBsimSystem\fP (const unsigned int \fBnSpecies\fP, const double \fBbeta\fP, const std::vector< double > \fBbox\fP, const std::vector< double > \fBmu\fP, const std::vector< int > \fBmaxSpecies\fP, const std::vector< int > \fBminSpecies\fP, const int Mtot, const double energyHistDelta=10\&.0, const int max_order=2)"
.br
.RI "\fIInitialize the system\&. \fP"
.ti -1c
.RI "\fB~simSystem\fP ()"
.br
.ti -1c
.RI "bool \fBaddKECorrection\fP ()"
.br
.ti -1c
.RI "void \fBtoggleKE\fP ()"
.br
.RI "\fIToggle KE adjustment to energy setting\&. \fP"
.ti -1c
.RI "void \fBincrementEnergy\fP (const double dU)"
.br
.RI "\fIIncrement the system's energy\&. \fP"
.ti -1c
.RI "void \fBaddPotential\fP (const int spec1, const int spec2, const std::string ppot_name, const std::vector< double > &params, const bool useCellList=false, const std::string tabFile='')"
.br
.RI "\fIAdd a pair potential to the system which governs the pair (spec1, spec2)\&. \fP"
.ti -1c
.RI "void \fBprintSnapshot\fP (std::string filename, std::string comment, bool overwrite=true)"
.br
.RI "\fIPrint an XYZ file of the instantaneous system configuration\&. \fP"
.ti -1c
.RI "void \fBinsertAtom\fP (const int typeIndex, \fBatom\fP *newAtom, bool override=false)"
.br
.RI "\fIInsert an atom into the system\&. \fP"
.ti -1c
.RI "void \fBdeleteAtom\fP (const int typeIndex, const int atomIndex, bool override=false)"
.br
.RI "\fIDelete an atom from the system\&. \fP"
.ti -1c
.RI "void \fBtranslateAtom\fP (const int typeIndex, const int atomIndex, std::vector< double > oldPos)"
.br
.RI "\fITranslate an atom in the system\&. \fP"
.ti -1c
.RI "void \fBreadConfig\fP (std::string filename)"
.br
.RI "\fIRead an XYZ file as the system's initial configuration\&. \fP"
.ti -1c
.RI "void \fBsetEUB\fP (const std::vector< double > eub)"
.br
.RI "\fIAssign energy upper bound from restart\&. \fP"
.ti -1c
.RI "void \fBsetELB\fP (const std::vector< double > elb)"
.br
.RI "\fIAssign energy lower bound from restart\&. \fP"
.ti -1c
.RI "void \fBcheckEnergyHistogramBounds\fP ()"
.br
.RI "\fIMonitor the energy histogram bounds at each Ntot\&. \fP"
.ti -1c
.RI "void \fBrefineEnergyHistogramBounds\fP ()"
.br
.RI "\fICheck the histogram entries and trim off zero-valued entries and bounds\&. \fP"
.ti -1c
.RI "void \fBrecordEnergyHistogram\fP ()"
.br
.RI "\fIRecord the energy histogram for the system at a given Ntot\&. \fP"
.ti -1c
.RI "void \fBreInitializeEnergyHistogram\fP ()"
.br
.RI "\fIRe-initialize the energy histogram with internal estimates of bounds\&. \fP"
.ti -1c
.RI "void \fBprintEnergyHistogram\fP (const std::string fileName, const bool normalize=true)"
.br
.RI "\fIPrint the (normalized by default) energy histogram for each Ntot\&. \fP"
.ti -1c
.RI "void \fBrestartEnergyHistogram\fP (const std::string prefix)"
.br
.RI "\fIRestart the energy histogram for each Ntot from unnormalized checkpoint\&. \fP"
.ti -1c
.RI "void \fBrefinePkHistogramBounds\fP ()"
.br
.RI "\fICheck the histogram entries and trim off zero-valued entries and bounds\&. \fP"
.ti -1c
.RI "void \fBrecordPkHistogram\fP ()"
.br
.RI "\fIRecord the particle number histogram for the system at a given Ntot\&. \fP"
.ti -1c
.RI "void \fBprintPkHistogram\fP (const std::string fileName, const bool normalize=true)"
.br
.RI "\fIPrint the (normalized by default) particle number histogram for each Ntot\&. \fP"
.ti -1c
.RI "void \fBrestartPkHistogram\fP (const std::string prefix)"
.br
.RI "\fIRestart the particle histogram for each Ntot from unnormalized checkpoint\&. \fP"
.ti -1c
.RI "void \fBrecordExtMoments\fP ()"
.br
.RI "\fIRecord the extensive moment at a given Ntot\&. \fP"
.ti -1c
.RI "void \fBprintExtMoments\fP (const std::string fileName, const bool normalize=true)"
.br
.RI "\fIPrint the (normalized by default) extensive energy histogram for each Ntot\&. \fP"
.ti -1c
.RI "void \fBrestartExtMoments\fP (const std::string prefix, const std::vector< double > &ctr)"
.br
.RI "\fIRestart the extensive energy histogram for each Ntot from unnormalized checkpoint\&. \fP"
.ti -1c
.RI "void \fBstartWALA\fP (const double lnF, const double g, const double s, const int Mtot)"
.br
.RI "\fIStart using Wang-Landau and instantiate the bias object\&. \fP"
.ti -1c
.RI "void \fBstopWALA\fP ()"
.br
.RI "\fIStop using Wang-Landau and free the bias object\&. \fP"
.ti -1c
.RI "void \fBstartTMMC\fP (const long long int \fBtmmcSweepSize\fP, const int Mtot)"
.br
.RI "\fIStart using TMMC and instantiate the bias object\&. \fP"
.ti -1c
.RI "void \fBstopTMMC\fP ()"
.br
.RI "\fIStop using TMMC and free the bias object\&. \fP"
.ti -1c
.RI "void \fBsetTotNBounds\fP (const std::vector< int > &bounds)"
.br
.RI "\fISet the bounds on the total number of particles in a system\&. \fP"
.ti -1c
.RI "void \fBincrementMState\fP ()"
.br
.RI "\fIIncrease the expanded ensemble state of the system by 1\&. \fP"
.ti -1c
.RI "void \fBdecrementMState\fP ()"
.br
.RI "\fIDecrease the expanded ensemble state of the system by 1\&. \fP"
.ti -1c
.RI "bool \fBpotentialIsSet\fP (const int spec1, const int spec2)"
.br
.RI "\fIBoolean which returns whether or not a pair has had its potential specified by the user yet\&. \fP"
.ti -1c
.RI "const int \fBnSpecies\fP ()"
.br
.RI "\fIReturn the number of different species in the system\&. \fP"
.ti -1c
.RI "const int \fBmaxSpecies\fP (const int index)"
.br
.RI "\fIReturns the absolute maximum number of a given species type allowed in the system\&. \fP"
.ti -1c
.RI "const int \fBminSpecies\fP (const int index)"
.br
.RI "\fIReturns the absolute minimum number of a given species type allowed in the system\&. \fP"
.ti -1c
.RI "const int \fBtotNMax\fP ()"
.br
.RI "\fIReturn upper bound on the total number of atoms in the system\&. \fP"
.ti -1c
.RI "const int \fBtotNMin\fP ()"
.br
.RI "\fIReturn lower bound on the total number of atoms in the system\&. \fP"
.ti -1c
.RI "const int \fBgetTotN\fP ()"
.br
.RI "\fIReturn a sum of the total number of atoms currently in the system\&. \fP"
.ti -1c
.RI "const int \fBgetMaxOrder\fP ()"
.br
.RI "\fIReturn the max order the extensive moments are being stored out to\&. \fP"
.ti -1c
.RI "const int \fBgetCurrentM\fP ()"
.br
.RI "\fIReturn the system's current expanded ensemble fractional state\&. \fP"
.ti -1c
.RI "const int \fBgetTotalM\fP ()"
.br
.RI "\fIReturn the total number of fractional states available to species in the expanded ensemble\&. \fP"
.ti -1c
.RI "const int \fBgetFractionalAtomType\fP ()"
.br
.RI "\fIReturn the atom type of the fractional atom\&. \fP"
.ti -1c
.RI "const double \fBenergy\fP ()"
.br
.RI "\fIReturn the system's instantaneous energy\&. \fP"
.ti -1c
.RI "const double \fBscratchEnergy\fP ()"
.br
.RI "\fIRecalculate the energy of the system from scratch\&. \fP"
.ti -1c
.RI "const double \fBbeta\fP ()"
.br
.RI "\fIReturn 1/kT\&. \fP"
.ti -1c
.RI "const double \fBmu\fP (const int index)"
.br
.RI "\fIReturn the chemical potential for a given species' index\&. \fP"
.ti -1c
.RI "const double \fBmass\fP (const int index)"
.br
.RI "\fIReturn the mass of a given species' index\&. \fP"
.ti -1c
.RI "const std::vector< double > \fBextMomCounter\fP ()"
.br
.RI "\fIGet counter for extensive moments needed for restarting system from a checkpoint\&. \fP"
.ti -1c
.RI "const std::vector< double > \fBbox\fP ()"
.br
.RI "\fIReturn the system box dimensions\&. \fP"
.ti -1c
.RI "std::vector< double > \fBgetELB\fP ()"
.br
.RI "\fIReturns current tally of energy min at each Ntot for checkpointing\&. \fP"
.ti -1c
.RI "std::vector< double > \fBgetEUB\fP ()"
.br
.RI "\fIReturns current tally of energy max at each Ntot for checkpointing\&. \fP"
.ti -1c
.RI "std::vector< \fBatom\fP * > \fBgetNeighborAtoms\fP (const unsigned int typeIndexA, const unsigned int typeIndexB, \fBatom\fP *_atom)"
.br
.RI "\fIReturn the list of neighbors of type A, around a particle of type B which is passed\&. \fP"
.ti -1c
.RI "\fBtmmc\fP * \fBgetTMMCBias\fP ()"
.br
.RI "\fIReturn pointer to the TMMC bias\&. \fP"
.ti -1c
.RI "\fBwala\fP * \fBgetWALABias\fP ()"
.br
.RI "\fIReturn pointer to the Wang-Landau bias\&. \fP"
.ti -1c
.RI "\fBatom\fP * \fBgetFractionalAtom\fP ()"
.br
.RI "\fIReturns a pointer the atom in the system that is currently only fractionally inserted/deleted\&. \fP"
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBuseTMMC\fP"
.br
.RI "\fILogical stating whether or not to use TMMC biasing\&. \fP"
.ti -1c
.RI "bool \fBuseWALA\fP"
.br
.RI "\fILogical stating whether or not to use Wang-Landau biasing\&. \fP"
.ti -1c
.RI "bool \fBrestartFromWALA\fP"
.br
.ti -1c
.RI "bool \fBrestartFromTMMC\fP"
.br
.RI "\fIFlags to restart from WALA or TMMC initially\&. \fP"
.ti -1c
.RI "long long int \fBtmmcSweepSize\fP"
.br
.RI "\fISize of a sweep in TMMC\&. \fP"
.ti -1c
.RI "long long int \fBtotalTMMCSweeps\fP"
.br
.RI "\fITotal number of sweeps to perform during TMMC\&. \fP"
.ti -1c
.RI "long long int \fBwlSweepSize\fP"
.br
.RI "\fISize of Wang-Landau sweep\&. \fP"
.ti -1c
.RI "long long int \fBnCrossoverVisits\fP"
.br
.RI "\fINumber of crossovers that must occur before switching from WALA to TMMC\&. \fP"
.ti -1c
.RI "double \fBlnF_start\fP"
.br
.ti -1c
.RI "double \fBlnF_end\fP"
.br
.RI "\fIStarting and ending lnF for Wang-Landau\&. \fP"
.ti -1c
.RI "double \fBwala_g\fP"
.br
.ti -1c
.RI "double \fBwala_s\fP"
.br
.RI "\fIWang-Landau g and s factors\&. \fP"
.ti -1c
.RI "double \fBgcmcEqSteps\fP"
.br
.RI "\fIIn the case of unbiased GCMC, number of equilibration steps to perform\&. \fP"
.ti -1c
.RI "double \fBgcmcPrSteps\fP"
.br
.RI "\fIIn the case of unbiased GCMC, number of production steps to perform\&. \fP"
.ti -1c
.RI "double \fBgcmcSnapFreq\fP"
.br
.RI "\fIIn the case of unbiased GCMC, frequency with which to take snapshots of the system\&. \fP"
.ti -1c
.RI "double \fBgcmcThermoFreq\fP"
.br
.RI "\fIIn the case of unbiased GCMC, frequency with which to record thermo properties\&. \fP"
.ti -1c
.RI "long double \fBwalaTotalStepCounter\fP"
.br
.RI "\fITracks the total MC steps taken during WALA stage\&. \fP"
.ti -1c
.RI "long double \fBcrossoverTotalStepCounter\fP"
.br
.RI "\fITracks the total MC steps taken during crossover stage\&. \fP"
.ti -1c
.RI "long double \fBtmmcTotalStepCounter\fP"
.br
.RI "\fITracks the total MC steps taken during TMMC stage\&. \fP"
.ti -1c
.RI "\fBtmmc\fP * \fBtmmcBias\fP"
.br
.RI "\fITMMC biasing function\&. \fP"
.ti -1c
.RI "\fBwala\fP * \fBwlBias\fP"
.br
.RI "\fIWALA biasing function\&. \fP"
.ti -1c
.RI "std::string \fBrestartFromWALAFile\fP"
.br
.ti -1c
.RI "std::string \fBrestartFromTMMCFile\fP"
.br
.RI "\fIFiles to restart from WALA or TMMC initially\&. \fP"
.ti -1c
.RI "std::vector< int > \fBnumSpecies\fP"
.br
.RI "\fITotal number of each type of atom the system contains\&. \fP"
.ti -1c
.RI "std::vector< std::vector< \fBatom\fP > > \fBatoms\fP"
.br
.RI "\fIAtoms in a matrix by type, and particle index, respectively that a system CAN hold but not all are actually 'in' the system\&. \fP"
.ti -1c
.RI "std::vector< std::vector
.br
< std::shared_ptr
.br
< \fBpairPotential\fP > > > \fBppot\fP"
.br
.RI "\fIMatrix of pair potentials for atom types i, j\&. \fP"
.ti -1c
.RI "std::vector< \fBcompositeBarrier\fP > \fBspeciesBarriers\fP"
.br
.RI "\fIBarriers, if any, for each species\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
System information for the simulation\&. 
.PP
Definition at line 26 of file system\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "simSystem::simSystem ()\fC [inline]\fP"

.PP
Definition at line 28 of file system\&.h\&.
.PP
.nf
28 {;}
.fi
.SS "simSystem::simSystem (const unsigned intnSpecies, const doublebeta, const std::vector< double >box, const std::vector< double >mu, const std::vector< int >maxSpecies, const std::vector< int >minSpecies, const intMtot, const doubleenergyHistDelta = \fC10\&.0\fP, const intmax_order = \fC2\fP)"

.PP
Initialize the system\&. Sets the use of both WL and TMMC biasing to false\&.
.PP
\fBParameters:\fP
.RS 4
\fInSpecies\fP Number of unqiue species types to allow in the system 
.br
\fIbeta\fP Inverse temperature (1/kT) 
.br
\fIbox\fP Box dimensions [x, y, z] 
.br
\fImu\fP Chemical potential of each species 
.br
\fImaxSpecies\fP Maximum number of each species to allow in the system 
.br
\fIMtot\fP Total number of expanded ensemble states 
.br
\fIenergyHistDelta\fP Bin width of energy histogram at each Ntot (optional, default = 10\&.0) 
.br
\fImax_order\fP Maximum order to record correlations to (default = 2) 
.RE
.PP

.PP
Definition at line 431 of file system\&.cpp\&.
.PP
References atoms, beta(), box(), crossoverTotalStepCounter, lnF_end, lnF_start, maxSpecies(), minSpecies(), mu(), nCrossoverVisits, nSpecies(), numSpecies, ppot, restartFromTMMC, restartFromTMMCFile, restartFromWALA, restartFromWALAFile, speciesBarriers, SYS_FAILURE, tmmcTotalStepCounter, totalTMMCSweeps, useTMMC, useWALA, wala_g, wala_s, walaTotalStepCounter, and wlSweepSize\&.
.PP
.nf
431                                                                                                                                                                                                                                                                               {
432     if ((box\&.size() != 3) || (nSpecies != mu\&.size()) || (maxSpecies\&.size() != nSpecies)) {
433         throw customException ("Invalid system initialization parameters");
434         exit(SYS_FAILURE);
435     } else {
436         nSpecies_ = nSpecies;
437         maxSpecies_ = maxSpecies;
438         minSpecies_ = minSpecies;
439         box_ = box;
440         mu_ = mu;
441         beta_ = beta;
442     }
443 
444     lnF_start = 1\&.0; // default for lnF_start
445     lnF_end = 2\&.0e-18; // default for lnF_end
446     toggleKE_ = false; //default, do NOT adjust energy by kinetic contribution of 3/2kT per atom (just record PE)
447     totalTMMCSweeps = 0;
448     wlSweepSize = 0;
449     wala_g = 0\&.5;
450     wala_s = 0\&.8;
451     nCrossoverVisits = 5;
452     walaTotalStepCounter = 0;
453     crossoverTotalStepCounter = 0;
454     tmmcTotalStepCounter = 0;
455 
456     if (max_order < 1){
457         throw customException ("max_order must be >= 1");
458     }
459     max_order_ = max_order;
460 
461     if (energyHistDelta <= 0) {
462         throw customException ("energyHistDelta must be > 0");
463     }
464     energyHistDelta_ = energyHistDelta;
465 
466     for (unsigned int i = 0; i < 3; ++i) {
467         if (box_[i] <= 0) {
468             throw customException ("Box dimensions must be > 0");
469         }
470     }
471 
472     if (Mtot < 1) {
473         throw customException ("Total fractional states for expanded ensemble must be >= 1");
474     }
475     Mtot_ = Mtot;
476     Mcurrent_ = 0; // always start from fully inserted state
477 
478     try {
479         ppot\&.resize(nSpecies);
480     } catch (std::exception &e) {
481         throw customException (e\&.what());
482     }
483     for (unsigned int i = 0; i < nSpecies; ++i) {
484         try {
485             ppot[i]\&.resize(nSpecies);
486         } catch (std::exception &e) {
487             throw customException (e\&.what());
488         }
489     }
490 
491     try {
492         mass_\&.resize(nSpecies, 1\&.0);
493     } catch (std::exception &e) {
494         throw customException (e\&.what());
495     }
496 
497     try {
498         ppotSet_\&.resize(nSpecies);
499     } catch (std::exception &e) {
500         throw customException (e\&.what());
501     }
502     for (unsigned int i = 0; i < nSpecies; ++i) {
503         try {
504             ppotSet_[i]\&.resize(nSpecies, false);
505         } catch (std::exception &e) {
506             throw customException (e\&.what());
507         }
508     }
509 
510     // Wall potentials for each species, if there are any?
511     try {
512         speciesBarriers\&.resize(nSpecies);
513     } catch (std::exception &e) {
514         throw customException (e\&.what());
515     }
516 
517     // Prepare vectors and matrices for cell lists\&.
518     // It is crucial to reserve the correct number of cellLists in advance
519     // since cellListsByPairType uses the addresses of cellLists\&. Otherwise,
520     // if dynamic memory reallocation takes place, the pointers do not
521     // correspond to initial values anymore, causing the simulation to crash\&.
522     cellLists_\&.reserve(nSpecies_*nSpecies_);
523 
524     try {
525         useCellList_\&.resize(nSpecies);
526         cellListsByPairType_\&.resize(nSpecies);
527     } catch (std::exception &e) {
528         throw customException (e\&.what());
529     }
530     for (unsigned int i = 0; i < nSpecies; ++i) {
531         try {
532             useCellList_[i]\&.resize(nSpecies);
533             cellListsByPairType_[i]\&.assign(nSpecies, NULL);
534         } catch (std::exception &e) {
535             throw customException (e\&.what());
536         }
537     }
538 
539     totN_ = 0;
540         try {
541         numSpecies\&.resize(nSpecies, 0);
542     } catch (std::exception &e) {
543         throw customException (e\&.what());
544     }
545 
546     try {
547         atoms\&.resize(nSpecies);
548     } catch (std::exception &e) {
549         throw customException (e\&.what());
550     }
551     for (unsigned int i = 0; i < nSpecies; ++i) {
552         if (minSpecies_[i] < 0) {
553             throw customException ("Min species < 0");
554         }
555         if (maxSpecies_[i] < minSpecies_[i]) {
556             throw customException ("Max species < Min species");
557         }
558         try {
559             atoms[i]\&.resize(maxSpecies_[i], atom());
560         } catch (std::exception &e) {
561             throw customException (e\&.what());
562         }
563     }
564 
565     energy_ = 0\&.0;
566 
567     useTMMC = false;
568     useWALA = false;
569 
570     totNBounds_\&.resize(2, 0);
571     for (unsigned int i = 0; i < nSpecies_; ++i) {
572         totNBounds_[0] += minSpecies_[i];
573         totNBounds_[1] += maxSpecies_[i];
574     }
575 
576     // allocate space for average U storage matrix - Shen and Errington method implies this size is always the same for
577     // both single and multicomponent mixtures
578     long long int size = totNBounds_[1] - totNBounds_[0] + 1;
579     energyHistogram_lb_\&.resize(size, -5\&.0);
580     energyHistogram_ub_\&.resize(size, 5\&.0);
581     for (unsigned int i = 0; i < size; ++i) {
582         energyHistogram_lb_[i] = -5\&.0;
583         energyHistogram_ub_[i] = 5\&.0;
584         try {
585             dynamic_one_dim_histogram dummyHist (energyHistogram_lb_[i], energyHistogram_ub_[i], energyHistDelta_);
586             energyHistogram_\&.resize(i+1, dummyHist);
587         } catch (std::bad_alloc &ba) {
588             throw customException ("Out of memory for energy histogram for each Ntot");
589         }
590     }
591     pkHistogram_\&.resize(0);
592     dynamic_one_dim_histogram dummyPkHist (0\&.0, totNBounds_[1], 1\&.0);
593     try {
594         std::vector < dynamic_one_dim_histogram > tmp (totNBounds_[1]-totNBounds_[0]+1, dummyPkHist);
595         pkHistogram_\&.resize(nSpecies_, tmp);
596     } catch (std::bad_alloc &ba) {
597         throw customException ("Out of memory for particle histogram for each Ntot");
598     }
599 
600     // initialize moments
601     std::vector < double > lbn (6,0), ubn(6,0);
602     std::vector < long long unsigned int > nbn (6,0);
603     ubn[0] = nSpecies_-1;
604     ubn[1] = max_order_;
605     ubn[2] = nSpecies_-1;
606     ubn[3] = max_order_;
607     ubn[4] = max_order_;
608     ubn[5] = totNBounds_[1]-totNBounds_[0];
609 
610     nbn[0] = nSpecies_;
611     nbn[1] = max_order_+1;
612     nbn[2] = nSpecies_;
613     nbn[3] = max_order_+1;
614     nbn[4] = max_order_+1;
615     nbn[5] = size;
616 
617     histogram hnn (lbn, ubn, nbn);
618     extensive_moments_ = hnn;
619 
620     restartFromWALA = false;
621     restartFromTMMC = false;
622     restartFromWALAFile = "";
623     restartFromTMMCFile = "";
624 }
.fi
.SS "simSystem::~simSystem ()"

.PP
Definition at line 410 of file system\&.cpp\&.
.PP
References tmmcBias, useTMMC, useWALA, and wlBias\&.
.PP
.nf
410                        {
411     if (useTMMC) {
412         delete tmmcBias;
413     }
414     if (useWALA) {
415         delete wlBias;
416     }
417 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool simSystem::addKECorrection ()\fC [inline]\fP"

.PP
Definition at line 32 of file system\&.h\&.
.PP
Referenced by initialize(), deleteParticle::make(), insertParticle::make(), and setConfig()\&.
.PP
.nf
32 { return toggleKE_; }
.fi
.SS "void simSystem::addPotential (const intspec1, const intspec2, const std::stringppot_name, const std::vector< double > &params, const booluseCellList = \fCfalse\fP, const std::stringtabFile = \fC''\fP)"

.PP
Add a pair potential to the system which governs the pair (spec1, spec2)\&. However, it only stores the pointer so the object must be fixed in memory somewhere else throughout the simulation\&.
.PP
\fBParameters:\fP
.RS 4
\fIspec1\fP Species index 1 (>= 0) 
.br
\fIspec2\fP Species index 2 (>= 0) 
.br
\fIppot_name\fP Name of pair potential 
.br
\fIparams\fP Vector of parameters which define pair potential 
.br
\fIbool\fP Optional argument of whether or not to build and maintain a cell list for this pair (spec1, spec2) (default=false) 
.br
\fItabFile\fP Optional argument use for tabulated potentials, this is the file to load from (default='') 
.RE
.PP

.PP
Definition at line 1226 of file system\&.cpp\&.
.PP
References numToStr(), ppot, sendErr(), and sendMsg()\&.
.PP
Referenced by setPairPotentials()\&.
.PP
.nf
1226                                                                                                                                                                               {
1227     if (spec1 >= nSpecies_ || spec1 < 0) {
1228         throw customException ("Trying to define pair potential for species (1) that does not exist yet/is invalid");
1229     }
1230     if (spec2 >= nSpecies_ || spec2 < 0) {
1231         throw customException ("Trying to define pair potential for species (2) that does not exist yet/is invalid");
1232     }
1233 
1234     if (ppot_name == "square_well") {
1235         try {
1236             auto pp1 = std::make_shared < squareWell > ();
1237             pp1->setParameters(params);
1238             ppot[spec1][spec2] = pp1;
1239             auto pp2 = std::make_shared < squareWell > ();
1240             pp2->setParameters(params);
1241             ppot[spec2][spec1] = pp2;
1242         } catch (std::exception &ex) {
1243             throw customException(ex\&.what());
1244         }
1245     } else if (ppot_name == "lennard_jones") {
1246         try {
1247             auto pp1 = std::make_shared < lennardJones > ();
1248             pp1->setParameters(params);
1249             ppot[spec1][spec2] = pp1;
1250             auto pp2 = std::make_shared < lennardJones > ();
1251             pp2->setParameters(params);
1252             ppot[spec2][spec1] = pp2;
1253         } catch (std::exception &ex) {
1254             throw customException(ex\&.what());
1255         }
1256     } else if (ppot_name == "fs_lennard_jones") {
1257         try {
1258             auto pp1 = std::make_shared < fsLennardJones > ();
1259             pp1->setParameters(params);
1260             ppot[spec1][spec2] = pp1;
1261             auto pp2 = std::make_shared < fsLennardJones > ();
1262             pp2->setParameters(params);
1263             ppot[spec2][spec1] = pp2;
1264         } catch (std::exception &ex) {
1265             throw customException(ex\&.what());
1266         }
1267     } else if (ppot_name == "hard_sphere") {
1268         try {
1269             auto pp1 = std::make_shared < hardCore > ();
1270             pp1->setParameters(params);
1271             ppot[spec1][spec2] = pp1;
1272             auto pp2 = std::make_shared < hardCore > ();
1273             pp2->setParameters(params);
1274             ppot[spec2][spec1] = pp2;
1275         } catch (std::exception &ex) {
1276             throw customException(ex\&.what());
1277         }
1278     } else if (ppot_name == "tabulated") {
1279         try {
1280             auto pp1 = std::make_shared < tabulated > ();
1281             pp1->setParameters(params);
1282             pp1->loadPotential(tabFile);
1283             ppot[spec1][spec2] = pp1;
1284             auto pp2 = std::make_shared < tabulated > ();
1285             pp2->setParameters(params);
1286             pp2->loadPotential(tabFile);
1287             ppot[spec2][spec1] = pp2;
1288         } catch (std::exception &ex) {
1289             throw customException(ex\&.what());
1290         }
1291     } else {
1292         throw customException("Unrecognized pair potential name for species "+numToStr(spec1)+", "+numToStr(spec2));
1293     }
1294 
1295     ppotSet_[spec1][spec2] = true;
1296     ppotSet_[spec2][spec1] = true;
1297 
1298     if (useCellList) {
1299         sendMsg("Setting up cell list for interactions between type "+numToStr(spec1)+" and "+numToStr(spec2));
1300         // Add creation of cell lists
1301         if ((ppot[spec1][spec2]->rcut() > box_[0]/3\&.0) || (ppot[spec1][spec2]->rcut() > box_[1]/3\&.0) || (ppot[spec1][spec2] ->rcut() > box_[2]/3\&.0)) {
1302             sendErr("Cutoff ("+numToStr(ppot[spec1][spec2]->rcut())+") larger than 1\&.0/3\&.0 boxsize, disabling cell lists for this interaction");
1303             useCellList_[spec1][spec2] = false;
1304             useCellList_[spec2][spec1] = false;
1305         } else {
1306             sendMsg("Creating Cell list with r_cut = "+numToStr(ppot[spec1][spec2]->rcut()));
1307             useCellList_[spec1][spec2] = true;
1308             useCellList_[spec2][spec1] = true;
1309 
1310             std::vector <atom*> dummyList(0);
1311 
1312             if (cellListsByPairType_[spec1][spec2] == NULL) {
1313                 cellLists_\&.push_back(cellList(box_, ppot[spec1][spec2]->rcut(), dummyList));
1314                 cellListsByPairType_[spec1][spec2] = &cellLists_[cellLists_\&.size()-1];
1315             }
1316             if (cellListsByPairType_[spec2][spec1] == NULL) {
1317                 cellLists_\&.push_back(cellList(box_, ppot[spec2][spec1]->rcut(), dummyList));
1318                 cellListsByPairType_[spec2][spec1] = &cellLists_[cellLists_\&.size()-1];
1319             }
1320         }
1321     } else {
1322         useCellList_[spec1][spec2] = false;
1323         useCellList_[spec2][spec1] = false;
1324     }
1325 }
.fi
.SS "const double simSystem::beta ()\fC [inline]\fP"

.PP
Return 1/kT\&. 
.PP
Definition at line 87 of file system\&.h\&.
.PP
Referenced by aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), and simSystem()\&.
.SS "const std::vector< double > simSystem::box ()\fC [inline]\fP"

.PP
Return the system box dimensions\&. 
.PP
Definition at line 112 of file system\&.h\&.
.PP
Referenced by checkBounds(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), setBarriers(), setConfig(), setMoves(), and simSystem()\&.
.SS "void simSystem::checkEnergyHistogramBounds ()"

.PP
Monitor the energy histogram bounds at each Ntot\&. 
.PP
Definition at line 857 of file system\&.cpp\&.
.PP
Referenced by performCrossover(), and performWALA()\&.
.PP
.nf
857                                             {
858     if (totN_ >= totNBounds_[0] && totN_ <= totNBounds_[1]) {
859         const int address = totN_-totNBounds_[0];
860         energyHistogram_lb_[address] = std::min(energyHistogram_lb_[address], energy_);
861         energyHistogram_ub_[address] = std::max(energyHistogram_ub_[address], energy_);
862     }
863 }
.fi
.SS "void simSystem::decrementMState ()"

.PP
Decrease the expanded ensemble state of the system by 1\&. Accounts for the periodicity of [0, M) 
.PP
Definition at line 16 of file system\&.cpp\&.
.PP
.nf
16                                  {
17     Mcurrent_--;
18     if (Mcurrent_ < 0) {
19         Mcurrent_ += Mtot_;
20     }
21 }
.fi
.SS "void simSystem::deleteAtom (const inttypeIndex, const intatomIndex, booloverride = \fCfalse\fP)"

.PP
Delete an atom from the system\&. Does all the bookkeepping behind the scenes\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeIndex\fP What type the atom is (>= 0) 
.br
\fIatomIndex\fP Which atom \fIindex\fP of type typeIndex to destroy (>= 0) 
.br
\fIOptional\fP override command which allows the system to delete a particle even it goes below the minimum allowed\&. E\&.g\&. during a swap move\&. 
.RE
.PP

.PP
Definition at line 241 of file system\&.cpp\&.
.PP
References atoms, atom::mState, numSpecies, and cellList::swapAndDeleteParticle()\&.
.PP
Referenced by deleteParticle::make(), swapParticles::make(), and readConfig()\&.
.PP
.nf
241                                                                                    {
242     if (typeIndex < nSpecies_ && typeIndex >= 0) {
243         if ((numSpecies[typeIndex] > minSpecies_[typeIndex]) || ((numSpecies[typeIndex] == minSpecies_[typeIndex]) && (Mcurrent_ > 0)) || override) {
244             if (override) {
245                 // doing a swap move
246                 if (Mtot_ > 1) {
247                     // expanded ensemble and not necessarily deleting the partial atom
248 
249                     int end = numSpecies[typeIndex] - 1;
250                     if (fractionalAtomType_ == typeIndex && Mcurrent_ > 0) {
251                         // we are deleting a particle which has to watch out for the partial atom
252                         end++;
253                     }
254 
255                     if (atoms[typeIndex][atomIndex]\&.mState == 0) {
256                         // if we are removing a "full" particle, have to decrement Ntot, else not
257                         numSpecies[typeIndex]--;
258                         totN_--;
259                     } else {
260                         // but if removing the partial particle, M is affected
261                         Mcurrent_ = 0; // regardless of how M was originally, the partial particle is now "entirely" gone
262                     }
263 
264                     bool replace = false;
265                     if (&atoms[typeIndex][end] == fractionalAtom_) {
266                         // then the fractional atom is about to be used to replace a "full" one
267                         replace = true;
268                     }
269 
270                     // have to entirely remove the particle
271                     for (unsigned int i = 0; i < nSpecies_; ++i) {
272                         if (useCellList_[typeIndex][i]) {
273                             cellList* cl = cellListsByPairType_[typeIndex][i];
274                             cl->swapAndDeleteParticle(&atoms[typeIndex][atomIndex], &atoms[typeIndex][end]);
275                         }
276                     }
277 
278                     atoms[typeIndex][atomIndex] = atoms[typeIndex][end];    // "replacement" operation
279 
280                     if (replace) {
281                         fractionalAtom_ = &atoms[typeIndex][atomIndex]; // update the pointer if necessary
282                     }
283                 } else {
284                     // no expanded ensemble, just delete particle from appropriate cell list
285                     for (unsigned int i = 0; i < nSpecies_; ++i) {
286                         if (useCellList_[typeIndex][i]) {
287                             cellList* cl = cellListsByPairType_[typeIndex][i];
288                             cl->swapAndDeleteParticle(&atoms[typeIndex][atomIndex], &atoms[typeIndex][numSpecies[typeIndex] - 1]);
289                         }
290                     }
291 
292                     atoms[typeIndex][atomIndex] = atoms[typeIndex][numSpecies[typeIndex] - 1];    // "replacement" operation
293                     numSpecies[typeIndex]--;
294                     totN_--;
295                 }
296             } else {
297                 // not doing a swap move, just a "regular" deletion
298                 if (Mtot_ > 1) {
299                     // expanded ensemble
300                     if (Mcurrent_ == 1) {
301                         // when we delete this atom, it is entirely gone
302 
303                         // first ensure the system pointer is correct if currently a partially inserted atom
304                         if (fractionalAtom_ != &atoms[typeIndex][atomIndex] || typeIndex != fractionalAtomType_) {
305                             throw customException ("Fractional atom pointer does not point to atom belived to be inserted");
306                         }
307 
308                         // decrement expanded state
309                         fractionalAtom_->mState = 0;
310                         Mcurrent_ = 0;
311 
312                         // since deleting partial particle, do not update Ntot, etc\&.
313                         // however, do have to remove from cellLists
314                         int end = numSpecies[typeIndex]; // includes space for the partially inserted one currently in cellList
315                         for (unsigned int i = 0; i < nSpecies_; ++i) {
316                             if (useCellList_[typeIndex][i]) {
317                                 cellList* cl = cellListsByPairType_[typeIndex][i];
318                                 cl->swapAndDeleteParticle(&atoms[typeIndex][atomIndex], &atoms[typeIndex][end]);
319                             }
320                         }
321 
322                         atoms[typeIndex][atomIndex] = atoms[typeIndex][end];    // "replacement" operation
323 
324                     } else if (Mcurrent_ == 0) {
325                         // have to decrement Ntot, but keep in cell lists
326                         numSpecies[typeIndex]--;
327                         totN_--;
328 
329                         // this is a new fractional atom
330                         fractionalAtom_ = &atoms[typeIndex][atomIndex];
331                         fractionalAtomType_ = typeIndex;
332 
333                         // decrement expanded state
334                         fractionalAtom_->mState = Mtot_-1;
335                         Mcurrent_ = Mtot_-1;
336                     } else {
337                         // further deleting an atom that already partially exists in the system, but remains in cell lists
338 
339                         // first ensure the system pointer is correct if currently a partially inserted atom
340                         if (fractionalAtom_ != &atoms[typeIndex][atomIndex] || typeIndex != fractionalAtomType_) {
341                             throw customException ("Fractional atom pointer does not point to atom belived to be inserted");
342                         }
343 
344                         // decrement expanded state
345                         fractionalAtom_->mState -= 1;
346                         Mcurrent_ -= 1;
347                     }
348                 } else {
349                     // no expanded ensemble, just delete particle from appropriate cell list
350                     for (unsigned int i = 0; i < nSpecies_; ++i) {
351                         if (useCellList_[typeIndex][i]) {
352                             cellList* cl = cellListsByPairType_[typeIndex][i];
353                             cl->swapAndDeleteParticle(&atoms[typeIndex][atomIndex], &atoms[typeIndex][numSpecies[typeIndex] - 1]);
354                         }
355                     }
356 
357                     atoms[typeIndex][atomIndex] = atoms[typeIndex][numSpecies[typeIndex] - 1];    // "replacement" operation
358                     numSpecies[typeIndex]--;
359                     totN_--;
360                 }
361             }
362         } else {
363             throw customException ("System going below minimum allowable number of atoms, cannot delete an atom of type index "+std::to_string(typeIndex));
364         }
365     } else {
366         throw customException ("That species index does not exist, cannot delete an atom");
367     }
368 }
.fi
.SS "const double simSystem::energy ()\fC [inline]\fP"

.PP
Return the system's instantaneous energy\&. 
.PP
Definition at line 84 of file system\&.h\&.
.PP
Referenced by performGCMC(), and sanityChecks()\&.
.SS "const std::vector< double > simSystem::extMomCounter ()\fC [inline]\fP"

.PP
Get counter for extensive moments needed for restarting system from a checkpoint\&. 
.PP
Definition at line 111 of file system\&.h\&.
.PP
References histogram::getCounter()\&.
.PP
Referenced by checkpoint::dump()\&.
.SS "const int simSystem::getCurrentM ()\fC [inline]\fP"

.PP
Return the system's current expanded ensemble fractional state\&. 
.PP
Definition at line 80 of file system\&.h\&.
.PP
Referenced by calculateBias(), aggVolBias3::make(), translateParticle::make(), deleteParticle::make(), insertParticle::make(), swapParticles::make(), moves::makeMove(), performCrossover(), performGCMC(), performTMMC(), performWALA(), and sanityChecks()\&.
.SS "std::vector< double > simSystem::getELB ()\fC [inline]\fP"

.PP
Returns current tally of energy min at each Ntot for checkpointing\&. 
.PP
Definition at line 113 of file system\&.h\&.
.PP
Referenced by checkpoint::dump()\&.
.SS "std::vector< double > simSystem::getEUB ()\fC [inline]\fP"

.PP
Returns current tally of energy max at each Ntot for checkpointing\&. 
.PP
Definition at line 114 of file system\&.h\&.
.PP
Referenced by checkpoint::dump()\&.
.SS "\fBatom\fP* simSystem::getFractionalAtom ()\fC [inline]\fP"

.PP
Returns a pointer the atom in the system that is currently only fractionally inserted/deleted\&. 
.PP
Definition at line 118 of file system\&.h\&.
.PP
Referenced by deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), and sanityChecks()\&.
.SS "const int simSystem::getFractionalAtomType ()\fC [inline]\fP"

.PP
Return the atom type of the fractional atom\&. 
.PP
Definition at line 82 of file system\&.h\&.
.PP
Referenced by aggVolBias3::make(), translateParticle::make(), swapParticles::make(), moves::makeMove(), and sanityChecks()\&.
.SS "const int simSystem::getMaxOrder ()\fC [inline]\fP"

.PP
Return the max order the extensive moments are being stored out to\&. 
.PP
Definition at line 78 of file system\&.h\&.
.PP
Referenced by restartExtMoments(), and setConfig()\&.
.SS "std::vector< \fBatom\fP * > simSystem::getNeighborAtoms (const unsigned inttypeIndexA, const unsigned inttypeIndexB, \fBatom\fP *_atom)"

.PP
Return the list of neighbors of type A, around a particle of type B which is passed\&. 
.PP
\fBParameters:\fP
.RS 4
\fItypeIndexA\fP Index of first atom type 
.br
\fItypeIndexB\fP Index of second atom type 
.br
\fIatom\fP Pointer to atom to find neighbors around
.RE
.PP
\fBReturns:\fP
.RS 4
neighbor_list 
.RE
.PP

.PP
Definition at line 1501 of file system\&.cpp\&.
.PP
References atoms, cellList::calcIndex(), cellList::cells, cellList::neighbours, numSpecies, and atom::pos\&.
.PP
Referenced by deleteParticle::make(), translateParticle::make(), swapParticles::make(), and insertParticle::make()\&.
.PP
.nf
1501                                                                                                                          {
1502     std::vector < atom* > neighbors;
1503 
1504     int end = numSpecies[typeIndexA];
1505     if (Mcurrent_ > 0 && typeIndexA == fractionalAtomType_) {
1506         // account for partial atom too
1507         end++;
1508     }
1509     neighbors\&.reserve(end);
1510 
1511     // if no cell lists are defined for this interaction, return all particles
1512     if (!useCellList_[typeIndexA][typeIndexB]) {
1513         for (unsigned int i = 0; i < end; ++i) {
1514             if (_atom != &atoms[typeIndexA][i]) { // watch out for self in case typeA = typeB
1515                 neighbors\&.push_back(&atoms[typeIndexA][i]);
1516             }
1517         }
1518     } else if (useCellList_[typeIndexA][typeIndexB]) {
1519         cellList* cl = cellListsByPairType_[typeIndexA][typeIndexB];
1520         const unsigned int cellIndex = cl->calcIndex(_atom->pos[0], _atom->pos[1], _atom->pos[2]);
1521 
1522         // loop over own cell
1523         for (unsigned int i = 0; i < cl->cells[cellIndex]\&.size(); ++i) {
1524             if (_atom != cl->cells[cellIndex][i]) {
1525                 neighbors\&.push_back(cl->cells[cellIndex][i]);
1526             }
1527         }
1528 
1529         // loop over neighboring cells
1530         for (unsigned int i = 0; i < cl->neighbours[cellIndex]\&.size(); ++i) {
1531             const unsigned int neighborCellIndex = cl->neighbours[cellIndex][i];
1532             for (unsigned int j = 0; j < cl->cells[neighborCellIndex]\&.size(); ++j) {
1533                 if (_atom != cl->cells[neighborCellIndex][j]) {
1534                     neighbors\&.push_back(cl->cells[neighborCellIndex][j]);
1535                 }
1536             }
1537         }
1538     }
1539 
1540     return neighbors;
1541 }
.fi
.SS "\fBtmmc\fP * simSystem::getTMMCBias ()"

.PP
Return pointer to the TMMC bias\&. Return a pointer to the TMMC biasing object, if using TMMC, else throws an exception\&.
.PP
\fBReturns:\fP
.RS 4
tmmc Pointer to TMMC biasing object being used\&. 
.RE
.PP

.PP
Definition at line 1704 of file system\&.cpp\&.
.PP
References tmmcBias, and useTMMC\&.
.PP
Referenced by checkpoint::dump(), checkpoint::load(), performCrossover(), and performTMMC()\&.
.PP
.nf
1704                               {
1705     if (useTMMC == true) {
1706         return tmmcBias;
1707     } else {
1708         throw customException ("Not using TMMC");
1709     }
1710 }
.fi
.SS "const int simSystem::getTotalM ()\fC [inline]\fP"

.PP
Return the total number of fractional states available to species in the expanded ensemble\&. 
.PP
Definition at line 81 of file system\&.h\&.
.PP
Referenced by checkpoint::load(), deleteParticle::make(), insertParticle::make(), moves::makeMove(), performCrossover(), performTMMC(), performWALA(), sanityChecks(), setBarriers(), setConfig(), setMoves(), and setPairPotentials()\&.
.SS "const int simSystem::getTotN ()\fC [inline]\fP"

.PP
Return a sum of the total number of atoms currently in the system\&. 
.PP
Definition at line 77 of file system\&.h\&.
.PP
Referenced by calculateBias(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), and sanityChecks()\&.
.SS "\fBwala\fP * simSystem::getWALABias ()"

.PP
Return pointer to the Wang-Landau bias\&. Return a pointer to the TMMC biasing object, if using TMMC, else throws an exception\&.
.PP
\fBReturns:\fP
.RS 4
wala Pointer to WALA biasing object being used\&. 
.RE
.PP

.PP
Definition at line 1717 of file system\&.cpp\&.
.PP
References useWALA, and wlBias\&.
.PP
Referenced by checkpoint::dump(), checkpoint::load(), aggVolBias3::make(), translateParticle::make(), deleteParticle::make(), swapParticles::make(), insertParticle::make(), performCrossover(), and performWALA()\&.
.PP
.nf
1717                               {
1718     if (useWALA == true) {
1719         return wlBias;
1720     } else {
1721         throw customException ("Not using WALA");
1722     }
1723 }
.fi
.SS "void simSystem::incrementEnergy (const doubledU)\fC [inline]\fP"

.PP
Increment the system's energy\&. 
.PP
Definition at line 34 of file system\&.h\&.
.PP
Referenced by aggVolBias3::make(), translateParticle::make(), deleteParticle::make(), insertParticle::make(), and swapParticles::make()\&.
.SS "void simSystem::incrementMState ()"

.PP
Increase the expanded ensemble state of the system by 1\&. Accounts for the periodicity of [0, M) 
.PP
Definition at line 6 of file system\&.cpp\&.
.PP
.nf
6                                  {
7     Mcurrent_++;
8     if (Mcurrent_ == Mtot_) {
9         Mcurrent_ = 0;
10     }
11 }
.fi
.SS "void simSystem::insertAtom (const inttypeIndex, \fBatom\fP *newAtom, booloverride = \fCfalse\fP)"

.PP
Insert an atom into the system\&. Does all the bookkeepping behind the scenes\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeIndex\fP What type the atom is (>= 0) 
.br
\fInewAtom\fP Pointer to new atom\&. A copy is stored in the system so the original may be destroyed\&. 
.br
\fIoverride\fP Override command that prevents the expanded ensemble state from being changed\&. Used during swap moves where 'insertions' are temporary\&. 
.RE
.PP

.PP
Definition at line 140 of file system\&.cpp\&.
.PP
References atoms, cellList::insertParticle(), atom::mState, and numSpecies\&.
.PP
Referenced by insertParticle::make(), swapParticles::make(), and readConfig()\&.
.PP
.nf
140                                                                              {
141     if (typeIndex < nSpecies_ && typeIndex >= 0) {
142         if (numSpecies[typeIndex] < maxSpecies_[typeIndex]) {
143             if (Mtot_ > 1 && !override) {
144                 // expanded ensemble behavior, "normal" insertion and deletion
145                 if (Mcurrent_ > 0) { // further inserting an atom that already partially exists in the system
146                     // ensure the system pointer is correct if currently a partially inserted atom
147                     if (fractionalAtom_ != newAtom || typeIndex != fractionalAtomType_) {
148                         throw customException ("Fractional atom pointer does not point to atom believed to be inserted");
149                     }
150 
151                     // increment expanded state
152                     fractionalAtom_->mState++;
153                     Mcurrent_++;
154 
155                     // check if now fully inserted
156                     if (fractionalAtom_->mState == Mtot_) {
157                         fractionalAtom_->mState = 0;
158                         Mcurrent_ = 0;
159                         totN_++;
160                         numSpecies[typeIndex]++;
161                     }
162                 } else {
163                     // Inserting a new atom for the first time
164                     atoms[typeIndex][numSpecies[typeIndex]] = (*newAtom);
165 
166                     // Assign fractional atom
167                     fractionalAtom_ = &atoms[typeIndex][numSpecies[typeIndex]];
168                     fractionalAtomType_ = typeIndex;
169 
170                     // Increment expanded state
171                     fractionalAtom_->mState = 1;
172                     Mcurrent_ = 1;
173 
174                     // Add particle into appropriate cell lists
175                     for (unsigned int i = 0; i < nSpecies_; ++i) {
176                         if (useCellList_[typeIndex][i]) {
177                             cellList* cl = cellListsByPairType_[typeIndex][i];
178                             cl->insertParticle(&atoms[typeIndex][numSpecies[typeIndex]]); // numSpecies[typeIndex] is the number of fully inserted ones, this partially inserted one comes after that
179                         }
180                     }
181                 }
182             } else if (Mtot_ > 1 && override) {
183                 // Expanded ensemble behavior, but now amidst a "swap move" rather than an actual insertion or deletion\&.
184                 // For this, insertions involve just putting the atom "back" into the system / cellLists after being artificially completely removed
185 
186                 // Ensure we insert at the proper "end"
187                 int end = numSpecies[typeIndex];
188                 if (Mcurrent_ > 0 && typeIndex == fractionalAtomType_ && newAtom->mState == 0) {
189                     end++; // Insert after the partially inserted one since newAtom is NOT the partial one
190                 }
191                 atoms[typeIndex][end] = (*newAtom);
192 
193                 // If we just added a partially inserted/deleted particle back to the system, need to update the pointer
194                 if (atoms[typeIndex][end]\&.mState != 0) {
195                     fractionalAtom_ = &atoms[typeIndex][end];
196                     fractionalAtomType_ = typeIndex;
197 
198                     // Set the system's mState back to that of the atom just inserted, iff it was the partial one
199                     Mcurrent_ = atoms[typeIndex][end]\&.mState;
200                 } else {
201                     totN_++; // We just added a "full" atom
202                     numSpecies[typeIndex]++; // We just added a "full" atom
203                 }
204 
205                 // Put newAtom into the cell lists whatever its state
206                 for (unsigned int i = 0; i < nSpecies_; ++i) {
207                     if (useCellList_[typeIndex][i]) {
208                         cellList* cl = cellListsByPairType_[typeIndex][i];
209                         cl->insertParticle(&atoms[typeIndex][end]);
210                     }
211                 }
212             } else {
213                 // Direct insertion (no expanded ensemble)
214                 atoms[typeIndex][numSpecies[typeIndex]] = (*newAtom);
215                 numSpecies[typeIndex]++;
216                 totN_++;
217 
218                 // Add particle into appropriate cell lists
219                 for (unsigned int i = 0; i < nSpecies_; ++i) {
220                     if (useCellList_[typeIndex][i]) {
221                         cellList* cl = cellListsByPairType_[typeIndex][i];
222                         cl->insertParticle(&atoms[typeIndex][numSpecies[typeIndex] - 1]);
223                     }
224                 }
225             }
226         } else {
227             throw customException ("Reached upper bound, cannot insert an atom of type index "+std::to_string(typeIndex));
228         }
229     } else {
230         throw customException ("That species index does not exist, cannot insert an atom");
231     }
232 }
.fi
.SS "const double simSystem::mass (const intindex)\fC [inline]\fP"

.PP
Return the mass of a given species' index\&. 
.PP
Definition at line 89 of file system\&.h\&.
.PP
Referenced by deleteParticle::make(), and insertParticle::make()\&.
.SS "const int simSystem::maxSpecies (const intindex)"

.PP
Returns the absolute maximum number of a given species type allowed in the system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Species index to query
.RE
.PP
\fBReturns:\fP
.RS 4
maxSpecies Maximum number of them allowed 
.RE
.PP

.PP
Definition at line 1670 of file system\&.cpp\&.
.PP
Referenced by insertParticle::make(), and simSystem()\&.
.PP
.nf
1670                                                 {
1671     if (maxSpecies_\&.begin() == maxSpecies_\&.end()) {
1672             throw customException ("No species in the system, cannot report a maximum");
1673         }
1674         if (maxSpecies_\&.size() <= index) {
1675             throw customException ("System does not contain that species, cannot report a maximum");
1676         } else  {
1677             return maxSpecies_[index];
1678         }
1679 }
.fi
.SS "const int simSystem::minSpecies (const intindex)"

.PP
Returns the absolute minimum number of a given species type allowed in the system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Species index to query
.RE
.PP
\fBReturns:\fP
.RS 4
minSpecies Minimum number of them allowed 
.RE
.PP

.PP
Definition at line 1688 of file system\&.cpp\&.
.PP
Referenced by deleteParticle::make(), and simSystem()\&.
.PP
.nf
1688                                                 {
1689     if (minSpecies_\&.begin() == minSpecies_\&.end()) {
1690             throw customException ("No species in the system, cannot report a minimum");
1691         }
1692         if (minSpecies_\&.size() <= index) {
1693             throw customException ("System does not contain that species, cannot report a minimum");
1694         } else  {
1695             return minSpecies_[index];
1696         }
1697 }
.fi
.SS "const double simSystem::mu (const intindex)\fC [inline]\fP"

.PP
Return the chemical potential for a given species' index\&. 
.PP
Definition at line 88 of file system\&.h\&.
.PP
Referenced by deleteParticle::make(), insertParticle::make(), and simSystem()\&.
.SS "const int simSystem::nSpecies ()\fC [inline]\fP"

.PP
Return the number of different species in the system\&. 
.PP
Definition at line 72 of file system\&.h\&.
.PP
Referenced by checkBounds(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), performGCMC(), sanityChecks(), setBarriers(), setConfig(), setMoves(), setPairPotentials(), and simSystem()\&.
.SS "bool simSystem::potentialIsSet (const intspec1, const intspec2)\fC [inline]\fP"

.PP
Boolean which returns whether or not a pair has had its potential specified by the user yet\&. 
.PP
Definition at line 70 of file system\&.h\&.
.PP
Referenced by checkBounds(), and readConfig()\&.
.SS "void simSystem::printEnergyHistogram (const std::stringfileName, const boolnormalize = \fCtrue\fP)"

.PP
Print the (normalized by default) energy histogram for each Ntot\&. Refines bounds before each print\&.
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Prefix of the filename to load from 
.br
\fInormalize\fP Whether or not to normalize the histogram (default=true) 
.RE
.PP

.PP
Definition at line 915 of file system\&.cpp\&.
.PP
Referenced by checkpoint::dump(), and performTMMC()\&.
.PP
.nf
915                                                                                     {
916     std::ofstream of;
917     std::string name = fileName+"\&.dat";
918     of\&.open(name\&.c_str(), std::ofstream::out);
919     of << "# <P(U)> as a function of N_tot\&." << std::endl;
920     of << "# number_of_species: " << nSpecies_ << std::endl;
921     of << "# species_total_upper_bound: " << totNBounds_[1] << std::endl;
922     of << "# species_total_lower_bound: " << totNBounds_[0] << std::endl;
923     double V = box_[0]*box_[1]*box_[2];
924     of << "# volume: " << std::setprecision(15) << V << std::endl;
925     of << "# Bin widths for each" << std::endl;
926     for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
927         of << it->get_delta() << "\t";
928     }
929     of << std::endl;
930     of << "# Bin lower bound for each" << std::endl;
931     for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
932         of << it->get_lb() << "\t";
933     }
934     of << std::endl;
935     of << "# Bin upper bound for each" << std::endl;
936     for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
937         of << it->get_ub() << "\t";
938     }
939     of << std::endl;
940     if (normalize) {
941         of << "# Normalized histogram for each" << std::endl;
942         for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
943             std::deque <double> h = it->get_hist();
944             double sum = 0\&.0;
945             for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
946                 sum += *it2;
947             }
948             for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
949                 of << std::setprecision(15) << *it2/sum << "\t";
950             }
951             of << std::endl;
952         }
953     } else {
954         of << "# Unnormalized histogram for each" << std::endl;
955         for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
956             std::deque <double> h = it->get_hist();
957             for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
958                 of << std::setprecision(15) << *it2 << "\t";
959             }
960             of << std::endl;
961         }
962     }
963     of\&.close();
964 }
.fi
.SS "void simSystem::printExtMoments (const std::stringfileName, const boolnormalize = \fCtrue\fP)"

.PP
Print the (normalized by default) extensive energy histogram for each Ntot\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of the file to print to 
.br
\fInormalize\fP Whether or not to normalize the histogram (default=true) 
.RE
.PP

.PP
Definition at line 661 of file system\&.cpp\&.
.PP
References histogram::getAddress(), histogram::getCounter(), and histogram::getRawHistogram()\&.
.PP
Referenced by checkpoint::dump(), and performTMMC()\&.
.PP
.nf
661                                                                                {
662     std::ofstream of;
663     std::string name = fileName+"\&.dat";
664     of\&.open(name\&.c_str(), std::ofstream::out);
665     of << "# <N_i^j*N_k^m*U^p> as a function of N_tot\&." << std::endl;
666     of << "# number_of_species: " << nSpecies_ << std::endl;
667     of << "# max_order: " << max_order_ << std::endl;
668     of << "# species_total_upper_bound: " << totNBounds_[1] << std::endl;
669     of << "# species_total_lower_bound: " << totNBounds_[0] << std::endl;
670     double V = box_[0]*box_[1]*box_[2];
671     of << "# volume: " << std::setprecision(15) << V << std::endl;
672     of << "#\tN_tot\t";
673     for (unsigned int i = 0; i < nSpecies_; ++i) {
674         for (unsigned int j = 0; j <= max_order_; ++j) {
675             for (unsigned int k = 0; k < nSpecies_; ++k) {
676                 for (unsigned int m = 0; m <= max_order_; ++m) {
677                     for (unsigned int p = 0; p <= max_order_; ++p) {
678                         of << "N_"+std::to_string(i+1)+"^"+std::to_string(j)+"*N_"+std::to_string(k+1)+"^"+std::to_string(m)+"*U^"+std::to_string(p)+"\t";
679                     }
680                 }
681             }
682         }
683     }
684     of << std::endl;
685     std::vector <double> h = extensive_moments_\&.getRawHistogram ();
686     std::vector <double> ctr = extensive_moments_\&.getCounter ();
687     std::vector <double> coords (6,0);
688     long unsigned int idx = 0;
689     if (normalize) {
690         for (unsigned int n = 0; n < totNBounds_[1]-totNBounds_[0]+1; ++n) {
691             of << n+totNBounds_[0] << "\t";
692             coords[5] = n;
693             for (unsigned int i = 0; i < nSpecies_; ++i) {
694                 coords[0] = i;
695                 for (unsigned int j = 0; j <= max_order_; ++j) {
696                     coords[1] = j;
697                     for (unsigned int k = 0; k < nSpecies_; ++k) {
698                         coords[2] = k;
699                         for (unsigned int m = 0; m <= max_order_; ++m) {
700                             coords[3] = m;
701                             for (unsigned int p = 0; p <= max_order_; ++p) {
702                                 coords[4] = p;
703                                 idx = extensive_moments_\&.getAddress(coords);
704                                 of << std::setprecision(15) << h[idx]/ctr[idx] << "\t";
705                             }
706                         }
707                     }
708                 }
709             }
710             of << std::endl;
711         }
712     } else {
713         for (unsigned int n = 0; n < totNBounds_[1]-totNBounds_[0]+1; ++n) {
714             of << n+totNBounds_[0] << "\t";
715             coords[5] = n;
716             for (unsigned int i = 0; i < nSpecies_; ++i) {
717                 coords[0] = i;
718                 for (unsigned int j = 0; j <= max_order_; ++j) {
719                     coords[1] = j;
720                     for (unsigned int k = 0; k < nSpecies_; ++k) {
721                         coords[2] = k;
722                         for (unsigned int m = 0; m <= max_order_; ++m) {
723                             coords[3] = m;
724                             for (unsigned int p = 0; p <= max_order_; ++p) {
725                                 coords[4] = p;
726                                 idx = extensive_moments_\&.getAddress(coords);
727                                 of << std::setprecision(15) << h[idx] << "\t";
728                             }
729                         }
730                     }
731                 }
732             }
733             of << std::endl;
734         }
735     }
736     of\&.close();
737 }
.fi
.SS "void simSystem::printPkHistogram (const std::stringfileName, const boolnormalize = \fCtrue\fP)"

.PP
Print the (normalized by default) particle number histogram for each Ntot\&. Refines histograms before each print\&.
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Prefix of filename to print to 
.br
\fInormalize\fP Whether or not to normalize the histogram (default=true) 
.RE
.PP

.PP
Definition at line 1081 of file system\&.cpp\&.
.PP
Referenced by checkpoint::dump(), and performTMMC()\&.
.PP
.nf
1081                                                                                 {
1082     for (unsigned int i = 0; i < nSpecies_; ++i) {
1083         std::ofstream of;
1084         std::string name = fileName+"_"+std::to_string(i+1)+"\&.dat";
1085         of\&.open(name\&.c_str(), std::ofstream::out);
1086         of << "# <P(N_" << i+1 << ")> as a function of N_tot\&." << std::endl;
1087         of << "# number_of_species: " << nSpecies_ << std::endl;
1088         of << "# species_total_upper_bound: " << totNBounds_[1] << std::endl;
1089         of << "# species_total_lower_bound: " << totNBounds_[0] << std::endl;
1090         double V = box_[0]*box_[1]*box_[2];
1091         of << "# volume: " << std::setprecision(15) << V << std::endl;
1092         of << "# Bin widths for each species index " << std::endl;
1093         for (std::vector < dynamic_one_dim_histogram >::iterator it = pkHistogram_[i]\&.begin(); it != pkHistogram_[i]\&.end(); ++it) {
1094             of << it->get_delta() << "\t";
1095         }
1096         of << std::endl;
1097         of << "# Bin lower bound for each species index " << std::endl;
1098         for (std::vector < dynamic_one_dim_histogram >::iterator it = pkHistogram_[i]\&.begin(); it != pkHistogram_[i]\&.end(); ++it) {
1099             of << it->get_lb() << "\t";
1100         }
1101         of << std::endl;
1102         of << "# Bin upper bound for each species index " << std::endl;
1103         for (std::vector < dynamic_one_dim_histogram >::iterator it = pkHistogram_[i]\&.begin(); it != pkHistogram_[i]\&.end(); ++it) {
1104             of << it->get_ub() << "\t";
1105         }
1106         of << std::endl;
1107         if (normalize) {
1108             of << "# Normalized histogram for each species index " << std::endl;
1109             for (std::vector < dynamic_one_dim_histogram >::iterator it = pkHistogram_[i]\&.begin(); it != pkHistogram_[i]\&.end(); ++it) {
1110                 std::deque <double> h = it->get_hist();
1111                 double sum = 0\&.0;
1112                 for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
1113                     sum += *it2;
1114                 }
1115                 for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
1116                     of << std::setprecision(15) << *it2/sum << "\t";
1117                 }
1118                 of << std::endl;
1119             }
1120         } else {
1121             of << "# Unnormalized histogram for each species index " << std::endl;
1122             for (std::vector < dynamic_one_dim_histogram >::iterator it = pkHistogram_[i]\&.begin(); it != pkHistogram_[i]\&.end(); ++it) {
1123                 std::deque <double> h = it->get_hist();
1124                 for (std::deque <double>::iterator it2 = h\&.begin(); it2 != h\&.end(); ++it2) {
1125                     of << std::setprecision(15) << *it2 << "\t";
1126                 }
1127                 of << std::endl;
1128             }
1129         }
1130         of\&.close();
1131     }
1132 }
.fi
.SS "void simSystem::printSnapshot (std::stringfilename, std::stringcomment, booloverwrite = \fCtrue\fP)"

.PP
Print an XYZ file of the instantaneous system configuration\&. This can be read in at a later time via estart() function\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP File to store XYZ coordinates to 
.br
\fIcomment\fP Comment line for the file 
.br
\fIoverwrite\fP Flag to overwrite file if it already exists or to append (default = true, overwrite) 
.RE
.PP

.PP
Definition at line 1334 of file system\&.cpp\&.
.PP
References atoms, and numSpecies\&.
.PP
Referenced by checkpoint::dump(), performGCMC(), performTMMC(), and setConfig()\&.
.PP
.nf
1334                                                                                     {
1335     if (overwrite) {
1336         std::ofstream outfile (filename\&.c_str(), std::ofstream::trunc);
1337         int tot = 0;
1338         for (unsigned int j = 0; j < nSpecies_; ++j) {
1339             tot += numSpecies[j]; // only count fully inserted species
1340         }
1341 
1342         outfile << tot << std::endl;
1343         outfile << comment << std::endl;
1344 
1345         for (unsigned int j = 0; j < nSpecies_; ++j) {
1346             long long int num = numSpecies[j];
1347             if (Mcurrent_ > 1 && fractionalAtomType_ == j) {
1348                 num += 1; // account for partially inserted atom
1349             }
1350             for (unsigned int i = 0; i < num; ++i) {
1351                 if (atoms[j][i]\&.mState == 0) { // only print fully inserted atoms
1352                     outfile << j << "\t" <<  std::setprecision(15) << atoms[j][i]\&.pos[0] << "\t" << std::setprecision(15) << atoms[j][i]\&.pos[1] << "\t" << std::setprecision(15) << atoms[j][i]\&.pos[2] << std::endl;
1353                 }
1354             }
1355         }
1356 
1357         outfile\&.close();
1358     } else {
1359         std::ofstream outfile (filename\&.c_str(), std::ofstream::out | std::ofstream::app);
1360         int tot = 0;
1361         for (unsigned int j = 0; j < nSpecies_; ++j) {
1362             tot += numSpecies[j]; // only count fully inserted species
1363         }
1364 
1365         outfile << tot << std::endl;
1366         outfile << comment << std::endl;
1367 
1368         for (unsigned int j = 0; j < nSpecies_; ++j) {
1369             long long int num = numSpecies[j];
1370             if (Mcurrent_ > 1 && fractionalAtomType_ == j) {
1371                 num += 1; // account for partially inserted atom
1372             }
1373             for (unsigned int i = 0; i < num; ++i) {
1374                 if (atoms[j][i]\&.mState == 0) { // only print fully inserted atoms
1375                     outfile << j << "\t" <<  std::setprecision(15) << atoms[j][i]\&.pos[0] << "\t" << std::setprecision(15) << atoms[j][i]\&.pos[1] << "\t" << std::setprecision(15) << atoms[j][i]\&.pos[2] << std::endl;
1376                 }
1377             }
1378         }
1379 
1380         outfile\&.close();
1381     }
1382 }
.fi
.SS "void simSystem::readConfig (std::stringfilename)"

.PP
Read an XYZ file as the system's initial configuration\&. Note that the number of species, etc\&. must already be specified in the constructor\&. Will also reset and calculate the energy from scratch so these potentials should be set before reading in a restart file\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP File to read XYZ coordinates from 
.RE
.PP

.PP
Definition at line 1390 of file system\&.cpp\&.
.PP
References deleteAtom(), insertAtom(), numSpecies, potentialIsSet(), scratchEnergy(), sendErr(), sendMsg(), SYS_FAILURE, and customException::what()\&.
.PP
Referenced by checkpoint::load(), and setConfig()\&.
.PP
.nf
1390                                               {
1391     sendMsg("Reading initial configuration from "+filename);
1392 
1393     std::ifstream infile (filename\&.c_str());
1394     if (!infile\&.is_open()) {
1395         sendErr("Cannot open "+filename);
1396         exit(SYS_FAILURE);
1397     }
1398 
1399     std::string line;
1400     std::vector < atom > sysatoms;
1401     std::vector < int > index;
1402     int natoms = 0;
1403     int lineIndex = 0;
1404     while(std::getline(infile,line)) {
1405         std::stringstream lineStream(line);
1406         if (lineIndex == 0) {
1407             lineStream >> natoms;
1408             index\&.resize(natoms);
1409             sysatoms\&.resize(natoms);
1410         } else if (lineIndex > 1) {
1411             lineStream >> index[lineIndex-2] >> sysatoms[lineIndex-2]\&.pos[0] >> sysatoms[lineIndex-2]\&.pos[1] >> sysatoms[lineIndex-2]\&.pos[2];
1412         }
1413         lineIndex++;
1414     }
1415     infile\&.close();
1416 
1417     // check if within global bounds
1418     if (sysatoms\&.size() > totNBounds_[1] || sysatoms\&.size() < totNBounds_[0]) {
1419         throw customException ("Number of particles ("+std::to_string(sysatoms\&.size())+") in the restart file out of target range ["+std::to_string(totNBounds_[0])+", "+std::to_string(totNBounds_[1])+"]");
1420     }
1421 
1422     // sort by type
1423     std::map < int, int > types;
1424     for (unsigned int j = 0; j < natoms; ++j) {
1425         if (types\&.find(index[j]) != types\&.end()) {
1426             types[index[j]] += 1;
1427         } else {
1428             types[index[j]] = 1;
1429         }
1430     }
1431 
1432     int maxType = -1;
1433     for (std::map < int, int >::iterator it = types\&.begin(); it != types\&.end(); ++it) {
1434         maxType = std::max(maxType, it->first);
1435         if (it->first < 0 || it->first >= nSpecies_) {
1436             throw customException ("Restart file corrupted, types out of range");
1437         }
1438     }
1439 
1440     // check that pair potentials exist so energy can be calculated
1441     for (unsigned int i = 0; i < nSpecies_; ++i) {
1442         for (unsigned int j = 0; j < nSpecies_; ++j) {
1443             if (!potentialIsSet(i, j)) {
1444                 throw customException("Not all pair potentials are set, so cannot initial from file");
1445             }
1446         }
1447     }
1448 
1449     // empty out the system before adding new atoms in - all atoms "fully inserted" so no partial ones to worry about
1450     if (Mcurrent_ != 0) {
1451         throw customException ("System cannot be restarted from "+filename+", for some reason current expanded state != 0");
1452     }
1453     for (unsigned int i = 0; i < nSpecies_; ++i) {
1454         const int ns = numSpecies[i];
1455         for (int j = ns-1; j >=0; --j) {
1456             for (int k = 0; k < Mtot_; ++k) {
1457                 deleteAtom (i, j, true);
1458             }
1459         }
1460     }
1461     if (totN_ != 0) {
1462         throw customException ("total N = "+std::to_string(totN_)+" != 0 after system supposedly emptied");
1463     }
1464     for (unsigned int i = 0; i < nSpecies_; ++i) {
1465         if (numSpecies[i] != 0) {
1466             throw customException ("Number of molecules of species #"+std::to_string(i+1)+" = "+std::to_string(numSpecies[i])+" != 0 after system supposedly emptied");
1467         }
1468     }
1469     if (Mcurrent_ != 0) {
1470         throw customException ("M state != 0 after system supposedly emptied");
1471     }
1472 
1473     energy_ = 0\&.0;
1474     for (unsigned int j = 0; j < sysatoms\&.size(); ++j) {
1475         try {
1476             // "partially" insert each atom so it goes through all the stages
1477             insertAtom (index[j], &sysatoms[j]);
1478             for (unsigned int k = 1; k < Mtot_; ++k) {
1479                 insertAtom (index[j], fractionalAtom_); // this will check that within each species own max and min, global bounds handled above
1480             }
1481         } catch (customException &ce) {
1482             std::string a = "Could not initialize system from restart file, ", b = ce\&.what();
1483             throw customException (a+b);
1484         }
1485     }
1486 
1487     // recalculate system's initial energy
1488     energy_ = scratchEnergy();
1489     sendMsg("Successfully loaded initial configuration from "+filename);
1490 }
.fi
.SS "void simSystem::recordEnergyHistogram ()"

.PP
Record the energy histogram for the system at a given Ntot\&. Only records values when N_tot in range of [min, max]\&. 
.PP
Definition at line 846 of file system\&.cpp\&.
.PP
Referenced by performTMMC()\&.
.PP
.nf
846                                        {
847     // only record if in range (removes equilibration stage to get in this range, if there was any)
848     if (totN_ >= totNBounds_[0] && totN_ <= totNBounds_[1]) {
849         const int address = totN_-totNBounds_[0];
850         energyHistogram_[address]\&.record(energy_);
851     }
852 }
.fi
.SS "void simSystem::recordExtMoments ()"

.PP
Record the extensive moment at a given Ntot\&. 
.PP
Definition at line 629 of file system\&.cpp\&.
.PP
References histogram::increment(), and numSpecies\&.
.PP
Referenced by performTMMC()\&.
.PP
.nf
629                                   {
630     // only record if in range (removes equilibration stage to get in this range, if there was any)
631     if (totN_ >= totNBounds_[0] && totN_ <= totNBounds_[1]) {
632         double val = 0\&.0;
633         std::vector < double > coords (6,0);
634         coords[5] = totN_-totNBounds_[0];
635         for (unsigned int i = 0; i < nSpecies_; ++i) {
636             coords[0] = i;
637             for (unsigned int j = 0; j <= max_order_; ++j) {
638                 coords[1] = j;
639                 for (unsigned int k = 0; k < nSpecies_; ++k) {
640                     coords[2] = k;
641                     for (unsigned int m = 0; m <= max_order_; ++m) {
642                         coords[3] = m;
643                         for (unsigned int p = 0; p <= max_order_; ++p) {
644                             coords[4] = p;
645                             val = pow(numSpecies[i], j)*pow(numSpecies[k], m)*pow(energy_, p);
646                             extensive_moments_\&.increment (coords, val);
647                         }
648                     }
649                 }
650             }
651         }
652     }
653 }
.fi
.SS "void simSystem::recordPkHistogram ()"

.PP
Record the particle number histogram for the system at a given Ntot\&. Only records values when N_tot in range of [min, max]\&. 
.PP
Definition at line 1050 of file system\&.cpp\&.
.PP
References numSpecies\&.
.PP
Referenced by performTMMC()\&.
.PP
.nf
1050                                    {
1051     // only record if in range (removes equilibration stage to get in this range, if there was any)
1052     if (totN_ >= totNBounds_[0] && totN_ <= totNBounds_[1]) {
1053         const int address = totN_-totNBounds_[0];
1054         for (unsigned int i = 0; i < nSpecies_; ++i) {
1055             pkHistogram_[i][address]\&.record(numSpecies[i]);
1056         }
1057     }
1058 }
.fi
.SS "void simSystem::refineEnergyHistogramBounds ()"

.PP
Check the histogram entries and trim off zero-valued entries and bounds\&. 
.PP
Definition at line 868 of file system\&.cpp\&.
.PP
References customException::what()\&.
.PP
Referenced by checkpoint::dump(), and performTMMC()\&.
.PP
.nf
868                                              {
869     for (std::vector < dynamic_one_dim_histogram >::iterator it = energyHistogram_\&.begin(); it != energyHistogram_\&.end(); ++it) {
870         try {
871             it->trim_edges();
872         } catch (customException &ce) {
873             std::string a = "Unable to trim edges in energyHistogram at each Ntot: ", b = ce\&.what();
874             throw customException (a+b);
875         }
876     }
877 }
.fi
.SS "void simSystem::refinePkHistogramBounds ()"

.PP
Check the histogram entries and trim off zero-valued entries and bounds\&. 
.PP
Definition at line 1063 of file system\&.cpp\&.
.PP
Referenced by checkpoint::dump(), and performTMMC()\&.
.PP
.nf
1063                                          {
1064     for (std::vector < std::vector < dynamic_one_dim_histogram > >::iterator it = pkHistogram_\&.begin(); it != pkHistogram_\&.end(); ++it) {
1065         for (std::vector < dynamic_one_dim_histogram >::iterator it2 = it->begin(); it2 != it->end(); ++it2) {
1066             try {
1067                 it2->trim_edges();
1068             } catch (customException &ce) {
1069                 throw customException ("Unable to trim edges in pkHistogram at each Ntot");
1070             }
1071         }
1072     }
1073 }
.fi
.SS "void simSystem::reInitializeEnergyHistogram ()"

.PP
Re-initialize the energy histogram with internal estimates of bounds\&. Intended to be used at crossover stage before TMMC\&. 
.PP
Definition at line 882 of file system\&.cpp\&.
.PP
References totNMax(), and totNMin()\&.
.PP
Referenced by performCrossover()\&.
.PP
.nf
882                                              {
883     double lb = 0\&.0, ub = 0\&.0;
884     if (energyHistogram_lb_\&.size() != energyHistogram_ub_\&.size()) {
885         throw customException ("Bad energy histogram bound sizes");
886     }
887     if (energyHistogram_lb_\&.size() != totNMax() - totNMin() + 1) {
888         throw customException ("Bad energy histogram bound sizes");
889     }
890     for (unsigned int i = 0; i < totNMax() - totNMin() + 1; ++i) {
891         if (energyHistogram_lb_[i] > energyHistogram_ub_[i]) {
892             throw customException ("Bad energy histogram bound sizes");
893         }
894         // "Standardize" the bounds against U = 0 for to "align" the bins, already done for pkHistogram\&.
895         // This allows overlapping windows to be merged, otherwise they are not "aligned"\&.
896         // Rounding does not account for rare edge cases where energy falls exactly on the border between bins, but does not matter since this will be automatically handled\&.
897         // This is just to give the system a good "guess" to conserve memory\&.
898         lb = round((energyHistogram_lb_[i] - 0\&.0)/energyHistDelta_)*energyHistDelta_;
899         ub = round((energyHistogram_ub_[i] - 0\&.0)/energyHistDelta_)*energyHistDelta_;
900 
901         try {
902             energyHistogram_[i]\&.reinitialize(lb,ub,energyHistDelta_);
903         } catch (customException &ce) {
904             throw customException ("Unable to reinitialize the energyHistogram");
905         }
906     }
907 }
.fi
.SS "void simSystem::restartEnergyHistogram (const std::stringprefix)"

.PP
Restart the energy histogram for each Ntot from unnormalized checkpoint\&. This will check for 'alignment' of energy bins to 0\&. So 'manually' prepared files are likely to fail, but this is intended to restart from system-generated files anyway\&.
.PP
\fBParameters:\fP
.RS 4
\fIprefix\fP Prefix of the filename to load from 
.RE
.PP

.PP
Definition at line 972 of file system\&.cpp\&.
.PP
References totNMax(), and totNMin()\&.
.PP
Referenced by checkpoint::load()\&.
.PP
.nf
972                                                               {
973     int minBound = 0, maxBound = totNMax() - totNMin() + 1;
974     std::vector < double > lb(maxBound - minBound, 0), ub(maxBound - minBound, 0), delta(maxBound - minBound, 0);
975     std::string fileName = prefix+"\&.dat";
976 
977     std::ifstream infile (fileName\&.c_str());
978     if (!infile\&.is_open()) {
979         throw customException ("Cannot load energyHistogram from "+fileName);
980     }
981 
982     std::string line, tmp = "";
983     int lineIndex = 0;
984     while(std::getline(infile,line)) {
985         std::stringstream lineStream(line);
986         if (lineIndex == 2) {
987             // get upper bound
988             std::getline(lineStream, tmp, ':');
989             std::getline(lineStream, tmp, ':');
990             int high = atoi(tmp\&.c_str());
991             if (high != totNMax()) {
992                 throw customException ("Max bound ("+ std::to_string(high)+") is not Nmax("+std::to_string(totNMax())+"), cannot restart energy histogram from "+fileName);
993             }
994         } else if (lineIndex == 3) {
995             // get lower bound
996             std::getline(lineStream, tmp, ':');
997             std::getline(lineStream, tmp, ':');
998             int low = atoi(tmp\&.c_str());
999             if (low != totNMin()) {
1000                 throw customException ("Min bound ("+ std::to_string(low)+") is not Nmin("+std::to_string(totNMin())+"), cannot restart energy histogram from "+fileName);
1001             }
1002         } else if (lineIndex == 6) {
1003             // delta
1004             for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1005                 lineStream >> delta[i];
1006             }
1007         } else if (lineIndex == 8) {
1008             // lower bound
1009             for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1010                 lineStream >> lb[i];
1011             }
1012             // check that system "aligned" the lower bounds so that a bin falls centered at U = 0
1013             for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1014                 const double x = (lb[i] - 0\&.0)/delta[i];
1015                 const double err = fabs(round(x) - x);
1016                 if (err >= 1\&.0e-6) {
1017                     throw customException ("Energy bins not aligned to U = 0, cannot restart energy histogram from "+fileName+" (err, "+std::to_string(i)+") = "+std::to_string(err));
1018                 }
1019             }
1020         } else if (lineIndex == 10) {
1021             // upper bound
1022             for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1023                 lineStream >> ub[i];
1024             }
1025             // now can reinitialize the histogram
1026             for (unsigned int i = minBound; i < maxBound; ++i) {
1027                 try {
1028                     energyHistogram_[i-minBound]\&.reinitialize(lb[i-minBound], ub[i-minBound], delta[i-minBound]);
1029                 } catch (\&.\&.\&.) {
1030                     throw customException ("Unable to restart energy histogram from "+fileName);
1031                 }
1032             }
1033         } else if (lineIndex >= 12) {
1034             // histogram itself
1035             std::deque <double> h = energyHistogram_[lineIndex-12]\&.get_hist();
1036             for (std::deque <double>::iterator it = h\&.begin(); it != h\&.end(); ++it) {
1037                 lineStream >> *it;
1038             }
1039             energyHistogram_[lineIndex-12]\&.set_hist(h);
1040         }
1041         lineIndex++;
1042     }
1043     infile\&.close();
1044 }
.fi
.SS "void simSystem::restartExtMoments (const std::stringprefix, const std::vector< double > &ctr)"

.PP
Restart the extensive energy histogram for each Ntot from unnormalized checkpoint\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of the file to load from 
.br
\fIctr\fP Counter for each point in the histogram 
.RE
.PP

.PP
Definition at line 745 of file system\&.cpp\&.
.PP
References histogram::getAddress(), getMaxOrder(), histogram::getRawHistogram(), histogram::set(), totNMax(), totNMin(), and customException::what()\&.
.PP
Referenced by checkpoint::load()\&.
.PP
.nf
745                                                                                          {
746     std::string fileName = prefix+"\&.dat";
747 
748     std::ifstream infile (fileName\&.c_str());
749     if (!infile\&.is_open()) {
750         throw customException ("Cannot load extMoments from "+fileName);
751     }
752 
753     std::string line, tmp = "";
754     int lineIndex = 0, dummy;
755     long long unsigned int idx;
756     std::vector < double > h = extensive_moments_\&.getRawHistogram (), coords (6, 0);
757 
758     while(std::getline(infile,line)) {
759         std::stringstream lineStream(line);
760         if (lineIndex == 1) {
761             std::getline(lineStream, tmp, ':');
762             std::getline(lineStream, tmp, ':');
763             int ns = atoi(tmp\&.c_str());
764             if (ns != nSpecies_) {
765                 throw customException ("Number of speces in restart file ("+ std::to_string(ns)+") is not the same as provided in input ("+std::to_string(nSpecies_)+"), cannot restart extMom from "+fileName);
766             }
767         } else if (lineIndex == 2) {
768             std::getline(lineStream, tmp, ':');
769             std::getline(lineStream, tmp, ':');
770             int mo = atoi(tmp\&.c_str());
771             if (mo != getMaxOrder()) {
772                 throw customException ("Max order ("+ std::to_string(mo)+") is not the same as provided in input ("+std::to_string(getMaxOrder())+"), cannot restart extMom from "+fileName);
773             }
774         } if (lineIndex == 3) {
775             std::getline(lineStream, tmp, ':');
776             std::getline(lineStream, tmp, ':');
777             int high = atoi(tmp\&.c_str());
778             if (high != totNMax()) {
779                 throw customException ("Max bound ("+ std::to_string(high)+") is not Nmax ("+std::to_string(totNMax())+"), cannot restart extMom from "+fileName);
780             }
781         } else if (lineIndex == 4) {
782             std::getline(lineStream, tmp, ':');
783             std::getline(lineStream, tmp, ':');
784             int low = atoi(tmp\&.c_str());
785             if (low != totNMin()) {
786                 throw customException ("Min bound ("+ std::to_string(low)+") is not Nmin ("+std::to_string(totNMin())+"), cannot restart extMom from "+fileName);
787             }
788 
789             // now reinstantiate the histogram
790             std::vector < double > lbn (6,0), ubn(6,0);
791             std::vector < long long unsigned int > nbn (6,0);
792             ubn[0] = nSpecies_-1;
793             ubn[1] = max_order_;
794             ubn[2] = nSpecies_-1;
795             ubn[3] = max_order_;
796             ubn[4] = max_order_;
797             ubn[5] = totNMax()-totNMin();
798 
799             nbn[0] = nSpecies_;
800             nbn[1] = max_order_+1;
801             nbn[2] = nSpecies_;
802             nbn[3] = max_order_+1;
803             nbn[4] = max_order_+1;
804             nbn[5] = totNMax()-totNMin()+1;
805 
806             histogram hnn (lbn, ubn, nbn);
807             extensive_moments_ = hnn;
808         } else if (lineIndex >= 7) {
809             // histogram itself
810             lineStream >> dummy;
811             coords[5] = lineIndex-7;
812             for (unsigned int i = 0; i < nSpecies_; ++i) {
813                 coords[0] = i;
814                 for (unsigned int j = 0; j <= max_order_; ++j) {
815                     coords[1] = j;
816                     for (unsigned int k = 0; k < nSpecies_; ++k) {
817                         coords[2] = k;
818                         for (unsigned int m = 0; m <= max_order_; ++m) {
819                             coords[3] = m;
820                             for (unsigned int p = 0; p <= max_order_; ++p) {
821                                 coords[4] = p;
822                                 idx = extensive_moments_\&.getAddress(coords);
823                                 lineStream >> h[idx];
824                             }
825                         }
826                     }
827                 }
828             }
829         }
830         lineIndex++;
831     }
832     infile\&.close();
833 
834     try {
835         // this checks h and ctr same size, and by extension that h from file has same size as h in system
836         extensive_moments_\&.set(h, ctr);
837     } catch (customException &ce) {
838         throw customException ("Unable to restart extMom from "+fileName+" : "+ce\&.what());
839     }
840 }
.fi
.SS "void simSystem::restartPkHistogram (const std::stringprefix)"

.PP
Restart the particle histogram for each Ntot from unnormalized checkpoint\&. 
.PP
\fBParameters:\fP
.RS 4
\fIprefix\fP Prefix of the filename to load from 
.RE
.PP

.PP
Definition at line 1139 of file system\&.cpp\&.
.PP
References totNMax(), and totNMin()\&.
.PP
Referenced by checkpoint::load()\&.
.PP
.nf
1139                                                           {
1140     for (unsigned int spec = 0; spec < nSpecies_; ++spec) {
1141         int minBound = 0, maxBound = totNMax() - totNMin() + 1;
1142         std::vector < double > lb(maxBound - minBound, 0), ub(maxBound - minBound, 0), delta(maxBound - minBound, 0);
1143         std::string fileName = prefix+"_"+std::to_string(spec+1)+"\&.dat";
1144 
1145         std::ifstream infile (fileName\&.c_str());
1146         if (!infile\&.is_open()) {
1147             throw customException ("Cannot load pkHistogram from "+fileName);
1148         }
1149 
1150         std::string line, tmp = "";
1151         int lineIndex = 0;
1152         while(std::getline(infile,line)) {
1153             std::stringstream lineStream(line);
1154             if (lineIndex == 2) {
1155                 // get upper bound
1156                 std::getline(lineStream, tmp, ':');
1157                 std::getline(lineStream, tmp, ':');
1158                 int high = atoi(tmp\&.c_str());
1159                 if (high != totNMax()) {
1160                     throw customException ("Max bound ("+ std::to_string(high)+") is not Nmax("+std::to_string(totNMax())+"), cannot restart particle histogram from "+fileName);
1161                 }
1162             } else if (lineIndex == 3) {
1163                 // get lower bound
1164                 std::getline(lineStream, tmp, ':');
1165                 std::getline(lineStream, tmp, ':');
1166                 int low = atoi(tmp\&.c_str());
1167                 if (low != totNMin()) {
1168                     throw customException ("Min bound ("+ std::to_string(low)+") is not Nmin("+std::to_string(totNMin())+"), cannot restart particle histogram from "+fileName);
1169                 }
1170             } else if (lineIndex == 1) {
1171                 // check the number of species is correct
1172                 std::getline(lineStream, tmp, ':');
1173                 std::getline(lineStream, tmp, ':');
1174                 int ns = atoi(tmp\&.c_str());
1175                 if (ns != nSpecies_) {
1176                     throw customException ("Number of speces in restart file ("+ std::to_string(ns)+") is not the same as provided in input ("+std::to_string(nSpecies_)+"), cannot restart particle histogram from "+fileName);
1177                 }
1178             } else if (lineIndex == 6) {
1179                 // delta
1180                 for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1181                     lineStream >> delta[i];
1182                 }
1183             } else if (lineIndex == 8) {
1184                 // lower bound
1185                 for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1186                     lineStream >> lb[i];
1187                 }
1188             } else if (lineIndex == 10) {
1189                 // upper bound
1190                 for (unsigned int i = 0; i < maxBound-minBound; ++i) {
1191                     lineStream >> ub[i];
1192                 }
1193                 // now can reinitialize the histogram
1194                 for (unsigned int i = minBound; i < maxBound; ++i) {
1195                     try {
1196                         pkHistogram_[spec][i-minBound]\&.reinitialize(lb[i-minBound], ub[i-minBound], delta[i-minBound]);
1197                     } catch (\&.\&.\&.) {
1198                         throw customException ("Unable to restart particle histogram from "+fileName);
1199                     }
1200                 }
1201             } else if (lineIndex >= 12) {
1202                 // histogram itself
1203                 std::deque <double> h = pkHistogram_[spec][lineIndex-12]\&.get_hist();
1204                 for (std::deque <double>::iterator it = h\&.begin(); it != h\&.end(); ++it) {
1205                     lineStream >> *it;
1206                 }
1207                 pkHistogram_[spec][lineIndex-12]\&.set_hist(h);
1208             }
1209             lineIndex++;
1210         }
1211         infile\&.close();
1212     }
1213 }
.fi
.SS "const double simSystem::scratchEnergy ()"

.PP
Recalculate the energy of the system from scratch\&. 
.PP
\fBReturns:\fP
.RS 4
totU Total energy of the system 
.RE
.PP

.PP
Definition at line 1548 of file system\&.cpp\&.
.PP
References atoms, NUM_INFINITY, numSpecies, ppot, speciesBarriers, and customException::what()\&.
.PP
Referenced by readConfig(), and sanityChecks()\&.
.PP
.nf
1548                                        {
1549     double totU = 0\&.0;
1550     double V = 1\&.0;
1551 
1552     for (unsigned int i = 0; i < box_\&.size(); ++i) {
1553         V *= box_[i];
1554     }
1555 
1556     for (unsigned int spec1 = 0; spec1 < nSpecies_; ++spec1) {
1557         int num1 = 0, adj1 = 0;
1558         try {
1559             num1 = numSpecies[spec1];
1560         } catch (customException &ce) {
1561             std::string a = "Cannot recalculate energy from scratch: ", b = ce\&.what();
1562             throw customException (a+b);
1563         }
1564 
1565         // Possibly have fractionally inserted atom
1566         if (fractionalAtomType_ == spec1 && Mcurrent_ > 0) {
1567             adj1 = 1;
1568         }
1569 
1570         // Wall/barrier interactions
1571         for (unsigned int j = 0; j < num1+adj1; ++j) {
1572             double dU = 0\&.0;
1573             try {
1574                 dU = speciesBarriers[spec1]\&.energy(&atoms[spec1][j], box_);
1575             } catch (customException &ce) {
1576                 std::string a = "Cannot recalculate energy from scratch: ", b = ce\&.what();
1577                 throw customException (a+b);
1578             }
1579             if (dU == NUM_INFINITY) {
1580                 return NUM_INFINITY;
1581             } else {
1582                 totU += dU;
1583             }
1584         }
1585 
1586         // Interactions with same type
1587         for (unsigned int j = 0; j < num1+adj1; ++j) {
1588             double dU = 0\&.0;
1589             for (unsigned int k = j+1; k < num1+adj1; ++k) {
1590                 try {
1591                     dU = ppot[spec1][spec1]->energy(&atoms[spec1][j], &atoms[spec1][k], box_);
1592                 } catch (customException &ce) {
1593                     std::string a = "Cannot recalculate energy from scratch: ", b = ce\&.what();
1594                     throw customException (a+b);
1595                 }
1596                 if (dU < NUM_INFINITY) {
1597                     totU += dU;
1598                 } else {
1599                     return NUM_INFINITY;
1600                 }
1601             }
1602         }
1603 
1604         // Add tail correction to potential energy but only for atoms fully inserted
1605 #ifdef FLUID_PHASE_SIMULATIONS
1606         if ((ppot[spec1][spec1]->useTailCorrection) && (num1 > 1)) {
1607             totU += (num1)*0\&.5*ppot[spec1][spec1]->tailCorrection((num1-1)/V); // This is never infinite
1608         }
1609 #endif
1610 
1611         // Interactions with other unique types
1612         for (unsigned int spec2 = spec1+1; spec2 < nSpecies_; ++spec2) {
1613             int num2 = 0, adj2 = 0;
1614             double dU = 0\&.0;
1615 
1616             try {
1617                 num2 = numSpecies[spec2];
1618             } catch (customException &ce) {
1619                 std::string a = "Cannot recalculate energy from scratch: ", b = ce\&.what();
1620                 throw customException (a+b);
1621             }
1622 
1623             if (fractionalAtomType_ == spec2 && Mcurrent_ > 0) {
1624                 adj2 = 1;
1625             }
1626 
1627             for (unsigned int j = 0; j < num1+adj1; ++j) {
1628                 for (unsigned int k = 0; k < num2+adj2; ++k) {
1629                     try {
1630                         dU = ppot[spec1][spec2]->energy(&atoms[spec1][j], &atoms[spec2][k], box_);
1631                     } catch (customException &ce) {
1632                         std::string a = "Cannot recalculate energy from scratch: ", b = ce\&.what();
1633                         throw customException (a+b);
1634                     }
1635                     if (dU < NUM_INFINITY) {
1636                         totU += dU;
1637                     } else {
1638                         return NUM_INFINITY;
1639                     }
1640                 }
1641             }
1642 
1643             // Add tail correction to potential energy but only bewteen fully inserted species
1644 #ifdef FLUID_PHASE_SIMULATIONS
1645             if ((ppot[spec1][spec2]->useTailCorrection) && (num2 > 0) && (num1 > 0)) {
1646                 totU += (num1)*ppot[spec1][spec2]->tailCorrection(num2/V); // Never infinite
1647             }
1648 #endif
1649         }
1650     }
1651 
1652     if (toggleKE_ == true) {
1653         double ns = 0\&.0;
1654         for (unsigned int i = 0; i < nSpecies_; ++i) {
1655             ns += numSpecies[i];
1656         }
1657         totU += 1\&.5/beta_*ns; // Only adjust for FULLY-INSERTED ATOMS
1658     }
1659 
1660     return totU;
1661 }
.fi
.SS "void simSystem::setELB (const std::vector< double >elb)\fC [inline]\fP"

.PP
Assign energy lower bound from restart\&. 
.PP
Definition at line 43 of file system\&.h\&.
.PP
Referenced by checkpoint::load()\&.
.SS "void simSystem::setEUB (const std::vector< double >eub)\fC [inline]\fP"

.PP
Assign energy upper bound from restart\&. 
.PP
Definition at line 42 of file system\&.h\&.
.PP
Referenced by checkpoint::load()\&.
.SS "void simSystem::setTotNBounds (const std::vector< int > &bounds)"

.PP
Set the bounds on the total number of particles in a system\&. If not set manually, this defaults to the sum of the bounds given for each individual species in the system\&. Therefore, for single component simulations, this is identical to [minSpecies(0), maxSpecies(0)] unless otherwise set\&. These bounds are intended to be used to create 'windows' so that specific simulations can sample subregions of [minSpecies(0), maxSpecies(0)] and be stitched together with histogram reweighting later\&.
.PP
However, this routine will ALSO cause the system to reevaluate its bounds\&. If these total bounds are outside any individual bound for each atom type, nothing will change\&. However, if the upper bound for total atoms is less than an upper bound for a specific species, that species will have its bounds changed to match the total maximum\&. As a result sys\&.atoms can change so this routine should be called at the beginning of a simulation, never during\&. The total minimum will also be checked\&. That is, if the sum of the minimum for all species is still higher than this, an exception will be throw since the system will never reach such a low density anyway\&. Most likely the user has made a mistake\&.
.PP
Be sure to initialize other objects, such as biases, AFTER this routine has been called since it will adjust the allowable number of particles in the system\&.
.PP
\fBParameters:\fP
.RS 4
\fIbounds\fP Vector of [min, max] 
.RE
.PP

.PP
Definition at line 41 of file system\&.cpp\&.
.PP
References atoms, and numSpecies\&.
.PP
Referenced by initialize()\&.
.PP
.nf
41                                                               {
42     if (bounds\&.size() != 2) {
43         throw customException ("Bounds on total N must supplied as vector of <minN, maxN>");
44     }
45     if (bounds[0] < 0) {
46         throw customException ("Lower bound on total particles must be > 0");
47     }
48     if (bounds[0] > bounds[1]) {
49         throw customException ("Upper bound must be greater than lower bound for total number of particles in the system");
50     }
51     totNBounds_ = bounds;
52 
53     int totMin = 0;
54     for (unsigned int i = 0; i < nSpecies_; ++i) {
55         if (maxSpecies_[i] > totNBounds_[1]) {
56             maxSpecies_[i] = totNBounds_[1];
57         }
58         if (maxSpecies_[i] < totNBounds_[1]) {
59             throw customException ("Upper bound for species "+std::to_string(i+1)+" is lower than overall max, so cannot realize possibility of system being full of this species");
60         }
61         totMin += minSpecies_[i];
62     }
63     if (totMin > totNBounds_[0]) {
64         throw customException ("Lower total N bound is lower than the sum of all individual lower bounds, region cannot be completely sampled");
65     }
66 
67     // Recheck bounds and possibly resize
68     int tmpTot = 0;
69     for (unsigned int i = 0; i < nSpecies_; ++i) {
70         if (maxSpecies_[i] < minSpecies_[i]) {
71             throw customException ("Max species < Min species");
72         }
73         try {
74             atoms[i]\&.resize(maxSpecies_[i], atom());
75         } catch (std::exception &e) {
76             throw customException (e\&.what());
77         }
78         // If numSpecies[i] above maxSpecies_[i] for some reason, destroy the atoms beyond bound
79         if (numSpecies[i] > (int)atoms[i]\&.size()) {
80             numSpecies[i] = atoms[i]\&.size();
81         }
82         tmpTot += numSpecies[i];
83     }
84     totN_ = tmpTot;
85 
86     // Allocate space for energy matrix - this will only be recorded when the system is within the specific window we are looking for
87     // Because of implementation of Shen and Errington method, this syntax is the same for single and multicomponent systems
88     long long int size = totNBounds_[1] - totNBounds_[0] + 1;
89 
90     energyHistogram_\&.resize(0);
91     energyHistogram_lb_\&.resize(size, -5\&.0);
92     energyHistogram_ub_\&.resize(size, 5\&.0);
93 
94     for (unsigned int i = 0; i < size; ++i) {
95         try {
96             dynamic_one_dim_histogram dummyHist (energyHistogram_lb_[i], energyHistogram_ub_[i], energyHistDelta_);
97             energyHistogram_\&.resize(i+1, dummyHist);
98         } catch (std::bad_alloc &ba) {
99             throw customException ("Out of memory for energy histogram for each Ntot");
100         }
101     }
102 
103     pkHistogram_\&.resize(0);
104     dynamic_one_dim_histogram dummyPkHist (0\&.0, totNBounds_[1], 1\&.0);
105     try {
106         std::vector < dynamic_one_dim_histogram > tmp (totNBounds_[1]-totNBounds_[0]+1, dummyPkHist);
107         pkHistogram_\&.resize(nSpecies_, tmp);
108     } catch (std::bad_alloc &ba) {
109         throw customException ("Out of memory for particle histogram for each Ntot");
110     }
111 
112     // Initialize moments
113     std::vector < double > lbn (6,0), ubn(6,0);
114     std::vector < long long unsigned int > nbn (6,0);
115     ubn[0] = nSpecies_-1;
116     ubn[1] = max_order_;
117     ubn[2] = nSpecies_-1;
118     ubn[3] = max_order_;
119     ubn[4] = max_order_;
120     ubn[5] = totNBounds_[1]-totNBounds_[0];
121 
122     nbn[0] = nSpecies_;
123     nbn[1] = max_order_+1;
124     nbn[2] = nSpecies_;
125     nbn[3] = max_order_+1;
126     nbn[4] = max_order_+1;
127     nbn[5] = size;
128 
129     histogram hnn (lbn, ubn, nbn);
130     extensive_moments_ = hnn;
131 }
.fi
.SS "void simSystem::startTMMC (const long long inttmmcSweepSize, const intMtot)"

.PP
Start using TMMC and instantiate the bias object\&. Start using a transition-matrix in the simulation\&.
.PP
Throws an exception if input values are illegal or there is another problem (e\&.g\&. memory)\&.
.PP
\fBParameters:\fP
.RS 4
\fItmmcSweepSize\fP Number of times each transition in the collection matrix must be visited for a 'sweep' to be completed 
.br
\fIMtot\fP Total number of expanded ensemble state allowed within the system 
.RE
.PP

.PP
Definition at line 1750 of file system\&.cpp\&.
.PP
References tmmcBias, useTMMC, and customException::what()\&.
.PP
Referenced by checkpoint::load(), performCrossover(), and performTMMC()\&.
.PP
.nf
1750                                                                             {
1751     // initialize the tmmc object
1752     try {
1753         tmmcBias = new tmmc (totNBounds_[1], totNBounds_[0], Mtot, tmmcSweepSize, box_);
1754     } catch (customException& ce) {
1755         throw customException ("Cannot start TMMC biasing in system: "+std::to_string(*ce\&.what()));
1756     }
1757 
1758     useTMMC = true;
1759 }
.fi
.SS "void simSystem::startWALA (const doublelnF, const doubleg, const doubles, const intMtot)"

.PP
Start using Wang-Landau and instantiate the bias object\&. 
.PP
Definition at line 1733 of file system\&.cpp\&.
.PP
References useWALA, customException::what(), and wlBias\&.
.PP
Referenced by checkpoint::load(), and performWALA()\&.
.PP
.nf
1733                                                                                            {
1734     // initialize the wala object
1735     try {
1736         wlBias = new wala (lnF, g, s, totNBounds_[1], totNBounds_[0], Mtot, box_);
1737     } catch (customException& ce) {
1738         throw customException ("Cannot start Wang-Landau biasing in system: "+std::to_string(*ce\&.what()));
1739     }
1740 
1741     useWALA = true;
1742 }
.fi
.SS "void simSystem::stopTMMC ()\fC [inline]\fP"

.PP
Stop using TMMC and free the bias object\&. 
.PP
Definition at line 63 of file system\&.h\&.
.PP
References tmmcBias, and useTMMC\&.
.PP
Referenced by performTMMC()\&.
.SS "void simSystem::stopWALA ()\fC [inline]\fP"

.PP
Stop using Wang-Landau and free the bias object\&. 
.PP
Definition at line 61 of file system\&.h\&.
.PP
References useWALA, and wlBias\&.
.PP
Referenced by performCrossover()\&.
.SS "void simSystem::toggleKE ()"

.PP
Toggle KE adjustment to energy setting\&. 
.PP
Definition at line 399 of file system\&.cpp\&.
.PP
Referenced by initialize(), and setConfig()\&.
.PP
.nf
399                          {
400     if (toggleKE_ == false) {
401         toggleKE_ = true;
402     } else {
403         toggleKE_ = false;
404     }
405 }
.fi
.SS "const int simSystem::totNMax ()\fC [inline]\fP"

.PP
Return upper bound on the total number of atoms in the system\&. 
.PP
Definition at line 75 of file system\&.h\&.
.PP
Referenced by insertParticle::make(), performTMMC(), reInitializeEnergyHistogram(), restartEnergyHistogram(), restartExtMoments(), and restartPkHistogram()\&.
.SS "const int simSystem::totNMin ()\fC [inline]\fP"

.PP
Return lower bound on the total number of atoms in the system\&. 
.PP
Definition at line 76 of file system\&.h\&.
.PP
Referenced by deleteParticle::make(), performTMMC(), reInitializeEnergyHistogram(), restartEnergyHistogram(), restartExtMoments(), restartPkHistogram(), and setConfig()\&.
.SS "void simSystem::translateAtom (const inttypeIndex, const intatomIndex, std::vector< double >oldPos)"

.PP
Translate an atom in the system\&. Does all the bookkeeping behind the scenes\&. Do nothing if there is no cell list defined for the type
.PP
\fBParameters:\fP
.RS 4
\fItypeIndex\fP What type the atom is (>= 0) 
.br
\fIatomIndex\fP Which atom \fIindex\fP of type typeIndex to translate (>= 0) 
.br
\fIoldPos\fP Old position of the atom\&. The current/new position should already be stored in the atom at sys\&.atoms[typeIndex][atomIndex] 
.RE
.PP

.PP
Definition at line 378 of file system\&.cpp\&.
.PP
References atoms, and cellList::translateParticle()\&.
.PP
Referenced by aggVolBias3::make(), and translateParticle::make()\&.
.PP
.nf
378                                                                                                  {
379     if (typeIndex < nSpecies_ && typeIndex >= 0) {
380         if (atomIndex >= 0) {
381             // delete particle from appropriate cell list, move to new one
382             for (unsigned int i=0; i<nSpecies_; i++) {
383                 if (useCellList_[typeIndex][i]) {
384                     cellList* cl = cellListsByPairType_[typeIndex][i];
385                     cl->translateParticle(&atoms[typeIndex][atomIndex], oldPos);
386                 }
387             }
388         } else {
389             throw customException ("Number of those atoms in system is out of bounds, cannot translate an atom of type index "+std::to_string(typeIndex));
390         }
391     } else {
392         throw customException ("That species index does not exist, cannot translate the atom");
393     }
394 }
.fi
.SH "Field Documentation"
.PP 
.SS "std::vector< std::vector < \fBatom\fP > > simSystem::atoms"

.PP
Atoms in a matrix by type, and particle index, respectively that a system CAN hold but not all are actually 'in' the system\&. 
.PP
Definition at line 126 of file system\&.h\&.
.PP
Referenced by deleteAtom(), getNeighborAtoms(), insertAtom(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), printSnapshot(), sanityChecks(), scratchEnergy(), setTotNBounds(), simSystem(), and translateAtom()\&.
.SS "long double simSystem::crossoverTotalStepCounter"

.PP
Tracks the total MC steps taken during crossover stage\&. 
.PP
Definition at line 108 of file system\&.h\&.
.PP
Referenced by checkpoint::dump(), checkpoint::load(), performCrossover(), performTMMC(), and simSystem()\&.
.SS "double simSystem::gcmcEqSteps"

.PP
In the case of unbiased GCMC, number of equilibration steps to perform\&. 
.PP
Definition at line 102 of file system\&.h\&.
.PP
Referenced by initialize(), and performGCMC()\&.
.SS "double simSystem::gcmcPrSteps"

.PP
In the case of unbiased GCMC, number of production steps to perform\&. 
.PP
Definition at line 103 of file system\&.h\&.
.PP
Referenced by initialize(), and performGCMC()\&.
.SS "double simSystem::gcmcSnapFreq"

.PP
In the case of unbiased GCMC, frequency with which to take snapshots of the system\&. 
.PP
Definition at line 104 of file system\&.h\&.
.PP
Referenced by initialize(), and performGCMC()\&.
.SS "double simSystem::gcmcThermoFreq"

.PP
In the case of unbiased GCMC, frequency with which to record thermo properties\&. 
.PP
Definition at line 105 of file system\&.h\&.
.PP
Referenced by initialize(), and performGCMC()\&.
.SS "double simSystem::lnF_end"

.PP
Starting and ending lnF for Wang-Landau\&. 
.PP
Definition at line 100 of file system\&.h\&.
.PP
Referenced by initialize(), performWALA(), and simSystem()\&.
.SS "double simSystem::lnF_start"

.PP
Definition at line 100 of file system\&.h\&.
.PP
Referenced by initialize(), performWALA(), and simSystem()\&.
.SS "long long int simSystem::nCrossoverVisits"

.PP
Number of crossovers that must occur before switching from WALA to TMMC\&. 
.PP
Definition at line 98 of file system\&.h\&.
.PP
Referenced by initialize(), performCrossover(), and simSystem()\&.
.SS "std::vector< int > simSystem::numSpecies"

.PP
Total number of each type of atom the system contains\&. 
.PP
Definition at line 125 of file system\&.h\&.
.PP
Referenced by deleteAtom(), getNeighborAtoms(), insertAtom(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), performGCMC(), printSnapshot(), readConfig(), recordExtMoments(), recordPkHistogram(), sanityChecks(), scratchEnergy(), setConfig(), setTotNBounds(), and simSystem()\&.
.SS "std::vector< std::vector < std::shared_ptr < \fBpairPotential\fP > > > simSystem::ppot"

.PP
Matrix of pair potentials for atom types i, j\&. 
.PP
Definition at line 127 of file system\&.h\&.
.PP
Referenced by addPotential(), checkBounds(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), scratchEnergy(), setPairPotentials(), and simSystem()\&.
.SS "bool simSystem::restartFromTMMC"

.PP
Flags to restart from WALA or TMMC initially\&. 
.PP
Definition at line 93 of file system\&.h\&.
.PP
Referenced by checkpoint::checkpoint(), initialize(), performTMMC(), and simSystem()\&.
.SS "std::string simSystem::restartFromTMMCFile"

.PP
Files to restart from WALA or TMMC initially\&. 
.PP
Definition at line 123 of file system\&.h\&.
.PP
Referenced by initialize(), performTMMC(), and simSystem()\&.
.SS "bool simSystem::restartFromWALA"

.PP
Definition at line 93 of file system\&.h\&.
.PP
Referenced by initialize(), performWALA(), and simSystem()\&.
.SS "std::string simSystem::restartFromWALAFile"

.PP
Definition at line 123 of file system\&.h\&.
.PP
Referenced by initialize(), performWALA(), and simSystem()\&.
.SS "std::vector< \fBcompositeBarrier\fP > simSystem::speciesBarriers"

.PP
Barriers, if any, for each species\&. 
.PP
Definition at line 128 of file system\&.h\&.
.PP
Referenced by deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), scratchEnergy(), setBarriers(), and simSystem()\&.
.SS "\fBtmmc\fP* simSystem::tmmcBias"

.PP
TMMC biasing function\&. 
.PP
Definition at line 120 of file system\&.h\&.
.PP
Referenced by calculateBias(), getTMMCBias(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), startTMMC(), stopTMMC(), and ~simSystem()\&.
.SS "long long int simSystem::tmmcSweepSize"

.PP
Size of a sweep in TMMC\&. 
.PP
Definition at line 95 of file system\&.h\&.
.PP
Referenced by initialize(), checkpoint::load(), performCrossover(), and performTMMC()\&.
.SS "long double simSystem::tmmcTotalStepCounter"

.PP
Tracks the total MC steps taken during TMMC stage\&. 
.PP
Definition at line 109 of file system\&.h\&.
.PP
Referenced by checkpoint::dump(), checkpoint::load(), performTMMC(), and simSystem()\&.
.SS "long long int simSystem::totalTMMCSweeps"

.PP
Total number of sweeps to perform during TMMC\&. 
.PP
Definition at line 96 of file system\&.h\&.
.PP
Referenced by initialize(), performTMMC(), and simSystem()\&.
.SS "bool simSystem::useTMMC"

.PP
Logical stating whether or not to use TMMC biasing\&. 
.PP
Definition at line 91 of file system\&.h\&.
.PP
Referenced by calculateBias(), getTMMCBias(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), performTMMC(), performWALA(), simSystem(), startTMMC(), stopTMMC(), and ~simSystem()\&.
.SS "bool simSystem::useWALA"

.PP
Logical stating whether or not to use Wang-Landau biasing\&. 
.PP
Definition at line 92 of file system\&.h\&.
.PP
Referenced by calculateBias(), getWALABias(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), performCrossover(), performTMMC(), performWALA(), simSystem(), startWALA(), stopWALA(), and ~simSystem()\&.
.SS "double simSystem::wala_g"

.PP
Definition at line 101 of file system\&.h\&.
.PP
Referenced by initialize(), checkpoint::load(), performWALA(), and simSystem()\&.
.SS "double simSystem::wala_s"

.PP
Wang-Landau g and s factors\&. 
.PP
Definition at line 101 of file system\&.h\&.
.PP
Referenced by initialize(), checkpoint::load(), performWALA(), and simSystem()\&.
.SS "long double simSystem::walaTotalStepCounter"

.PP
Tracks the total MC steps taken during WALA stage\&. 
.PP
Definition at line 107 of file system\&.h\&.
.PP
Referenced by checkpoint::dump(), checkpoint::load(), performCrossover(), performTMMC(), performWALA(), and simSystem()\&.
.SS "\fBwala\fP* simSystem::wlBias"

.PP
WALA biasing function\&. 
.PP
Definition at line 121 of file system\&.h\&.
.PP
Referenced by calculateBias(), getWALABias(), startWALA(), stopWALA(), and ~simSystem()\&.
.SS "long long int simSystem::wlSweepSize"

.PP
Size of Wang-Landau sweep\&. 
.PP
Definition at line 97 of file system\&.h\&.
.PP
Referenced by initialize(), performCrossover(), performWALA(), and simSystem()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
