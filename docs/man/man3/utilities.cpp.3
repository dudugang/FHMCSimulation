.TH "/home/nam4/Desktop/sandbox/FHMCSimulation/src/utilities.cpp" 3 "Thu Dec 29 2016" "Version v0.1.0" "Flat-Histogram Monte Carlo Simulation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/nam4/Desktop/sandbox/FHMCSimulation/src/utilities.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'utilities\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBIM1\fP   2147483563"
.br
.ti -1c
.RI "#define \fBIM2\fP   2147483399"
.br
.ti -1c
.RI "#define \fBAM\fP   (1\&.0/\fBIM1\fP)"
.br
.ti -1c
.RI "#define \fBIMM1\fP   (\fBIM1\fP-1)"
.br
.ti -1c
.RI "#define \fBIA1\fP   40014"
.br
.ti -1c
.RI "#define \fBIA2\fP   40692"
.br
.ti -1c
.RI "#define \fBIQ1\fP   53668"
.br
.ti -1c
.RI "#define \fBIQ2\fP   52774"
.br
.ti -1c
.RI "#define \fBIR1\fP   12211"
.br
.ti -1c
.RI "#define \fBIR2\fP   3791"
.br
.ti -1c
.RI "#define \fBNTAB\fP   32"
.br
.ti -1c
.RI "#define \fBNDIV\fP   (1+\fBIMM1\fP/\fBNTAB\fP)"
.br
.ti -1c
.RI "#define \fBEPS\fP   1\&.2e-7"
.br
.ti -1c
.RI "#define \fBRNMX\fP   (1\&.0-\fBEPS\fP)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBsendMsg\fP (const std::string msg)"
.br
.RI "\fISend a message to std::cout\&. \fP"
.ti -1c
.RI "void \fBsendErr\fP (const std::string msg)"
.br
.RI "\fISend a message to std::cerr\&. \fP"
.ti -1c
.RI "void \fBparseJson\fP (const std::string filename, rapidjson::Document &doc)"
.br
.RI "\fIParse a JSON file and return the corresponding document\&. \fP"
.ti -1c
.RI "void \fBpauseCode\fP (long int dur)"
.br
.RI "\fIPause the code for a certain time\&. \fP"
.ti -1c
.RI "std::vector< std::string > \fBsplitstr\fP (const std::string &s, char delim)"
.br
.RI "\fIC++ explode a string\&. \fP"
.ti -1c
.RI "std::string \fBgetTimeStamp\fP ()"
.br
.RI "\fIObtain instantaneous timestamp\&. \fP"
.ti -1c
.RI "std::vector< std::vector
.br
< double > > \fBmatrixProduct\fP (std::vector< std::vector< double > > &mat1, std::vector< std::vector< double > > &mat2)"
.br
.RI "\fICompute product of 2 matrices, W = UV\&. \fP"
.ti -1c
.RI "std::vector< std::vector
.br
< double > > \fBrotationMatrix\fP (const double alpha, const double beta, const double gamma)"
.br
.RI "\fICreate 3D rotation matrix from angles (x, then y, then z) \fP"
.ti -1c
.RI "std::vector< double > \fBrandom3DSurfaceVector\fP (const double magnitude)"
.br
.RI "\fIChose a random vector sampled from a random distribution on the surface of a sphere\&. \fP"
.ti -1c
.RI "double \fBrng\fP (int *idum)"
.br
.RI "\fIRandom number generator (from Numerical Recipes) \fP"
.ti -1c
.RI "void \fBpbc\fP (std::vector< double > &pos, const std::vector< double > &box)"
.br
.RI "\fIReplace a position inside a box assuming periodic boundary conditions\&. \fP"
.ti -1c
.RI "double \fBpbcDist2\fP (const std::vector< double > &p1, const std::vector< double > &p2, const std::vector< double > &box)"
.br
.RI "\fICalculate the minimum image distance squared between two coordinates assuming periodic boundary conditions\&. \fP"
.ti -1c
.RI "bool \fBfileExists\fP (std::string fileName)"
.br
.RI "\fIFunction to check whether a given file exists or not\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBRNG_SEED\fP = -1024"
.br
.RI "\fIDefault RNG seed\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define AM   (1\&.0/\fBIM1\fP)"

.PP
Definition at line 8 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define EPS   1\&.2e-7"

.PP
Definition at line 18 of file utilities\&.cpp\&.
.SS "#define IA1   40014"

.PP
Definition at line 10 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IA2   40692"

.PP
Definition at line 11 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IM1   2147483563"

.PP
Definition at line 6 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IM2   2147483399"

.PP
Definition at line 7 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IMM1   (\fBIM1\fP-1)"

.PP
Definition at line 9 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IQ1   53668"

.PP
Definition at line 12 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IQ2   52774"

.PP
Definition at line 13 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IR1   12211"

.PP
Definition at line 14 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define IR2   3791"

.PP
Definition at line 15 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define NDIV   (1+\fBIMM1\fP/\fBNTAB\fP)"

.PP
Definition at line 17 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define NTAB   32"

.PP
Definition at line 16 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SS "#define RNMX   (1\&.0-\fBEPS\fP)"

.PP
Definition at line 19 of file utilities\&.cpp\&.
.PP
Referenced by rng()\&.
.SH "Function Documentation"
.PP 
.SS "bool fileExists (std::stringfileName)"

.PP
Function to check whether a given file exists or not\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfileName\fP Name of file to check
.RE
.PP
\fBReturns:\fP
.RS 4
If file exists 
.RE
.PP

.PP
Definition at line 271 of file utilities\&.cpp\&.
.PP
Referenced by checkpoint::checkpoint(), checkpoint::load(), and tabulated::loadPotential()\&.
.PP
.nf
271                                     {
272     struct stat stFileInfo;
273 
274     if (stat(fileName\&.c_str(),&stFileInfo) == 0)
275         return true;
276     else
277         return false;
278 }
.fi
.SS "std::string getTimeStamp ()"

.PP
Obtain instantaneous timestamp\&. 
.PP
\fBReturns:\fP
.RS 4
char* timestamp 
.RE
.PP

.PP
Definition at line 90 of file utilities\&.cpp\&.
.PP
Referenced by checkpoint::dump(), moves::print(), sendErr(), and sendMsg()\&.
.PP
.nf
90                           {
91     time_t rawtime;
92     time (&rawtime);
93     struct tm * timeinfo;
94     timeinfo = localtime (&rawtime);
95     char timestamp [80];
96     strftime (timestamp,80,"%d/%m/%Y %H:%M:%S",timeinfo);
97     std::string ans (timestamp);
98     return ans;
99 }
.fi
.SS "std::vector< std::vector < double > > matrixProduct (std::vector< std::vector< double > > &mat1, std::vector< std::vector< double > > &mat2)"

.PP
Compute product of 2 matrices, W = UV\&. 
.PP
\fBParameters:\fP
.RS 4
\fImat1\fP Matrix U 
.br
\fImat2\fP Matrix V 
.RE
.PP
\fBReturns:\fP
.RS 4
W 
.RE
.PP

.PP
Definition at line 108 of file utilities\&.cpp\&.
.PP
Referenced by rotationMatrix()\&.
.PP
.nf
108                                                                                                                                       {
109     std::vector < double > dummy (3, 0);
110     std::vector < std::vector < double > > W (3, dummy);
111 
112     for (unsigned int i = 0; i < 3; ++i) {
113         for (unsigned int j = 0; j < 3; ++j) {
114             W[i][j] = mat1[i][j]*mat2[j][i];
115         }
116     }
117 
118     return W;
119 }
.fi
.SS "void parseJson (const std::stringfilename, rapidjson::Document &doc)"

.PP
Parse a JSON file and return the corresponding document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP Input JSON document's filename 
.RE
.PP

.PP
Definition at line 44 of file utilities\&.cpp\&.
.PP
References sendMsg()\&.
.PP
Referenced by initialize(), checkpoint::load(), and setConfig()\&.
.PP
.nf
44                                                                   {
45     try {
46         FILE* fp = fopen(filename\&.c_str(), "r");
47         char readBuffer[65536];
48         rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));
49         doc\&.ParseStream(is);
50         fclose(fp);
51     } catch (\&.\&.\&.) {
52         throw customException ("Unable to parse "+filename);
53     }
54 
55     if (doc\&.IsObject()) {
56         sendMsg("Parsed JSON file "+filename);
57     } else {
58         throw customException ("Error in "+filename+", not begin detected as proper JSON document");
59     }
60 }
.fi
.SS "void pauseCode (long intdur)"

.PP
Pause the code for a certain time\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdur\fP Number of seconds to pause for 
.RE
.PP

.PP
Definition at line 67 of file utilities\&.cpp\&.
.PP
.nf
67                               {
68     long int temp = time(NULL) + dur;
69     while(temp > time(NULL));
70 }
.fi
.SS "void pbc (std::vector< double > &pos, const std::vector< double > &box)"

.PP
Replace a position inside a box assuming periodic boundary conditions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Position to be placed in box 
.br
\fIbox\fP Box dimensions 
.RE
.PP

.PP
Definition at line 227 of file utilities\&.cpp\&.
.PP
Referenced by hardWallZ::energy(), squareWellWallZ::energy(), rightTriangleXZ::energy(), hardWallZ::inside(), and squareWellWallZ::inside()\&.
.PP
.nf
227                                                                       {
228     // generally while loops are faster than round statements
229     for (unsigned int i = 0; i < pos\&.size(); ++i) {
230         while (pos[i] < 0\&.0) {
231             pos[i] += box[i];
232         }
233         while (pos[i] >= box[i]) {
234             pos[i] -= box[i];
235         }
236     }
237 }
.fi
.SS "double pbcDist2 (const std::vector< double > &p1, const std::vector< double > &p2, const std::vector< double > &box)"

.PP
Calculate the minimum image distance squared between two coordinates assuming periodic boundary conditions\&. Coordinates do not have to be in the box to begin with\&.
.PP
\fBParameters:\fP
.RS 4
\fI\\p1\fP Position 1 
.br
\fI\\p1\fP Position 2 
.br
\fI\\box\fP Box size
.RE
.PP
\fBReturns:\fP
.RS 4
d2 (distance squared) 
.RE
.PP

.PP
Definition at line 248 of file utilities\&.cpp\&.
.PP
Referenced by lennardJones::energy(), fsLennardJones::energy(), cylinderZ::energy(), tabulated::energy(), squareWell::energy(), hardCore::energy(), cylinderZ::inside(), and aggVolBias3::make()\&.
.PP
.nf
248                                                                                                                   {
249     double d2 = 0\&.0;
250     for (unsigned int i = 0; i < p2\&.size(); ++i) {
251         double dr = p2[i] - p1[i];
252         while (dr < -box[i]/2\&.0) {
253             dr += box[i];
254         }
255         while (dr > box[i]/2\&.0) {
256             dr -= box[i];
257         }
258         d2 += dr*dr;
259     }
260 
261     return d2;
262 }
.fi
.SS "std::vector< double > random3DSurfaceVector (const doublemagnitude)"

.PP
Chose a random vector sampled from a random distribution on the surface of a sphere\&. 
.PP
\fBParameters:\fP
.RS 4
\fImagnitude\fP Mangitude of the vector (radius of sphere)
.RE
.PP
\fBReturns:\fP
.RS 4
ans double3 containing coordinates of vector 
.RE
.PP

.PP
Definition at line 165 of file utilities\&.cpp\&.
.PP
References rng(), and RNG_SEED\&.
.PP
Referenced by aggVolBias3::make()\&.
.PP
.nf
165                                                                     {
166     int success = 0;
167     std::vector < double > ans (3, 0);
168     while (success == 0) {
169         double r1 = rng(&RNG_SEED), r2 = rng(&RNG_SEED), x1 = 1\&.0-2\&.0*r1, x2 = 1\&.0-2\&.0*r2;
170         double sum2 = x1*x1+x2*x2;
171         if (sum2 < 1\&.0) {
172             ans[0] = 2*x1*sqrt(1-sum2)*magnitude;
173             ans[1] = 2*x2*sqrt(1-sum2)*magnitude;
174             ans[2] = (1-2\&.0*sum2)*magnitude;
175             success = 1;
176         }
177     }
178     return ans;
179 }
.fi
.SS "double rng (int *idum)"

.PP
Random number generator (from Numerical Recipes) 
.PP
\fBParameters:\fP
.RS 4
\fIidum\fP seed
.RE
.PP
\fBReturns:\fP
.RS 4
temp Pseudo-random number between [0, 1) 
.RE
.PP

.PP
Definition at line 188 of file utilities\&.cpp\&.
.PP
References AM, IA1, IA2, IM1, IM2, IMM1, IQ1, IQ2, IR1, IR2, NDIV, NTAB, and RNMX\&.
.PP
Referenced by aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), swapParticles::make(), insertParticle::make(), moves::makeMove(), random3DSurfaceVector(), and quaternion::setRandomRot()\&.
.PP
.nf
188                        {
189     int j;
190     long k;
191     static long idum2=123456789;
192     static long iy=0;
193     static long iv[NTAB];
194     double temp;
195 
196     if (*idum <= 0) {
197         if (-(*idum) < 1) *idum=1;
198         else *idum = -(*idum);
199         idum2=(*idum);
200         for (j=NTAB+7;j>=0;j--) {
201             k=(*idum)/IQ1;
202             *idum=IA1*(*idum-k*IQ1)-k*IR1;
203             if (*idum < 0) *idum += IM1;
204             if (j < NTAB) iv[j] = *idum;
205         } iy=iv[0];
206     }
207     k=(*idum)/IQ1;
208     *idum=IA1*(*idum-k*IQ1)-k*IR1;
209     if (*idum < 0) *idum += IM1;
210     k=idum2/IQ2;
211     idum2=IA2*(idum2-k*IQ2)-k*IR2;
212     if (idum2 < 0) idum2 += IM2;
213     j=iy/NDIV;
214     iy=iv[j]-idum2;
215     iv[j] = *idum;
216     if (iy < 1) iy += IMM1;
217     if ((temp=AM*iy) > RNMX) return RNMX;
218     else return temp;
219 }
.fi
.SS "std::vector< std::vector < double > > rotationMatrix (const doublealpha, const doublebeta, const doublegamma)"

.PP
Create 3D rotation matrix from angles (x, then y, then z) 
.PP
\fBParameters:\fP
.RS 4
\fIalpha\fP Radians to rotate centers by around x-axis 
.br
\fIbeta\fP Radians to rotate centers by around y-axis 
.br
\fIgamma\fP Radians to rotate centers by around z-axis 
.RE
.PP

.PP
Definition at line 128 of file utilities\&.cpp\&.
.PP
References matrixProduct()\&.
.PP
.nf
128                                                                                                               {
129 
130     std::vector < double > dummy (3, 0);
131     std::vector < std::vector < double > > Rx (3, dummy), Ry(3, dummy), Rz(3, dummy), Ryx, Rzyx;
132 
133     // https://en\&.wikipedia\&.org/wiki/Rotation_matrix#General_rotations
134     Rx[0][0] = 1\&.0;
135     Rx[1][1] = cos(alpha);
136     Rx[1][2] = -sin(alpha);
137     Rx[2][1] = sin(alpha);
138     Rx[2][2] = cos(alpha);
139 
140     Ry[0][0] = cos(beta);
141     Ry[0][2] = sin(beta);
142     Ry[1][1] = 1\&.0;
143     Ry[2][0] = -sin(beta);
144     Ry[2][2] = cos(beta);
145 
146     Rz[0][0] = cos(gamma);
147     Rz[0][1] = -sin(gamma);
148     Rz[1][0] = sin(gamma);
149     Rz[1][1] = cos(gamma);
150     Rz[2][2] = 1\&.0;
151 
152     Ryx = matrixProduct(Ry, Rx);
153     Rzyx = matrixProduct(Rz, Ryx);
154 
155     return Rzyx;
156 }
.fi
.SS "void sendErr (const std::stringmsg)"

.PP
Send a message to std::cerr\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message as string 
.RE
.PP

.PP
Definition at line 35 of file utilities\&.cpp\&.
.PP
References getTimeStamp()\&.
.PP
Referenced by simSystem::addPotential(), checkBounds(), tabulated::energy(), initialize(), checkpoint::load(), tabulated::loadPotential(), moves::moves(), performCrossover(), performTMMC(), performWALA(), simSystem::readConfig(), sanityChecks(), setConfig(), setMoves(), setPairPotentials(), and setSystemBarriers()\&.
.PP
.nf
35                                    {
36     std::cerr << " *** ERROR: " << getTimeStamp() << " : " << msg << " *** " << std::endl;
37 }
.fi
.SS "void sendMsg (const std::stringmsg)"

.PP
Send a message to std::cout\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP Message as string 
.RE
.PP

.PP
Definition at line 26 of file utilities\&.cpp\&.
.PP
References getTimeStamp()\&.
.PP
Referenced by simSystem::addPotential(), initialize(), checkpoint::load(), tabulated::loadPotential(), parseJson(), performCrossover(), performTMMC(), performWALA(), simSystem::readConfig(), sanityChecks(), and setConfig()\&.
.PP
.nf
26                                    {
27     std::cout << getTimeStamp() << " : " << msg << std::endl;
28 }
.fi
.SS "std::vector< std::string > splitstr (const std::string &s, chardelim)"

.PP
C++ explode a string\&. 
.PP
Definition at line 75 of file utilities\&.cpp\&.
.PP
.nf
75                                                                   {
76     std::stringstream ss(s);
77     std::string item;
78     std::vector <std::string> tokens;
79     while (std::getline(ss, item, delim)) {
80         tokens\&.push_back(item);
81     }
82     return tokens;
83 }
.fi
.SH "Variable Documentation"
.PP 
.SS "int RNG_SEED = -1024"

.PP
Default RNG seed\&. 
.PP
Definition at line 3 of file utilities\&.cpp\&.
.PP
Referenced by initialize(), aggVolBias3::make(), deleteParticle::make(), translateParticle::make(), insertParticle::make(), swapParticles::make(), moves::makeMove(), random3DSurfaceVector(), and quaternion::setRandomRot()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Flat-Histogram Monte Carlo Simulation from the source code\&.
